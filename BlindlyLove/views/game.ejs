<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>모바일 테트리스+동물매치</title>
  <style>
    body {
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start; /* 상단 정렬 유지 */
      min-height: 100dvh;
      min-height: 100vh; /* Fallback */
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      position: relative; /* 자식 요소의 absolute/fixed 포지셔닝 기준 */
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 400px; /* 게임 영역 최대 너비 제한 */
      padding: 10px;
      box-sizing: border-box;
      flex-grow: 1; /* 남은 공간을 차지 */
      justify-content: flex-start; /* 콘텐츠를 상단부터 배치 */
      position: relative; /* 캔버스를 포함하는 영역 */
    }

    #score {
      font-size: 1.6rem;
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
      font-weight: bold;
      color: #38bdf8;
      z-index: 10;
    }

    #startBtn {
      padding: 0.6rem 1.5rem;
      font-size: 1.1rem;
      border: none;
      background: #38bdf8;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      transition: background 0.2s ease-in-out;
      margin-bottom: 0.8rem;
      z-index: 1001; /* 모든 요소 위에 오도록 매우 높은 z-index */
      position: relative; /* z-index 적용을 위해 필요 */
    }
    #startBtn:active { background: #258cdb; }
    #startBtn:disabled { background: #6c757d; cursor: not-allowed; }

    canvas {
      border: 3px solid #38bdf8;
      background: #000;
      margin-top: 0;
      touch-action: none; /* Prevents default touch actions like scrolling */
      width: 100%;
      height: auto;
      max-height: 60vh; /* 캔버스 높이 좀 더 제한 (컨트롤러 공간 확보) */
      flex-shrink: 0;
      z-index: 5; /* 캔버스 뒤에 오도록 */
    }

    /* Floating Controls Container (Fixed at Bottom of Screen) */
    #mobile-controls-container {
      position: fixed; /* 뷰포트에 고정 */
      bottom: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-around; /* 버튼들을 하단 중앙에 분배 */
      align-items: center; /* 세로 중앙 정렬 */
      padding: 10px; /* 패딩 추가 */
      box-sizing: border-box;
      z-index: 1000; /* 캔버스 위에, 시작 버튼 아래 (시작 버튼 Z-index가 더 높음) */
      background: rgba(17, 17, 17, 0.5); /* 하단 컨트롤 바 배경 (반투명) */
      backdrop-filter: blur(2px); /* 배경 흐림 효과 (선택 사항) */
      -webkit-backdrop-filter: blur(2px);
    }

    .control-btn {
      padding: 1.2rem 1.8rem; /* 버튼 크기 키워서 누르기 쉽게 */
      font-size: 1.8rem; /* 심볼이 커보이도록 글자 크기 키움 */
      background: rgba(74, 74, 74, 0.7); /* 반투명 배경 (더 잘 보이게) */
      color: #fff;
      border: none;
      border-radius: 12px; /* 둥근 모서리 */
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
      transition: background 0.2s ease-in-out, opacity 0.2s ease-in-out;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.9; /* 전체적인 투명도 (더 잘 보이게) */
      min-width: 80px; /* 최소 너비 확보 */
      min-height: 80px; /* 최소 높이 확보 */
    }
    .control-btn:active { background: rgba(106, 106, 106, 0.9); }
    .control-btn:disabled { background: rgba(108, 117, 125, 0.4); cursor: not-allowed; opacity: 0.5; }

    /* Specific button styling */
    #hard-drop-btn {
        background: rgba(231, 76, 60, 0.7); /* 하드 드롭 버튼 색상 반투명 */
    }
    #hard-drop-btn:active {
        background: rgba(192, 57, 43, 0.9);
    }

    /* 모바일 가로 모드 최적화 */
    @media (orientation: landscape) {
      body {
        flex-direction: row;
        justify-content: space-around;
        align-items: center;
      }
      #game-container {
        width: auto;
        padding: 5px;
        flex-direction: row;
        gap: 10px;
        flex-grow: 0;
        height: 100%;
        max-height: 100%;
        justify-content: space-around;
      }
      canvas {
        max-width: 60vw; /* 가로 모드에서 캔버스 더 넓게 사용 */
        max-height: 90vh;
      }
      #mobile-controls-container {
        position: static; /* 가로 모드에서는 플로우에 따라 배치 (fixed 해제) */
        width: auto;
        height: 100%;
        flex-direction: column; /* 세로로 버튼 그룹 배치 */
        justify-content: space-around; /* 그룹 내 버튼 분배 */
        align-items: center;
        padding: 8px;
        background: rgba(17, 17, 17, 0.5); /* 동일한 배경 */
        backdrop-filter: blur(2px);
        -webkit-backdrop-filter: blur(2px);
      }
      .control-btn {
          padding: 1rem 1.2rem; /* 가로 모드에서 버튼 크기 조정 */
          font-size: 1.6rem; /* 심볼 크기 조정 */
          min-width: 70px;
          min-height: 70px;
      }
      #score, #startBtn {
        font-size: 1.2rem;
        position: relative; /* 가로 모드에서도 z-index 유지 */
        z-index: 20;
      }
    }

    /* 매우 작은 세로 화면용 추가 조정 */
    @media (max-height: 600px) and (orientation: portrait) {
      #game-container { padding: 5px; }
      #score { font-size: 1.4rem; margin-top: 0.2rem; margin-bottom: 0.2rem; }
      #startBtn { font-size: 1rem; padding: 0.3rem 0.8rem; margin-bottom: 0.5rem; }
      canvas { max-height: 45vh; } /* 더 줄여서 하단 컨트롤 공간 확보 */
      .control-btn {
          padding: 0.8rem 1.5rem;
          font-size: 1.4rem;
          min-width: 70px;
          min-height: 70px;
          border-radius: 10px;
      }
      #mobile-controls-container { padding: 5px; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h2 id="score">점수: 0</h2>
    <button id="startBtn" disabled>게임 시작</button>
    <canvas id="tetris" width="240" height="400"></canvas>
  </div>

  <div id="mobile-controls-container">
      <button id="rotate-btn" class="control-btn">⟳</button> <button id="hard-drop-btn" class="control-btn">⇩</button> </div>

  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    ctx.scale(20, 20);

    const spriteUrls = {
      1: '/assets/images/dog.png',
      2: '/assets/images/cat.png',
      3: '/assets/images/bear.png',
      4: '/assets/images/rabbit.png',
      5: '/assets/images/monkey.png'
    };
    const spriteImgs = {};
    let imagesLoadedCount = 0;
    const totalImages = Object.keys(spriteUrls).length;

    function loadImages(callback) {
      for (let k in spriteUrls) {
        const img = new Image();
        img.src = spriteUrls[k];
        img.onload = () => {
          imagesLoadedCount++;
          if (imagesLoadedCount === totalImages) {
            callback();
          }
        };
        img.onerror = () => {
          console.error(`Failed to load image: ${spriteUrls[k]}. Check path and server.`);
          imagesLoadedCount++;
          if (imagesLoadedCount === totalImages) {
            callback();
          }
        };
        spriteImgs[k] = img;
      }
    }

    const W = 12, H = 20;
    let arena = createMatrix(W, H);
    arena.spriteMap = createMatrix(W, H);

    let player = { pos: { x: 0, y: 0 }, mat: null, imgMap: null };
    let keyState = { left: false, right: false, down: false };
    let dropCounter = 0, dropInterval = 1000, lastTime = 0, score = 0, gameRunning = false, levelUpTimer = 0, moveCounter = 0;
    let isProcessingAnimation = false;

    const moveInterval = 100;
    const colors = [null, '#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#FF922B', '#845EC2', '#00C9A7'];

    // --- Touch Gesture Variables ---
    let initialTouchX = 0;
    let initialTouchY = 0;
    let lastProcessedX = 0;
    let lastProcessedY = 0;
    let isDragging = false;
    const dragSensitivityX = 1.5; // Lower value for less sensitive drag (more pixels to move 1 block)
    const dragSensitivityY = 2.5; // Lower value for less sensitive drag down (more pixels for a drop)
    const tapThreshold = 10; // Max pixel movement for a tap (for rotation)

    function createMatrix(w, h) {
      return Array.from({ length: h }, () => Array(w).fill(0));
    }

    function createPiece(type) {
      const t = {
        T: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
        O: [[2, 2], [2, 2]],
        L: [[0, 3, 0], [0, 3, 0], [0, 3, 3]],
        J: [[0, 4, 0], [0, 4, 0], [4, 4, 0]],
        I: [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]],
        S: [[0, 6, 6], [6, 6, 0], [0, 0, 0]],
        Z: [[7, 7, 0], [0, 7, 7], [0, 0, 0]]
      };
      return t[type];
    }

    function rotateMatrix(matrix, dir) {
      const m = JSON.parse(JSON.stringify(matrix));
      for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < y; ++x) {
          [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
        }
      }
      if (dir > 0) m.forEach(row => row.reverse());
      else m.reverse();
      return m;
    }

    function drawMatrix(m, off, alpha = 1) {
      ctx.globalAlpha = alpha;
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          const v = m[y][x];
          if (v) {
            const px = x + off.x, py = y + off.y;
            const grad = ctx.createLinearGradient(px, py, px + 1, py + 1);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(1, colors[v]);
            ctx.fillStyle = grad;
            ctx.fillRect(px, py, 1, 1);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.08;
            ctx.strokeRect(px, py, 1, 1);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(px, py, 1, 0.2);

            let imgId = null;
            if (m === player.mat && off === player.pos && player.imgMap) {
              imgId = player.imgMap[y][x];
            } else if (m === arena) {
              imgId = arena.spriteMap?.[y]?.[x];
            }

            if (imgId && spriteImgs[imgId]?.complete && spriteImgs[imgId].naturalWidth > 0) {
              ctx.drawImage(spriteImgs[imgId], px + 0.1, py + 0.1, 0.8, 0.8);
            }
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawGhost() {
      const g = { pos: { ...player.pos }, mat: player.mat, imgMap: player.imgMap };
      while (!collide(arena, g)) g.pos.y++;
      g.pos.y--;
      drawMatrix(g.mat, g.pos, 0.3);
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawMatrix(arena, { x: 0, y: 0 });
      drawGhost();
      drawMatrix(player.mat, player.pos);
    }

    function collide(ar, pl) {
      const m = pl.mat, o = pl.pos;
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (m[y][x] !== 0 &&
              (ar[y + o.y] && ar[y + o.y][x + o.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    function merge(ar, pl) {
      pl.mat.forEach((row, y) => {
        row.forEach((v, x) => {
          if (v) {
            ar[y + pl.pos.y][x + pl.pos.x] = v;
            arena.spriteMap[y + pl.pos.y][x + pl.pos.x] = player.imgMap[y][x];
          }
        });
      });
    }

    function applyGravityAfterMatch() {
        let movedAnything = false;
        for (let x = 0; x < W; x++) {
            let filledCells = [];
            for (let y = H - 1; y >= 0; y--) {
                if (arena[y][x] !== 0) {
                    filledCells.push({ value: arena[y][x], sprite: arena.spriteMap[y][x] });
                }
            }

            for (let y = 0; y < H; y++) {
                arena[y][x] = 0;
                arena.spriteMap[y][x] = 0;
            }

            let currentY = H - 1;
            for (let i = 0; i < filledCells.length; i++) {
                arena[currentY][x] = filledCells[i].value;
                arena.spriteMap[currentY][x] = filledCells[i].sprite;
                if (currentY !== (H - 1 - i)) {
                    movedAnything = true;
                }
                currentY--;
            }
        }
        return movedAnything;
    }

    function findConnectedMatches() {
        const m = arena.spriteMap;
        const matchedCoords = new Set();
        const matchLength = 4;
        const visited = createMatrix(W, H);

        function dfs(y, x, targetValue, currentCluster) {
            if (y < 0 || y >= H || x < 0 || x >= W || visited[y][x] || m[y][x] !== targetValue) {
                return;
            }

            visited[y][x] = 1;
            currentCluster.push([y, x]);

            dfs(y + 1, x, targetValue, currentCluster);
            dfs(y - 1, x, targetValue, currentCluster);
            dfs(y, x + 1, targetValue, currentCluster);
            dfs(y, x - 1, targetValue, currentCluster);
        }

        for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
                const value = m[y][x];
                if (value !== 0 && !visited[y][x]) {
                    const currentCluster = [];
                    dfs(y, x, value, currentCluster);

                    if (currentCluster.length >= matchLength) {
                        currentCluster.forEach(coord => {
                            matchedCoords.add(JSON.stringify(coord));
                        });
                    }
                }
            }
        }
        return Array.from(matchedCoords).map(JSON.parse);
    }

    function clearMatchedBlocks(toDel) {
        toDel.forEach(([yy, xx]) => {
            arena[yy][xx] = 0;
            arena.spriteMap[yy][xx] = 0;
        });
    }

    async function animateMatch(toDel) {
        const flashColor = 'rgba(255, 255, 0, 0.8)';
        const boundaryFlashColor = 'rgba(0, 255, 255, 0.9)';

        // 1단계: 매치된 블록 경계 번쩍임 (현재 상태 위에 그림)
        ctx.lineWidth = 0.15;
        for (let i = 0; i < 2; i++) { // 두 번 깜빡임
            ctx.strokeStyle = boundaryFlashColor;
            ctx.globalAlpha = 1;
            toDel.forEach(([yy, xx]) => {
                ctx.strokeRect(xx, yy, 1, 1);
            });
            await new Promise(resolve => setTimeout(resolve, 40));

            // 경계선 지우기 위해 다시 그림 (이전 게임 상태로 복귀)
            draw(); 
            await new Promise(resolve => setTimeout(resolve, 40));
        }
        ctx.lineWidth = 0.08;

        // 2단계: 매치된 블록 글로우 효과
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = flashColor;
        toDel.forEach(([yy, xx]) => {
            ctx.fillRect(xx, yy, 1, 1);
        });
        ctx.globalAlpha = 1;
        await new Promise(resolve => setTimeout(resolve, 80));
        
        // 글로우 효과 지우기 위해 다시 그림
        draw(); 
    }

    async function processMatches() {
        if (isProcessingAnimation) {
             return;
        }

        isProcessingAnimation = true;
        toggleControlButtons(false);

        let chainCount = 0;

        do {
            let foundMatchThisIteration = false;
            let clearedLineThisIteration = 0;

            const matches = findConnectedMatches();
            if (matches.length > 0) {
                foundMatchThisIteration = true;
                chainCount++;

                await animateMatch(matches);
                clearMatchedBlocks(matches);
                score += matches.length * 10 * chainCount;
                updateScore();
                
                dropInterval = Math.min(1000, dropInterval + (matches.length * 20)); // Speed adjustment
                
                draw(); 
                await new Promise(resolve => setTimeout(resolve, 100));

                const moved = applyGravityAfterMatch();
                draw();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const linesCleared = arenaSweep();
            if (linesCleared > 0) {
                clearedLineThisIteration = linesCleared;
                draw();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            if (!foundMatchThisIteration && clearedLineThisIteration === 0) {
                break;
            }

        } while (true);

        isProcessingAnimation = false;
        toggleControlButtons(true);
    }

    function arenaSweep() {
      let rowsRemoved = 0;
      for (let y = H - 1; y >= 0; y--) {
        if (arena[y].every(v => v !== 0)) {
          rowsRemoved++;
          arena.splice(y, 1);
          arena.unshift(Array(W).fill(0));
          arena.spriteMap.splice(y, 1);
          arena.spriteMap.unshift(Array(W).fill(0));
          y++;
        }
      }
      if (rowsRemoved > 0) {
        score += rowsRemoved * 100;
        dropInterval = Math.max(100, dropInterval - rowsRemoved * 50);
        updateScore();
      }
      return rowsRemoved;
    }

    function updateScore() { document.getElementById('score').innerText = `점수: ${score}`; }

    function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        playerReset();
        processMatches();
      }
      dropCounter = 0;
    }

    function playerHardDrop() {
      if (isProcessingAnimation) return;
      while (!collide(arena, player)) player.pos.y++;
      player.pos.y--;
      merge(arena, player);
      playerReset();
      processMatches();
      dropCounter = 0;
    }

    function playerMove(dir) {
      if (isProcessingAnimation) return;
      player.pos.x += dir;
      if (collide(arena, player)) player.pos.x -= dir;
    }

    function playerRotate(dir) {
      if (isProcessingAnimation) return;

      const pos = player.pos.x;
      let offset = 1;
      const rotMat = rotateMatrix(player.mat, dir);
      const rotImg = rotateMatrix(player.imgMap, dir);
      player.mat = rotMat;
      player.imgMap = rotImg;

      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.mat[0].length) {
          player.mat = rotateMatrix(player.mat, -dir);
          player.imgMap = rotateMatrix(player.imgMap, -dir);
          player.pos.x = pos;
          return;
        }
      }
    }

    function playerReset() {
      const types = 'TJLOSZI';
      player.mat = createPiece(types[Math.floor(Math.random() * 7)]);
      player.imgMap = player.mat.map(row => row.map(v => v ? String(Math.ceil(Math.random() * 5)) : 0));
      player.pos.y = 0;
      player.pos.x = (W / 2 | 0) - (player.mat[0].length / 2 | 0);

      if (collide(arena, player)) {
        gameRunning = false;
        alert(`게임 종료! 최종 점수: ${score}`);
        toggleControlButtons(false);
        document.getElementById('startBtn').disabled = false;
      }
    }

    function update(time = 0) {
      if (!gameRunning) return;

      const dt = time - lastTime;
      lastTime = time;

      dropCounter += dt;
      levelUpTimer += dt;
      moveCounter += dt;

      if (dropCounter > dropInterval) {
        playerDrop();
      }

      if (levelUpTimer > 15000) {
        dropInterval = Math.max(100, dropInterval - 50);
        levelUpTimer = 0;
      }

      if (moveCounter > moveInterval) {
        if (keyState.left) playerMove(-1);
        if (keyState.right) playerMove(1);
        if (keyState.down) playerDrop();
        moveCounter = 0;
      }

      draw();
      requestAnimationFrame(update);
    }

    function toggleControlButtons(enable) {
        const buttons = document.querySelectorAll('.control-btn');
        buttons.forEach(button => {
            // 게임이 실행 중이 아닐 때는 모든 버튼 비활성화 (시작 버튼 제외)
            if (!gameRunning && button.id !== 'startBtn') {
                button.disabled = true;
            } else {
                button.disabled = !enable;
            }
        });
    }

    // --- Touch Gesture Implementation (Canvas Area) ---
    let initialTouchX = 0;
    let initialTouchY = 0;
    let lastProcessedX = 0;
    let lastProcessedY = 0;
    let isDragging = false;
    // 터치 민감도 조정 (이 값을 낮추면 더 적은 드래그로 움직임)
    const dragSensitivityX = 1.5; // X축 드래그 민감도 (작을수록 민감)
    const dragSensitivityY = 2.0; // Y축 드래그 민감도 (작을수록 민감)
    const tapThreshold = 10; // 탭으로 간주할 최대 이동 거리 (픽셀)

    // 캔버스 자체에 터치 이벤트 리스너 추가
    canvas.addEventListener('touchstart', (e) => {
        if (!gameRunning || isProcessingAnimation) return;
        isDragging = false;
        const touch = e.touches[0];
        initialTouchX = touch.clientX;
        initialTouchY = touch.clientY;
        lastProcessedX = touch.clientX; // 드래그 시작점을 현재 처리점으로 설정
        lastProcessedY = touch.clientY;
        e.preventDefault(); // 기본 브라우저 동작(스크롤, 확대/축소) 방지
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        if (!gameRunning || isProcessingAnimation || e.touches.length > 1) return; // 게임 중이 아니거나 애니메이션 중이거나 멀티터치면 무시
        const touch = e.touches[0];
        const currentX = touch.clientX;
        const currentY = touch.clientY;

        const deltaX = currentX - lastProcessedX;
        const deltaY = currentY - lastProcessedY;

        // 가로 이동 (좌/우)
        // 블록 한 칸 이동에 필요한 픽셀 거리 계산 (캔버스 너비 / 블록 개수 / 민감도)
        if (Math.abs(deltaX) >= (canvas.offsetWidth / W / dragSensitivityX)) {
            if (deltaX > 0) {
                playerMove(1); // 오른쪽 이동
            } else {
                playerMove(-1); // 왼쪽 이동
            }
            lastProcessedX = currentX; // 처리 완료된 위치 업데이트
            isDragging = true; // 드래그 중임을 표시
        }

        // 세로 소프트 드롭 (아래로)
        // 블록 한 칸 드롭에 필요한 픽셀 거리 계산 (캔버스 높이 / 블록 개수 / 민감도)
        if (deltaY >= (canvas.offsetHeight / H / dragSensitivityY)) {
            playerDrop(); // 소프트 드롭
            lastProcessedY = currentY; // 처리 완료된 위치 업데이트
            isDragging = true; // 드래그 중임을 표시
        }
        e.preventDefault(); // 기본 브라우저 동작 방지
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        if (!gameRunning || isProcessingAnimation) return;

        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;

        const totalDeltaX = Math.abs(touchEndX - initialTouchX);
        const totalDeltaY = Math.abs(touchEndY - initialTouchY);

        // 짧은 탭 (드래그가 아닐 경우) 회전 동작
        if (totalDeltaX < tapThreshold && totalDeltaY < tapThreshold && !isDragging) {
            playerRotate(1); // 시계 방향 단일 회전
        }
        isDragging = false; // 드래그 상태 초기화
        e.preventDefault(); // 기본 브라우저 동작 방지
    }, { passive: false });


    // 키보드 이벤트 리스너 (PC 디버깅용, 모바일에서는 사용 안 함)
    document.addEventListener('keydown', e => {
      if (!gameRunning || isProcessingAnimation) return;
      if (e.key === 'ArrowLeft') keyState.left = true;
      else if (e.key === 'ArrowRight') keyState.right = true;
      else if (e.key === 'ArrowDown') keyState.down = true;
      else if (e.key === ' ') { e.preventDefault(); playerHardDrop(); }
      else if (e.key === 'q' || e.key === 'w') playerRotate(1);
    });
    document.addEventListener('keyup', e => {
      if (!gameRunning || isProcessingAnimation) return;
      if (e.key === 'ArrowLeft') keyState.left = false;
      if (e.key === 'ArrowRight') keyState.right = false;
      if (e.key === 'ArrowDown') keyState.down = false;
    });

    // 모바일 버튼 리스너 (회전, 하드 드롭)
    document.getElementById('rotate-btn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!gameRunning || isProcessingAnimation) return; // 추가적인 안전장치
        playerRotate(1);
    });
    document.getElementById('hard-drop-btn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!gameRunning || isProcessingAnimation) return; // 추가적인 안전장치
        playerHardDrop();
    });


    document.getElementById('startBtn').onclick = () => {
      if (!gameRunning) {
        gameRunning = true;
        dropInterval = 1000;
        levelUpTimer = 0;
        score = 0;
        updateScore();
        arena = createMatrix(W, H);
        arena.spriteMap = createMatrix(W, H);
        playerReset();
        lastTime = performance.now();
        toggleControlButtons(true);
        document.getElementById('startBtn').disabled = true;
        update();
      }
    };

    loadImages(() => {
      document.getElementById('startBtn').disabled = false;
      console.log('All images loaded!');
    });

    updateScore();
    toggleControlButtons(false); // 게임 시작 전에는 컨트롤 버튼 비활성화
  </script>
</body>
</html>