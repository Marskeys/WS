<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>테트리스+동물매치</title>
  <style>
    body {
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden; /* 모바일에서 스크롤 방지 */
    }
    #score {
      font-size: 1.4rem;
      margin-top: 1rem;
    }
    #startBtn, #fullscreenBtn {
      padding: 0.5rem 1.2rem;
      margin: 0.5rem 0.2rem;
      font-size: 1rem;
      border: none;
      background: #38bdf8;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
    }
    #buttonContainer {
      display: flex;
      justify-content: center;
      margin-top: 1rem;
      gap: 10px; /* 버튼 간격 */
      flex-wrap: wrap; /* 작은 화면에서 버튼 줄바꿈 */
    }
    .game-button {
      padding: 1.2rem 1.8rem;
      font-size: 1.5rem;
      border: none;
      background: #6a0dad; /* 보라색 계열 */
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      flex: 1; /* flex item으로 공간 분배 */
      min-width: 80px; /* 최소 너비 설정 */
    }
    canvas {
      border: 3px solid #38bdf8;
      background: #000;
      margin-top: 1rem;
      touch-action: none; /* 캔버스 터치 액션 비활성화 (모바일 줌 방지) */
    }

    /* 모바일 가로 모드 최적화 */
    @media (orientation: landscape) {
      body {
        flex-direction: row;
        justify-content: space-around;
        align-items: center;
      }
      canvas {
        margin: 0 1rem;
      }
      #gameInfo {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #buttonContainer {
        flex-direction: column; /* 가로 모드에서 버튼 세로 정렬 */
        margin-left: 1rem;
      }
      .game-button {
        min-width: unset;
        width: 120px; /* 가로 모드에서 버튼 너비 고정 */
        margin-bottom: 10px;
      }
    }
  </style>
</head>
<body>
  <div id="gameInfo">
    <h2 id="score">점수: 0</h2>
    <div>
      <button id="startBtn">게임 시작</button>
      <button id="fullscreenBtn">전체 화면</button>
    </div>
  </div>
  <canvas id="tetris" width="240" height="400"></canvas>
  <div id="buttonContainer">
    <button class="game-button" id="moveLeftBtn">◀</button>
    <button class="game-button" id="rotateLeftBtn">↺</button>
    <button class="game-button" id="dropBtn">▼</button>
    <button class="game-button" id="rotateRightBtn">↻</button>
    <button class="game-button" id="moveRightBtn">▶</button>
    <button class="game-button" id="hardDropBtn">⚡</button>
  </div>

  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    // 캔버스 스케일은 반응형에서 동적으로 설정
    let scale = 20;

    const spriteUrls = {
      1: '/assets/images/dog.png',
      2: '/assets/images/cat.png',
      3: '/assets/images/bear.png',
      4: '/assets/images/rabbit.png',
      5: '/assets/images/monkey.png'
    };
    const spriteImgs = {};
    let imagesLoaded = 0;
    const totalImages = Object.keys(spriteUrls).length;

    function loadImages(callback) {
      if (totalImages === 0) {
        callback();
        return;
      }
      for (let k in spriteUrls) {
        const img = new Image();
        img.src = spriteUrls[k];
        img.onload = () => {
          spriteImgs[k] = img;
          imagesLoaded++;
          if (imagesLoaded === totalImages) {
            callback(); // 모든 이미지 로드 완료 시 콜백 호출
          }
        };
        img.onerror = () => {
          console.error(`Error loading image: ${spriteUrls[k]}`);
          imagesLoaded++;
          if (imagesLoaded === totalImages) {
            callback();
          }
        };
      }
    }

    const W = 12, H = 20;
    let arena = createMatrix(W, H);
    arena.spriteMap = createMatrix(W, H); // 아레나 스프라이트 맵 추가
    let player = { pos: { x: 0, y: 0 }, mat: null, imgMap: null };
    let keyState = { left: false, right: false, down: false };
    let dropCounter = 0, dropInterval = 1000, lastTime = 0, score = 0, gameRunning = false, levelUpTimer = 0, moveCounter = 0;
    const moveInterval = 100;
    const colors = [null, '#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#FF922B', '#845EC2', '#00C9A7'];

    // 캔버스 크기 및 스케일 조절 함수
    function resizeCanvas() {
      const aspectRatio = W / H; // 12 / 20 = 0.6
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;

      let canvasWidth, canvasHeight;

      if (screenHeight * aspectRatio > screenWidth) { // 높이가 더 제한적일 때 (주로 가로 모드)
        canvasWidth = screenWidth * 0.5; // 화면 너비의 절반 사용 (버튼 공간 확보)
        canvasHeight = canvasWidth / aspectRatio;
      } else { // 너비가 더 제한적일 때 (주로 세로 모드)
        canvasHeight = screenHeight * 0.6; // 화면 높이의 절반 이상 사용 (버튼 공간 확보)
        canvasWidth = canvasHeight * aspectRatio;
      }

      // 캔버스 최대 크기 제한 (너무 커지는 것을 방지)
      const maxCanvasHeight = 600;
      const maxCanvasWidth = maxCanvasHeight * aspectRatio;
      if (canvasHeight > maxCanvasHeight) {
        canvasHeight = maxCanvasHeight;
        canvasWidth = maxCanvasWidth;
      }

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      scale = canvas.width / W; // 스케일 재계산
      ctx.setTransform(scale, 0, 0, scale, 0, 0); // 스케일 적용
    }

    function createMatrix(w, h) {
      return Array.from({ length: h }, () => Array(w).fill(0));
    }

    function createPiece(type) {
      const t = {
        T: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
        O: [[2, 2], [2, 2]],
        L: [[0, 3, 0], [0, 3, 0], [0, 3, 3]],
        J: [[0, 4, 0], [0, 4, 0], [4, 4, 0]],
        I: [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]],
        S: [[0, 6, 6], [6, 6, 0], [0, 0, 0]],
        Z: [[7, 7, 0], [0, 7, 7], [0, 0, 0]]
      };
      return t[type];
    }

    function rotateMatrix(matrix, dir) {
      const m = JSON.parse(JSON.stringify(matrix));
      for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < y; ++x) {
          [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
        }
      }
      if (dir > 0) m.forEach(row => row.reverse());
      else m.reverse();
      return m;
    }

    function drawMatrix(m, off, alpha = 1) {
      ctx.globalAlpha = alpha;
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          const v = m[y][x];
          if (v) {
            const px = x + off.x, py = y + off.y;
            const grad = ctx.createLinearGradient(px, py, px + 1, py + 1);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(1, colors[v]);
            ctx.fillStyle = grad;
            ctx.fillRect(px, py, 1, 1);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 0.08;
            ctx.strokeRect(px, py, 1, 1);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(px, py, 1, 0.2);

            let imgId = null;
            if (m === player.mat && off === player.pos && player.imgMap) {
              imgId = player.imgMap[y][x];
            } else if (m === arena) {
              imgId = arena.spriteMap?.[y]?.[x];
            }
            if (imgId && spriteImgs[imgId]?.complete && spriteImgs[imgId].naturalWidth) {
              ctx.drawImage(spriteImgs[imgId], px + 0.1, py + 0.1, 0.8, 0.8);
            }
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawGhost() {
      const g = { pos: { ...player.pos }, mat: player.mat, imgMap: player.imgMap };
      while (!collide(arena, g)) g.pos.y++;
      g.pos.y--;
      drawMatrix(g.mat, g.pos, 0.3);
    }

    function draw() {
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale); // 스케일 고려하여 배경 채우기
      drawMatrix(arena, { x: 0, y: 0 });
      drawGhost();
      drawMatrix(player.mat, player.pos);
    }

    function collide(ar, pl) {
      const m = pl.mat, o = pl.pos;
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (m[y][x] && (ar[y + o.y] && ar[y + o.y][x + o.x]) !== 0) return true;
        }
      }
      return false;
    }

    function merge(ar, pl) {
      pl.mat.forEach((row, y) => {
        row.forEach((v, x) => {
          if (v) {
            ar[y + pl.pos.y][x + pl.pos.x] = v;
            arena.spriteMap[y + pl.pos.y][x + pl.pos.x] = player.imgMap[y][x];
          }
        });
      });
    }

    function applyGravity() {
      for (let x = 0; x < W; x++) {
        let col = [];
        for (let y = H - 1; y >= 0; y--) {
          if (arena[y][x]) {
            col.push({ value: arena[y][x], sprite: arena.spriteMap[y][x] });
            arena[y][x] = 0; arena.spriteMap[y][x] = 0;
          }
        }
        let y = H - 1;
        col.forEach(cell => {
          arena[y][x] = cell.value;
          arena.spriteMap[y][x] = cell.sprite;
          y--;
        });
      }
    }

    function matchAnimals() {
      const m = arena.spriteMap;
      const toDel = [];
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          const v = m[y][x];
          if (!v) continue;
          [[1, 0], [0, 1], [1, 1], [1, -1]].forEach(d => {
            const line = [];
            for (let k = 0; k < 3; k++) {
              const nx = x + d[0] * k, ny = y + d[1] * k;
              if (m[ny] && m[ny][nx] === v) line.push([ny, nx]);
            }
            if (line.length === 3) toDel.push(...line);
          });
        }
      }
      if (toDel.length) {
        // 중복 제거
        const uniqueToDel = Array.from(new Set(toDel.map(JSON.stringify)), JSON.parse);
        uniqueToDel.forEach(([yy, xx]) => {
          arena[yy][xx] = 0;
          arena.spriteMap[yy][xx] = 0;
        });
        score += uniqueToDel.length * 5;
        dropInterval = Math.max(100, dropInterval - uniqueToDel.length * 20); // 점수 획득 시 낙하 속도 증가
        updateScore();
        applyGravity();
      }
    }


    function arenaSweep() {
      let rows = 0;
      for (let y = H - 1; y >= 0; y--) {
        if (arena[y].every(v => v !== 0)) { // 0이 아닌 값으로 가득 찼는지 확인
          rows++;
          arena.splice(y, 1); arena.unshift(Array(W).fill(0));
          arena.spriteMap.splice(y, 1); arena.spriteMap.unshift(Array(W).fill(0));
          y++;
        }
      }
      if (rows) {
        score += rows * 100; // 한 줄 제거 점수 증가
        dropInterval = Math.max(100, dropInterval - rows * 50);
        updateScore();
      }
      matchAnimals(); // 줄 제거 후에도 동물 매칭 확인
    }

    function updateScore() { document.getElementById('score').innerText = `점수: ${score}`; }

    function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
      }
      dropCounter = 0;
    }

    function playerHardDrop() {
      while (!collide(arena, player)) player.pos.y++;
      player.pos.y--;
      merge(arena, player);
      playerReset();
      arenaSweep();
      dropCounter = 0;
    }

    function playerMove(dir) { player.pos.x += dir; if (collide(arena, player)) player.pos.x -= dir; }

    function playerRotate(dir) {
      const pos = player.pos.x;
      let offset = 1;
      const rotMat = rotateMatrix(player.mat, dir);
      const rotImg = rotateMatrix(player.imgMap, dir);
      player.mat = rotMat;
      player.imgMap = rotImg;
      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.mat[0].length || offset < -player.mat[0].length) { // 벽차기 회전 로직 개선
          player.mat = rotateMatrix(player.mat, -dir);
          player.imgMap = rotateMatrix(player.imgMap, -dir);
          player.pos.x = pos;
          return;
        }
      }
    }

    function playerReset() {
      const types = 'TJLOSZI';
      player.mat = createPiece(types[Math.floor(Math.random() * 7)]);
      // 동물 스프라이트 ID를 1부터 5까지 랜덤으로 할당
      player.imgMap = player.mat.map(row => row.map(v => v ? String(Math.ceil(Math.random() * 5)) : 0));
      player.pos.y = 0;
      player.pos.x = (W / 2 | 0) - (player.mat[0].length / 2 | 0);
      if (collide(arena, player)) {
        gameRunning = false;
        alert(`게임 종료! 최종 점수: ${score}`);
      }
    }

    function update(time = 0) {
      if (!gameRunning) return;
      const dt = time - lastTime; lastTime = time;
      dropCounter += dt; levelUpTimer += dt; moveCounter += dt;
      if (dropCounter > dropInterval) playerDrop();
      if (levelUpTimer > 10000) { dropInterval = Math.max(100, dropInterval - 100); levelUpTimer = 0; }
      if (moveCounter > moveInterval) {
        if (keyState.left) playerMove(-1);
        if (keyState.right) playerMove(1);
        if (keyState.down) playerDrop();
        moveCounter = 0;
      }
      draw();
      requestAnimationFrame(update);
    }

    // 키보드 이벤트
    document.addEventListener('keydown', e => {
      if (!gameRunning) return;
      if (e.key === 'ArrowLeft') keyState.left = true;
      else if (e.key === 'ArrowRight') keyState.right = true;
      else if (e.key === 'ArrowDown') keyState.down = true;
      else if (e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); playerHardDrop(); } // 스페이스바 또는 위쪽 화살표로 하드 드롭
      else if (e.key === 'q' || e.key === 'z') playerRotate(-1);
      else if (e.key === 'w' || e.key === 'x') playerRotate(1);
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft') keyState.left = false;
      if (e.key === 'ArrowRight') keyState.right = false;
      if (e.key === 'ArrowDown') keyState.down = false;
    });

    // 터치 조작 버튼 이벤트 리스너
    document.getElementById('moveLeftBtn').addEventListener('touchstart', (e) => { e.preventDefault(); playerMove(-1); });
    document.getElementById('moveRightBtn').addEventListener('touchstart', (e) => { e.preventDefault(); playerMove(1); });
    document.getElementById('dropBtn').addEventListener('touchstart', (e) => { e.preventDefault(); playerDrop(); });
    document.getElementById('hardDropBtn').addEventListener('touchstart', (e) => { e.preventDefault(); playerHardDrop(); });
    document.getElementById('rotateLeftBtn').addEventListener('touchstart', (e) => { e.preventDefault(); playerRotate(-1); });
    document.getElementById('rotateRightBtn').addEventListener('touchstart', (e) => { e.preventDefault(); playerRotate(1); });

    // 터치 이벤트를 통한 연속 이동/낙하 방지를 위해 touchend에서도 처리
    document.querySelectorAll('.game-button').forEach(button => {
      button.addEventListener('touchend', (e) => { e.preventDefault(); });
    });


    // 게임 시작 버튼
    document.getElementById('startBtn').onclick = () => {
      if (gameRunning) return; // 이미 게임 중이면 시작하지 않음
      gameRunning = true;
      dropInterval = 1000; levelUpTimer = 0; score = 0;
      updateScore();
      arena = createMatrix(W, H);
      arena.spriteMap = createMatrix(W, H);
      playerReset();
      update();
    };

    // 전체 화면 버튼
    document.getElementById('fullscreenBtn').addEventListener('click', () => {
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.mozRequestFullScreen) { /* Firefox */
        document.documentElement.mozRequestFullScreen();
      } else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
        document.documentElement.webkitRequestFullscreen();
      } else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */
        document.documentElement.msRequestFullscreen();
      }
    });

    // 화면 크기 변경 시 캔버스 크기 재조정
    window.addEventListener('resize', resizeCanvas);

    // 페이지 로드 시 이미지 로드 및 초기화
    window.onload = () => {
      loadImages(() => {
        resizeCanvas(); // 이미지 로드 후 캔버스 초기 크기 설정
      });
    };

    // 추가: 게임 오버 시 시작 버튼 활성화
    const originalAlert = window.alert;
    window.alert = function(message) {
        originalAlert(message);
        document.getElementById('startBtn').disabled = false; // 게임 종료 후 시작 버튼 활성화
    };
    document.getElementById('startBtn').disabled = true; // 이미지 로드 전까지 비활성화
  </script>
</body>
</html>