<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>모바일 테트리스+동물매치</title>
  <style>
    body {
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100dvh;
      min-height: 100vh; /* Fallback */
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      position: relative;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 400px;
      padding: 10px;
      box-sizing: border-box;
      min-height: 0;
      flex-grow: 1;
      justify-content: flex-start;
      position: relative; /* Controls will be absolutely positioned relative to this */
    }

    #score {
      font-size: 1.6rem;
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
      font-weight: bold;
      color: #38bdf8;
      z-index: 10;
    }

    #startBtn {
      padding: 0.6rem 1.5rem;
      font-size: 1.1rem;
      border: none;
      background: #38bdf8;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      transition: background 0.2s ease-in-out;
      margin-bottom: 0.8rem;
      z-index: 10;
    }
    #startBtn:active {
        background: #258cdb;
    }
    #startBtn:disabled {
        background: #6c757d;
        cursor: not-allowed;
    }

    canvas {
      border: 3px solid #38bdf8;
      background: #000;
      margin-top: 0;
      touch-action: none; /* Prevents default touch actions like scrolling */
      width: 100%;
      height: auto;
      max-height: 70vh; /* Allow more canvas height as controls are overlaid */
      flex-shrink: 0;
      z-index: 5; /* Canvas behind overlay controls */
    }

    /* New/Revised Controls Layout for Overlay */
    #overlay-controls {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%; /* Covers the game-container (which includes canvas) */
      display: flex; /* Use flexbox for simple positioning */
      justify-content: space-between; /* Space out the left and right groups */
      align-items: flex-end; /* Align buttons to the bottom */
      padding: 10px;
      box-sizing: border-box;
      pointer-events: none; /* Allows clicks to pass through to canvas *unless* on a button */
      z-index: 15; /* Above canvas, below score/start button */
    }

    .control-group {
        display: flex;
        flex-direction: column; /* Buttons stack vertically */
        gap: 10px; /* Space between buttons in a group */
        pointer-events: auto; /* Allows interaction within the group */
    }

    .control-btn {
      padding: 1rem 1.5rem; /* Larger touch area */
      font-size: 1.2rem;
      background: rgba(74, 74, 74, 0.6); /* Semi-transparent */
      color: #fff;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
      transition: background 0.2s ease-in-out, opacity 0.2s ease-in-out;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto; /* Allows interaction */
      opacity: 0.8; /* Overall transparency */
      min-width: 60px; /* Ensure a decent size */
      min-height: 60px;
    }
    .control-btn:active {
      background: rgba(106, 106, 106, 0.8);
    }
    .control-btn:disabled {
        background: rgba(108, 117, 125, 0.4);
        cursor: not-allowed;
        opacity: 0.5;
    }

    /* Specific button styling */
    #hard-drop-btn {
        background: rgba(231, 76, 60, 0.6);
    }
    #hard-drop-btn:active {
        background: rgba(192, 57, 43, 0.8);
    }

    /* Adjust positioning for landscape mode */
    @media (max-width: 600px) and (orientation: landscape) {
      body {
        flex-direction: row;
        justify-content: space-around;
        align-items: center;
      }
      #game-container {
        width: auto;
        padding: 5px;
        flex-direction: row;
        gap: 10px;
        flex-grow: 0;
        height: 100%;
        max-height: 100%;
        justify-content: space-around;
        position: relative;
      }
      canvas {
        max-width: 60vw;
        max-height: 90vh;
      }
      #overlay-controls {
        /* In landscape, place controls on the sides of the canvas */
        flex-direction: row; /* Buttons are horizontal now */
        align-items: center; /* Center vertically */
        justify-content: space-between;
        padding: 10px;
      }
      .control-group {
        flex-direction: column; /* Buttons still stack vertically within groups */
      }
      #score, #startBtn {
        font-size: 1.2rem;
        z-index: 20;
      }
      #score { order: -2; }
      #startBtn { order: -1; }
    }

    /* Fine-tune for very small portrait screens */
    @media (max-height: 700px) and (orientation: portrait) {
      canvas {
        max-height: 55vh;
      }
      #score { font-size: 1.4rem; }
      #startBtn { font-size: 1rem; padding: 0.4rem 1rem; }
      .control-btn { font-size: 1.1rem; padding: 0.8rem 0; min-width: 50px; min-height: 50px; }
      #overlay-controls { gap: 8px; padding: 8px; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h2 id="score">점수: 0</h2>
    <button id="startBtn" disabled>게임 시작</button>
    <canvas id="tetris" width="240" height="400"></canvas>

    <div id="overlay-controls">
        <div class="control-group left-controls">
            <button id="rotate-btn" class="control-btn">회전</button>
        </div>
        <div class="control-group right-controls">
            <button id="hard-drop-btn" class="control-btn">하드 드롭</button>
        </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    ctx.scale(20, 20);

    const spriteUrls = {
      1: '/assets/images/dog.png',
      2: '/assets/images/cat.png',
      3: '/assets/images/bear.png',
      4: '/assets/images/rabbit.png',
      5: '/assets/images/monkey.png'
    };
    const spriteImgs = {};
    let imagesLoadedCount = 0;
    const totalImages = Object.keys(spriteUrls).length;

    function loadImages(callback) {
      for (let k in spriteUrls) {
        const img = new Image();
        img.src = spriteUrls[k];
        img.onload = () => {
          imagesLoadedCount++;
          if (imagesLoadedCount === totalImages) {
            callback();
          }
        };
        img.onerror = () => {
          console.error(`Failed to load image: ${spriteUrls[k]}. Check path and server.`);
          imagesLoadedCount++;
          if (imagesLoadedCount === totalImages) {
            callback();
          }
        };
        spriteImgs[k] = img;
      }
    }

    const W = 12, H = 20;
    let arena = createMatrix(W, H);
    arena.spriteMap = createMatrix(W, H);

    let player = { pos: { x: 0, y: 0 }, mat: null, imgMap: null };
    let keyState = { left: false, right: false, down: false };
    let dropCounter = 0, dropInterval = 1000, lastTime = 0, score = 0, gameRunning = false, levelUpTimer = 0, moveCounter = 0;
    let isProcessingAnimation = false;

    const moveInterval = 100;
    const colors = [null, '#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#FF922B', '#845EC2', '#00C9A7'];

    // --- Touch Gesture Variables ---
    let touchStartX = 0;
    let touchStartY = 0;
    let lastMoveTime = 0;
    const swipeThresholdX = 20; // Minimum horizontal pixel drag to register a move
    const swipeThresholdY = 20; // Minimum vertical pixel drag to register a soft drop
    const tapThreshold = 10; // Max pixel movement for a tap (for rotation)
    const moveDelay = 100; // Delay between consecutive moves on touchmove

    function createMatrix(w, h) {
      return Array.from({ length: h }, () => Array(w).fill(0));
    }

    function createPiece(type) {
      const t = {
        T: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
        O: [[2, 2], [2, 2]],
        L: [[0, 3, 0], [0, 3, 0], [0, 3, 3]],
        J: [[0, 4, 0], [0, 4, 0], [4, 4, 0]],
        I: [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]],
        S: [[0, 6, 6], [6, 6, 0], [0, 0, 0]],
        Z: [[7, 7, 0], [0, 7, 7], [0, 0, 0]]
      };
      return t[type];
    }

    function rotateMatrix(matrix, dir) {
      const m = JSON.parse(JSON.stringify(matrix));
      for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < y; ++x) {
          [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
        }
      }
      if (dir > 0) m.forEach(row => row.reverse());
      else m.reverse();
      return m;
    }

    function drawMatrix(m, off, alpha = 1) {
      ctx.globalAlpha = alpha;
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          const v = m[y][x];
          if (v) {
            const px = x + off.x, py = y + off.y;
            const grad = ctx.createLinearGradient(px, py, px + 1, py + 1);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(1, colors[v]);
            ctx.fillStyle = grad;
            ctx.fillRect(px, py, 1, 1);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.08;
            ctx.strokeRect(px, py, 1, 1);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(px, py, 1, 0.2);

            let imgId = null;
            if (m === player.mat && off === player.pos && player.imgMap) {
              imgId = player.imgMap[y][x];
            } else if (m === arena) {
              imgId = arena.spriteMap?.[y]?.[x];
            }

            if (imgId && spriteImgs[imgId]?.complete && spriteImgs[imgId].naturalWidth > 0) {
              ctx.drawImage(spriteImgs[imgId], px + 0.1, py + 0.1, 0.8, 0.8);
            }
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawGhost() {
      const g = { pos: { ...player.pos }, mat: player.mat, imgMap: player.imgMap };
      while (!collide(arena, g)) g.pos.y++;
      g.pos.y--;
      drawMatrix(g.mat, g.pos, 0.3);
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawMatrix(arena, { x: 0, y: 0 });
      drawGhost();
      drawMatrix(player.mat, player.pos);
    }

    function collide(ar, pl) {
      const m = pl.mat, o = pl.pos;
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (m[y][x] !== 0 &&
              (ar[y + o.y] && ar[y + o.y][x + o.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    function merge(ar, pl) {
      pl.mat.forEach((row, y) => {
        row.forEach((v, x) => {
          if (v) {
            ar[y + pl.pos.y][x + pl.pos.x] = v;
            arena.spriteMap[y + pl.pos.y][x + pl.pos.x] = player.imgMap[y][x];
          }
        });
      });
    }

    function applyGravityAfterMatch() {
        let movedAnything = false;
        for (let x = 0; x < W; x++) {
            let filledCells = [];
            for (let y = H - 1; y >= 0; y--) {
                if (arena[y][x] !== 0) {
                    filledCells.push({ value: arena[y][x], sprite: arena.spriteMap[y][x] });
                }
            }

            for (let y = 0; y < H; y++) {
                arena[y][x] = 0;
                arena.spriteMap[y][x] = 0;
            }

            let currentY = H - 1;
            for (let i = 0; i < filledCells.length; i++) {
                arena[currentY][x] = filledCells[i].value;
                arena.spriteMap[currentY][x] = filledCells[i].sprite;
                if (currentY !== (H - 1 - i)) {
                    movedAnything = true;
                }
                currentY--;
            }
        }
        return movedAnything;
    }

    function findConnectedMatches() {
        const m = arena.spriteMap;
        const matchedCoords = new Set();
        const matchLength = 4;
        const visited = createMatrix(W, H);

        function dfs(y, x, targetValue, currentCluster) {
            if (y < 0 || y >= H || x < 0 || x >= W || visited[y][x] || m[y][x] !== targetValue) {
                return;
            }

            visited[y][x] = 1;
            currentCluster.push([y, x]);

            dfs(y + 1, x, targetValue, currentCluster);
            dfs(y - 1, x, targetValue, currentCluster);
            dfs(y, x + 1, targetValue, currentCluster);
            dfs(y, x - 1, targetValue, currentCluster);
        }

        for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
                const value = m[y][x];
                if (value !== 0 && !visited[y][x]) {
                    const currentCluster = [];
                    dfs(y, x, value, currentCluster);

                    if (currentCluster.length >= matchLength) {
                        currentCluster.forEach(coord => {
                            matchedCoords.add(JSON.stringify(coord));
                        });
                    }
                }
            }
        }
        return Array.from(matchedCoords).map(JSON.parse);
    }

    async function animateMatch(toDel) {
        const flashColor = 'rgba(255, 255, 0, 0.8)';
        const boundaryFlashColor = 'rgba(0, 255, 255, 0.9)';

        // Draw current state before starting animations
        draw(); 

        // 1단계: 매치된 블록 경계 번쩍임
        ctx.lineWidth = 0.15;
        for (let i = 0; i < 2; i++) {
            ctx.strokeStyle = boundaryFlashColor;
            ctx.globalAlpha = 1;
            toDel.forEach(([yy, xx]) => {
                ctx.strokeRect(xx, yy, 1, 1);
            });
            await new Promise(resolve => setTimeout(resolve, 40));

            draw(); // Redraw the scene to clear the border
            await new Promise(resolve => setTimeout(resolve, 40));
        }
        ctx.lineWidth = 0.08;

        // 2단계: 매치된 블록 강조 (글로우 효과)
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = flashColor;
        toDel.forEach(([yy, xx]) => {
            ctx.fillRect(xx, yy, 1, 1);
        });
        ctx.globalAlpha = 1;
        await new Promise(resolve => setTimeout(resolve, 80));
        
        draw(); // Clear the glow effect by redrawing
    }

    async function processMatches() {
        if (isProcessingAnimation) {
             return;
        }

        isProcessingAnimation = true;
        toggleControlButtons(false);

        let chainCount = 0;

        do {
            let foundMatchThisIteration = false;
            let clearedLineThisIteration = 0;

            const matches = findConnectedMatches();
            if (matches.length > 0) {
                foundMatchThisIteration = true;
                chainCount++;

                await animateMatch(matches);
                clearMatchedBlocks(matches);
                score += matches.length * 10 * chainCount;
                updateScore();
                
                dropInterval = Math.min(1000, dropInterval + (matches.length * 20));
                
                draw(); // Update visual after clearing
                await new Promise(resolve => setTimeout(resolve, 100));

                const moved = applyGravityAfterMatch();
                draw(); // Update visual after gravity
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const linesCleared = arenaSweep();
            if (linesCleared > 0) {
                clearedLineThisIteration = linesCleared;
                draw(); // Update visual after line clear
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            if (!foundMatchThisIteration && clearedLineThisIteration === 0) {
                break;
            }

        } while (true);

        isProcessingAnimation = false;
        toggleControlButtons(true);
    }

    function arenaSweep() {
      let rowsRemoved = 0;
      for (let y = H - 1; y >= 0; y--) {
        if (arena[y].every(v => v !== 0)) {
          rowsRemoved++;
          arena.splice(y, 1);
          arena.unshift(Array(W).fill(0));
          arena.spriteMap.splice(y, 1);
          arena.spriteMap.unshift(Array(W).fill(0));
          y++;
        }
      }
      if (rowsRemoved > 0) {
        score += rowsRemoved * 100;
        dropInterval = Math.max(100, dropInterval - rowsRemoved * 50);
        updateScore();
      }
      return rowsRemoved;
    }

    function updateScore() { document.getElementById('score').innerText = `점수: ${score}`; }

    function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        playerReset();
        processMatches();
      }
      dropCounter = 0;
    }

    function playerHardDrop() {
      if (isProcessingAnimation) return;
      while (!collide(arena, player)) player.pos.y++;
      player.pos.y--;
      merge(arena, player);
      playerReset();
      processMatches();
      dropCounter = 0;
    }

    function playerMove(dir) {
      if (isProcessingAnimation) return;
      player.pos.x += dir;
      if (collide(arena, player)) player.pos.x -= dir;
    }

    function playerRotate(dir) {
      if (isProcessingAnimation) return;

      const pos = player.pos.x;
      let offset = 1;
      const rotMat = rotateMatrix(player.mat, dir);
      const rotImg = rotateMatrix(player.imgMap, dir);
      player.mat = rotMat;
      player.imgMap = rotImg;

      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.mat[0].length) {
          player.mat = rotateMatrix(player.mat, -dir);
          player.imgMap = rotateMatrix(player.imgMap, -dir);
          player.pos.x = pos;
          return;
        }
      }
    }

    function playerReset() {
      const types = 'TJLOSZI';
      player.mat = createPiece(types[Math.floor(Math.random() * 7)]);
      player.imgMap = player.mat.map(row => row.map(v => v ? String(Math.ceil(Math.random() * 5)) : 0));
      player.pos.y = 0;
      player.pos.x = (W / 2 | 0) - (player.mat[0].length / 2 | 0);

      if (collide(arena, player)) {
        gameRunning = false;
        alert(`게임 종료! 최종 점수: ${score}`);
        toggleControlButtons(false);
        document.getElementById('startBtn').disabled = false;
      }
    }

    function update(time = 0) {
      if (!gameRunning) return;

      const dt = time - lastTime;
      lastTime = time;

      dropCounter += dt;
      levelUpTimer += dt;
      moveCounter += dt;

      if (dropCounter > dropInterval) {
        playerDrop();
      }

      if (levelUpTimer > 15000) {
        dropInterval = Math.max(100, dropInterval - 50);
        levelUpTimer = 0;
      }

      // Key controls are still here for debugging/desktop
      if (moveCounter > moveInterval) {
        if (keyState.left) playerMove(-1);
        if (keyState.right) playerMove(1);
        if (keyState.down) playerDrop();
        moveCounter = 0;
      }

      draw();
      requestAnimationFrame(update);
    }

    function toggleControlButtons(enable) {
        const buttons = document.querySelectorAll('.control-btn');
        buttons.forEach(button => {
            if (!gameRunning && button.id !== 'startBtn') {
                button.disabled = true;
            } else {
                button.disabled = !enable;
            }
        });
    }

    // --- Touch Gesture Implementation ---
    let initialTouchX = 0;
    let initialTouchY = 0;
    let lastProcessedX = 0;
    let lastProcessedY = 0;
    let isDragging = false;
    const dragSensitivityX = 1.5; // Lower value for less sensitive drag (more pixels to move 1 block)
    const dragSensitivityY = 2.5; // Lower value for less sensitive drag down (more pixels for a drop)

    canvas.addEventListener('touchstart', (e) => {
        if (!gameRunning || isProcessingAnimation) return;
        isDragging = false;
        const touch = e.touches[0];
        initialTouchX = touch.clientX;
        initialTouchY = touch.clientY;
        lastProcessedX = touch.clientX;
        lastProcessedY = touch.clientY;
        e.preventDefault(); // Prevent default browser actions like scrolling
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        if (!gameRunning || isProcessingAnimation || e.touches.length > 1) return; // Ignore multi-touch
        const touch = e.touches[0];
        const currentX = touch.clientX;
        const currentY = touch.clientY;

        const deltaX = currentX - lastProcessedX;
        const deltaY = currentY - lastProcessedY;

        // Horizontal Movement
        if (Math.abs(deltaX) >= (canvas.width / W / dragSensitivityX)) { // Move one block width
            if (deltaX > 0) {
                playerMove(1);
            } else {
                playerMove(-1);
            }
            lastProcessedX = currentX; // Reset processed position
            isDragging = true;
        }

        // Vertical Soft Drop
        if (deltaY >= (canvas.height / H / dragSensitivityY)) { // Drop one block height
            playerDrop();
            lastProcessedY = currentY; // Reset processed position
            isDragging = true;
        }
        e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        if (!gameRunning || isProcessingAnimation) return;

        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;

        const totalDeltaX = Math.abs(touchEndX - initialTouchX);
        const totalDeltaY = Math.abs(touchEndY - initialTouchY);

        // If it was a short tap (not a drag), then trigger rotation
        if (totalDeltaX < tapThreshold && totalDeltaY < tapThreshold && !isDragging) {
            playerRotate(1); // Single rotate direction
        }
        isDragging = false; // Reset drag state
        e.preventDefault();
    }, { passive: false });


    // Button listeners (only rotate and hard drop remain)
    document.getElementById('rotate-btn').addEventListener('touchstart', (e) => { e.preventDefault(); playerRotate(1); });
    document.getElementById('hard-drop-btn').addEventListener('touchstart', (e) => { e.preventDefault(); playerHardDrop(); });


    document.addEventListener('keydown', e => {
      if (!gameRunning || isProcessingAnimation) return;
      if (e.key === 'ArrowLeft') keyState.left = true;
      else if (e.key === 'ArrowRight') keyState.right = true;
      else if (e.key === 'ArrowDown') keyState.down = true;
      else if (e.key === ' ') { e.preventDefault(); playerHardDrop(); }
      else if (e.key === 'q' || e.key === 'w') playerRotate(1); // Any of these rotate (single direction)
    });
    document.addEventListener('keyup', e => {
      if (!gameRunning || isProcessingAnimation) return;
      if (e.key === 'ArrowLeft') keyState.left = false;
      if (e.key === 'ArrowRight') keyState.right = false;
      if (e.key === 'ArrowDown') keyState.down = false;
    });

    document.getElementById('startBtn').onclick = () => {
      if (!gameRunning) {
        gameRunning = true;
        dropInterval = 1000;
        levelUpTimer = 0;
        score = 0;
        updateScore();
        arena = createMatrix(W, H);
        arena.spriteMap = createMatrix(W, H);
        playerReset();
        lastTime = performance.now();
        toggleControlButtons(true);
        document.getElementById('startBtn').disabled = true;
        update();
      }
    };

    loadImages(() => {
      document.getElementById('startBtn').disabled = false;
      console.log('All images loaded!');
    });

    updateScore();
    toggleControlButtons(false);
  </script>
</body>
</html>