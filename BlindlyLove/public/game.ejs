<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>테트리스+동물매치 순차처리</title>
  <style>
    body { background:#111; color:#fff; display:flex; flex-direction:column; align-items:center; height:100vh; margin:0; font-family:'Segoe UI',sans-serif; }
    #score { font-size:1.4rem; margin-top:1rem; }
    #startBtn { padding:0.5rem 1.2rem; margin-top:0.5rem; font-size:1rem; background:#38bdf8; border:none; border-radius:6px; cursor:pointer; }
    canvas { border:3px solid #38bdf8; background:#000; margin-top:1rem; }
  </style>
</head>
<body>
  <h2 id="score">점수: 0</h2>
  <button id="startBtn">게임 시작</button>
  <canvas id="tetris" width="240" height="400"></canvas>
  <script>
    const canvas = document.getElementById('tetris'), ctx = canvas.getContext('2d');
    ctx.scale(20,20);

    const spriteUrls = {1:'./assets/images/dog.png',2:'./assets/images/cat.png',3:'./assets/images/bear.png',4:'./assets/images/rabbit.png',5:'./assets/images/monkey.png'};
    const spriteImgs = {};
    for (let k in spriteUrls) {
      const img = new Image();
      img.src = spriteUrls[k];
      spriteImgs[k] = img;
    }

    const W=12, H=20;
    let arena, player, keyState, dropCounter, dropInterval, lastTime, score, gameRunning, levelUpTimer, moveCounter;
    const moveInterval=100;
    const colors=[null,'#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#FF922B','#845EC2','#00C9A7'];

    function initVars(){
      arena = createMatrix(W,H);
      arena.spriteMap = createMatrix(W,H);
      player = {pos:{x:0,y:0},mat:null,imgMap:null};
      keyState={left:false,right:false,down:false};
      dropCounter=0; dropInterval=1000; lastTime=0; score=0; gameRunning=false; levelUpTimer=0; moveCounter=0;
      updateScore();
    }

    function createMatrix(w,h){ return Array.from({length:h},()=>Array(w).fill(0)); }
    function createPiece(type){
      const t={T:[[0,1,0],[1,1,1],[0,0,0]],O:[[2,2],[2,2]],L:[[0,3,0],[0,3,0],[0,3,3]],J:[[0,4,0],[0,4,0],[4,4,0]],I:[[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]],S:[[0,6,6],[6,6,0],[0,0,0]],Z:[[7,7,0],[0,7,7],[0,0,0]]};
      return t[type];
    }

    function rotateMatrix(matrix, dir){
      const m = JSON.parse(JSON.stringify(matrix));
      for (let y=0;y<m.length;y++){
        for(let x=0;x<y;x++){ [m[x][y],m[y][x]]=[m[y][x],m[x][y]]; }
      }
      dir>0? m.forEach(r=>r.reverse()): m.reverse();
      return m;
    }

    function drawMatrix(m, off, alpha=1){
      ctx.globalAlpha=alpha;
      for(let y=0;y<m.length;y++)for(let x=0;x<m[y].length;x++){
        const v=m[y][x]; if(!v) continue;
        const px=x+off.x, py=y+off.y;
        const grad=ctx.createLinearGradient(px,py,px+1,py+1);
        grad.addColorStop(0,'#fff'); grad.addColorStop(1,colors[v]);
        ctx.fillStyle=grad;
        ctx.fillRect(px,py,1,1);
        ctx.strokeStyle='#000'; ctx.lineWidth=0.08;
        ctx.strokeRect(px,py,1,1);
        ctx.fillStyle='rgba(255,255,255,0.2)';
        ctx.fillRect(px,py,1,0.2);

        let imgId = (m===player.mat && off===player.pos)? player.imgMap[y][x] : arena.spriteMap[y][x];
        if(imgId && spriteImgs[imgId]?.complete) ctx.drawImage(spriteImgs[imgId], px+0.1, py+0.1, 0.8, 0.8);
      }
      ctx.globalAlpha=1;
    }

    function draw(){
      ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawMatrix(arena,{x:0,y:0});
      drawGhost();
      drawMatrix(player.mat,player.pos);
    }

    function drawGhost(){
      const g={pos:{...player.pos},mat:player.mat,imgMap:player.imgMap};
      while(!collide(arena,g)) g.pos.y++;
      g.pos.y--;
      drawMatrix(g.mat,g.pos,0.3);
    }

    function collide(ar,pl){
      const m=pl.mat, o=pl.pos;
      for(let y=0;y<m.length;y++)for(let x=0;x<m[y].length;x++){
        if(m[y][x] && (ar[y+o.y] && ar[y+o.y][x+o.x])!==0) return true;
      }
      return false;
    }

    function merge(ar,pl){
      pl.mat.forEach((row,yy)=>row.forEach((v,xx)=>{
        if(v){
          ar[yy+pl.pos.y][xx+pl.pos.x]=v;
          arena.spriteMap[yy+pl.pos.y][xx+pl.pos.x] = player.imgMap[yy][xx];
        }
      }));
    }

    function applyGravity() {
  // Loop through only the columns where animals exploded
  for (let x = 0; x < W; x++) {
    let col = [];
    // Check each row in the column for non-empty blocks
    for (let y = H - 1; y >= 0; y--) {
      if (arena[y][x] !== 0) {
        col.push({ value: arena[y][x], sprite: arena.spriteMap[y][x] });
        arena[y][x] = 0;
        arena.spriteMap[y][x] = 0;
      }
    }
    // Only refill the column with the collected blocks, leaving other columns untouched
    let y = H - 1;
    for (let i = 0; i < col.length; i++) {
      arena[y][x] = col[i].value;
      arena.spriteMap[y][x] = col[i].sprite;
      y--;
    }
  }
}


    function sleep(ms){return new Promise(r=>setTimeout(r,ms));}

    function findMatches(){
      const m=arena.spriteMap; const toDel=[];
      for(let y=0;y<H;y++)for(let x=0;x<W;x++){
        const v=m[y][x]; if(!v)continue;
        [[1,0],[0,1],[1,1],[1,-1]].forEach(d=>{
          const line=[];
          for(let k=0;k<3;k++){
            const nx=x+d[0]*k, ny=y+d[1]*k;
            if(m[ny]&&m[ny][nx]===v) line.push([ny,nx]);
          }
          if(line.length===3) toDel.push(...line);
        });
      }
      return [...new Set(toDel.map(JSON.stringify))].map(JSON.parse);
    }

    async function resolveMatches(){
  let matched;
  do {
    matched = findMatches();
    if(matched.length){
      for(let i=0;i<3;i++){
        matched.forEach(([y,x])=>arena.spriteMap[y][x]= i%2? '': arena.spriteMap[y][x]);
        draw(); await sleep(150);
      }
      matched.forEach(([y,x])=>{ arena[y][x]=arena.spriteMap[y][x]=0; });
      score += matched.length*5;
      dropInterval = Math.min(1000, dropInterval+matched.length*20);
      updateScore();
      await sleep(200);
      applyGravity();
      draw(); await sleep(200);
      
      // ✅ 중력 적용 후 새로 가득 찬 줄이 있으면 삭제
      await arenaSweep();
    }
  } while(matched.length);
}

  

    async function arenaSweep(){
      let rows;
      do {
        rows=0;
        for(let y=H-1;y>=0;y--){
          if(arena[y].every(v=>v)){
            rows++;
            arena.splice(y,1); arena.unshift(Array(W).fill(0));
            arena.spriteMap.splice(y,1); arena.spriteMap.unshift(Array(W).fill(0));
            y++;
          }
        }
        if(rows){
          score += rows*10;
          dropInterval = Math.max(100, dropInterval-rows*50);
          updateScore();
          draw(); await sleep(200);
        }
        await resolveMatches();
      } while(rows);
    }

    function updateScore(){ document.getElementById('score').innerText=`점수: ${score}`; }

    function playerDrop(){
      player.pos.y++;
      if(collide(arena,player)){
        player.pos.y--;
        merge(arena,player);
        playerReset();
        arenaSweep();
      }
      dropCounter=0;
    }

    function playerHardDrop(){
      while(!collide(arena,player)) player.pos.y++;
      player.pos.y--;
      merge(arena,player);
      playerReset();
      arenaSweep();
      dropCounter=0;
    }

    function playerMove(dir){ player.pos.x+=dir; if(collide(arena,player)) player.pos.x-=dir; }

    function playerRotate(dir){
      const pos=player.pos.x; let offset=1;
      const rm=rotateMatrix(player.mat,dir), ri=rotateMatrix(player.imgMap,dir);
      player.mat=rm; player.imgMap=ri;
      while(collide(arena,player)){
        player.pos.x+=offset;
        offset = -(offset+(offset>0?1:-1));
        if(offset>player.mat[0].length){
          player.mat=rotateMatrix(player.mat,-dir);
          player.imgMap=rotateMatrix(player.imgMap,-dir);
          player.pos.x=pos; return;
        }
      }
    }

    function playerReset(){
      const types='TJLOSZI';
      player.mat=createPiece(types[Math.floor(Math.random()*7)]);
      player.imgMap=player.mat.map(r=>r.map(v=>v?String(Math.ceil(Math.random()*5)):0));
      player.pos.y=0;
      player.pos.x=(W/2|0)-(player.mat[0].length/2|0);
      if(collide(arena,player)){gameRunning=false; alert(`게임 끝! 점수: ${score}`);}
    }

    function update(time=0){
      if(!gameRunning) return;
      const dt=time-lastTime; lastTime=time;
      dropCounter+=dt; levelUpTimer+=dt; moveCounter+=dt;
      if(dropCounter>dropInterval){ playerDrop(); }
      if(levelUpTimer>10000){ dropInterval=Math.max(100,dropInterval-100); levelUpTimer=0; }
      if(moveCounter>moveInterval){
        if(keyState.left) playerMove(-1);
        if(keyState.right) playerMove(1);
        if(keyState.down) playerDrop();
        moveCounter=0;
      }
      draw(); requestAnimationFrame(update);
    }

    document.addEventListener('keydown',e=>{
      if(!gameRunning)return;
      if(e.key==='ArrowLeft')keyState.left=true;
      else if(e.key==='ArrowRight')keyState.right=true;
      else if(e.key==='ArrowDown')keyState.down=true;
      else if(e.key===' '){e.preventDefault();playerHardDrop();}
      else if(e.key==='q')playerRotate(-1);
      else if(e.key==='w')playerRotate(1);
    });

    document.addEventListener('keyup',e=>{
      if(e.key==='ArrowLeft')keyState.left=false;
      if(e.key==='ArrowRight')keyState.right=false;
      if(e.key==='ArrowDown')keyState.down=false;
    });

    document.getElementById('startBtn').onclick = () =>{
      initVars(); playerReset(); gameRunning=true; requestAnimationFrame(update);
    };
  </script>
</body>
</html>
