<header class="sticky-header" id="stickyHeader">
  <nav class="mk-nav">
    <a href="#youtube" class="nav-icon" title="YouTube">
      <i class="fab fa-youtube"></i>
    </a>
    <a href="#soundcloud" class="nav-icon" title="SoundCloud">
      <i class="fab fa-soundcloud"></i>
    </a>
    <a href="#instagram" class="nav-icon" title="Instagram">
      <i class="fab fa-instagram"></i>
    </a>
    <a href="#lessons" class="nav-icon" title="êµìœ¡">
      <i class="fas fa-chalkboard-teacher"></i>
    </a>
    <a href="#experiments" class="nav-icon" title="ì‹¤í—˜">
      <i class="fas fa-vial"></i>
    </a>
  </nav>
</header>

<header class="mk-header" id="mainHeader">
  <div class="logo-wrapper" id="logoWrapper">
      <object id="logo" type="image/svg+xml" data="/assets/images/logo.svg"></object>
  </div>

  <nav class="mk-nav">
    <a href="#youtube" class="nav-icon" title="YouTube">
      <i class="fab fa-youtube"></i>
    </a>
    <a href="#soundcloud" class="nav-icon" title="SoundCloud">
      <i class="fab fa-soundcloud"></i>
    </a>
    <a href="#instagram" class="nav-icon" title="Instagram">
      <i class="fab fa-instagram"></i>
    </a>
    <a href="#lessons" class="nav-icon" title="êµìœ¡">
      <i class="fas fa-chalkboard-teacher"></i>
    </a>
    <a href="#experiments" class="nav-icon" title="ì‹¤í—˜">
      <i class="fas fa-vial"></i>
    </a>
  </nav>
</header>



<script>
  const obj = document.getElementById('logo');
  obj.addEventListener('load', () => {
    const svgDoc = obj.contentDocument;

    const whole = svgDoc.getElementById('whole');
    const eyebrow = svgDoc.getElementById('eyebrow');
    const glow = svgDoc.getElementById('glow');

    // âœ… í•„í„° ì •ì˜
    const defs = svgDoc.querySelector('defs') || svgDoc.createElementNS("http://www.w3.org/2000/svg", "defs");

    // ğŸ”µ ë¶€ë“œëŸ¬ìš´ íŒŒë€ ê·¸ë¼ë°ì´ì…˜ glow
    const glowFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    glowFilter.setAttribute("id", "glow-gradient-blue");
    glowFilter.innerHTML = `
      <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur"/>
      <feFlood flood-color="deepskyblue" flood-opacity="1" result="flood"/>
      <feComposite in="flood" in2="blur" operator="in" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    `;
    defs.appendChild(glowFilter);

    // keysìš© ê³ ì • ë¸”ë£¨ í•„í„°
    const makeGlowFilter = (id, color, stdDev = 3) => {
      const filter = svgDoc.createElementNS("http://www.w3.org/2000/svg", "filter");
      filter.setAttribute("id", id);
      filter.innerHTML = `
        <feDropShadow dx="0" dy="0" stdDeviation="${stdDev}" flood-color="${color}" flood-opacity="1"/>
      `;
      return filter;
    };
    defs.appendChild(makeGlowFilter("glow-blue-static", "deepskyblue", 3));

    svgDoc.documentElement.insertBefore(defs, svgDoc.documentElement.firstChild);

    // âœ… whole + glow í•¨ê»˜ í˜ì´ë“œì¸
    if (whole) {
      const allWholePaths = whole.querySelectorAll('*');
      const glowPaths = glow ? glow.querySelectorAll('*') : [];

      let t = 0;
      let glowAnimationStarted = false;

      function animateFadeInOnce() {
        t += 0.015;
        if (t >= 1) t = 1;
        else requestAnimationFrame(animateFadeInOnce);

        const baseColor = 255;
        const blueOffset = Math.floor((1 - t) * 30); // ì•„ì£¼ ì‚´ì§ í‘¸ë¥¸ê¸° â†’ ì ì  í•˜ì–—ê²Œ
        const fillColor = `rgb(${baseColor - blueOffset}, ${baseColor - blueOffset}, ${baseColor})`;

        allWholePaths.forEach(el => el.setAttribute('fill', fillColor));
        whole.setAttribute('fill', fillColor);

        // glowë„ wholeì´ ì¶©ë¶„íˆ ë“¤ì–´ì˜¨ ë’¤ì— ë“±ì¥ ì‹œì‘
        if (glow && t >= 0.5 && !glowAnimationStarted) {
          glow.setAttribute('filter', 'url(#glow-gradient-blue)');
          startGlowPulse();
          glowAnimationStarted = true;
        }
      }

      animateFadeInOnce();
    }

    // âœ… glow í‘¸ë¥¸ ì ë©¸ íš¨ê³¼ (ì¤‘ì•™ ë°ê³ , ë°”ê¹¥ ì§„í•¨ â†’ ë‹¤ì‹œ í°ìƒ‰ ë³µê·€ ë°˜ë³µ)
    function startGlowPulse() {
      let increasing = true;
      let glowT = 0;

      function animateGlowPulse() {
        glowT += increasing ? 0.004 : -0.004;
        if (glowT >= 1) {
          glowT = 1;
          increasing = false;
        } else if (glowT <= 0) {
          glowT = 0;
          increasing = true;
        }

        const r = Math.floor(255 - glowT * 60); // í‘¸ë¥¸ê¸° ë” ëšœë ·í•˜ê²Œ!
        const g = Math.floor(255 - glowT * 60);
        const b = 255;
        const fillColor = `rgb(${r}, ${g}, ${b})`;

        const glowPaths = glow.querySelectorAll('*');
        glowPaths.forEach(el => el.setAttribute('fill', fillColor));
        glow.setAttribute('fill', fillColor);

        requestAnimationFrame(animateGlowPulse);
      }

      animateGlowPulse();
    }

    // âœ… eyebrow: ìœ„ì•„ë˜ ì• ë‹ˆë©”ì´ì…˜
    if (eyebrow) {
      const animate = svgDoc.createElementNS("http://www.w3.org/2000/svg", "animateTransform");
      animate.setAttribute("attributeName", "transform");
      animate.setAttribute("type", "translate");
      animate.setAttribute("values", "0,-2; 0,2; 0,-2");
      animate.setAttribute("dur", "1s");
      animate.setAttribute("repeatCount", "indefinite");
      eyebrow.appendChild(animate);
    }

    // âœ… keys_1~4: í‘¸ë¥¸ ê¸€ë¡œìš° (í•­ìƒ ì¼œì§)
    for (let i = 1; i <= 4; i++) {
      const el = svgDoc.getElementById(`keys_${i}`);
      if (el) el.setAttribute('filter', 'url(#glow-blue-static)');
    }

    // âœ… sonic_1~5, atelier_1~7: ê¸€ë¡œìš° ì—†ì´ í°ìƒ‰ fill
    const applyWhiteFill = (prefix, count) => {
      for (let i = 1; i <= count; i++) {
        const el = svgDoc.getElementById(`${prefix}_${i}`);
        if (el) el.setAttribute('fill', 'white');
      }
    };
    applyWhiteFill('sonic', 5);
    applyWhiteFill('atelier', 7);
  });
</script>




<script>
  document.addEventListener('DOMContentLoaded', () => {
    const mainHeader = document.querySelector('.mk-header');
    const stickyHeader = document.querySelector('.sticky-header');

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          // ë©”ì¸ í—¤ë”ê°€ ë³´ì´ë©´ ìŠ¤í‹°í‚¤ ìˆ¨ê¸°ê¸°
          stickyHeader.classList.remove('show');
        } else {
          // ë©”ì¸ í—¤ë”ê°€ í™”ë©´ì—ì„œ ì‚¬ë¼ì§€ë©´ ìŠ¤í‹°í‚¤ ë³´ì´ê¸°
          stickyHeader.classList.add('show');
        }
      },
      {
        root: null,
        threshold: 0,
      }
    );

    if (mainHeader) observer.observe(mainHeader);
  });
</script>
