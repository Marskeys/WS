<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orchestra Scroll Scene — 2D (PixiJS + GSAP)</title>
  <style>
    :root { --bg:#0e1016; --text:#eef2f8; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif; }
    #stage { position: fixed; inset: 0; z-index: 0; }
    #scroll { position: relative; height: 500vh; }
    .hud { position: fixed; left: 16px; bottom: 16px; z-index: 5; opacity:.8; font-size:12px; }
    .tag { position: fixed; right: 16px; bottom: 16px; z-index: 5; opacity:.6; font-size:11px; }
    .loading { position: fixed; inset: 0; display: grid; place-items: center; z-index: 10; background: var(--bg); }
    .loading.hidden{ display:none; }
    .loading .bar { width: 240px; height: 4px; background: #1c2230; border-radius: 999px; overflow: hidden; }
    .loading .bar div { height: 100%; width: 0; background: linear-gradient(90deg,#6ea8ff,#b388ff,#ff8aa1); }

    @media (prefers-reduced-motion: reduce){ #scroll{ height: 250vh; } }
  </style>
  <!-- PixiJS v7 -->
  <script src="https://unpkg.com/pixi.js@7.4.0/dist/pixi.min.js"></script>
  <!-- GSAP -->
  <script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>
  <script src="https://unpkg.com/gsap@3/dist/ScrollTrigger.min.js"></script>
</head>
<body>
  <div id="stage"></div>
  <div id="scroll"></div>
  <div class="hud">스크롤하면 더블베이스가 입장해요 ▶︎</div>
  <div class="tag">PixiJS AnimatedSprite + GSAP ScrollTrigger</div>
  <div class="loading" id="loading">
    <div style="margin-bottom:10px; opacity:.7">애셋 불러오는 중…</div>
    <div class="bar"><div id="progress"></div></div>
  </div>

  <script>
  (async function(){
    gsap.registerPlugin(ScrollTrigger);

    // ------------------------------------------------------------------
    // PIXI 앱
    // ------------------------------------------------------------------
    const app = new PIXI.Application({
      background: '#0e1016',
      antialias: true,
      hello: false,
      // 창 크기에 자동 맞춤
      resizeTo: window,
    });
    document.getElementById('stage').appendChild(app.view);

    // 해상도 제한 (모바일 발열/전력↓)
    app.renderer.resolution = Math.min(window.devicePixelRatio || 1, 1.5);

    // 로딩 표시
    const loadingEl = document.getElementById('loading');
    const progressBar = document.getElementById('progress');

    // ------------------------------------------------------------------
    // 애셋 등록
    //  - TexturePacker나 Pixi Spritesheet 포맷(JSON) 권장
    //  - 예) cello.json 안에 프레임명이 cello_0001.png ~ cello_0060.png
    //  -     bass.json  안에 프레임명이 bass_0001.png  ~ bass_0060.png
    //  - 경로만 네가 쓰는 걸로 바꿔줘.
    // ------------------------------------------------------------------
    PIXI.Assets.add({ alias: 'cello', src: '/assets/cello/cello.json' });
    PIXI.Assets.add({ alias: 'bass',  src: '/assets/bass/bass.json'   });

    PIXI.Assets.setPreferences({ preferWorkers: true });

    // 진행률
    PIXI.Assets.events.on('progress', (p)=>{
      progressBar.style.width = (p*100).toFixed(1)+'%';
    });

    // 로드
    const [celloSheet, bassSheet] = await PIXI.Assets.load(['cello','bass']);
    loadingEl.classList.add('hidden');

    // ------------------------------------------------------------------
    // 헬퍼: 프리픽스 기준으로 프레임 수집
    // ------------------------------------------------------------------
    function framesByPrefix(sheet, prefix){
      const names = Object.keys(sheet.textures)
        .filter(n => n.startsWith(prefix))
        .sort((a,b)=>{
          // 숫자 인덱스 정렬 (예: _0001)
          const na = parseInt(a.match(/(\d+)/)?.[0]||'0',10);
          const nb = parseInt(b.match(/(\d+)/)?.[0]||'0',10);
          return na-nb;
        });
      return names.map(n => sheet.textures[n]);
    }

    // ------------------------------------------------------------------
    // 애니메이티드 스프라이트 생성
    //  - 네 시트 프레임명에 맞춰 prefix 수정
    // ------------------------------------------------------------------
    const cello = new PIXI.AnimatedSprite(framesByPrefix(celloSheet, 'cello_'));
    cello.animationSpeed = 0.7; // 0.1~1.0
    cello.loop = true; cello.play();
    cello.anchor.set(0.5, 1.0); // 가운데-아래 기준

    const bass = new PIXI.AnimatedSprite(framesByPrefix(bassSheet, 'bass_'));
    bass.animationSpeed = 0.7; bass.loop = true; bass.play();
    bass.anchor.set(0.5, 1.0);

    // 스테이지에 추가
    app.stage.addChild(cello, bass);

    // 레이아웃: 스테이지 하단 라인에 세워두기
    function layout(){
      const W = app.renderer.width;
      const H = app.renderer.height;
      const baseH = Math.min(H, 900);
      const scale = Math.min(1, (W/1280)*0.9, (H/720)*0.9);

      cello.scale.set(scale);
      bass.scale.set(scale);

      const groundY = H * 0.90;
      cello.y = groundY;
      bass.y  = groundY;

      // 시작 포지션(첼로 중앙 살짝 왼쪽 / 베이스는 화면 밖 오른쪽)
      cello.x = W*0.42;
      bass.x  = W + (bass.width*0.5);
    }
    layout();
    window.addEventListener('resize', layout);

    // 처음엔 베이스 안 보이게
    bass.alpha = 0;

    // ------------------------------------------------------------------
    // GSAP ScrollTrigger — 스크롤 구동 연출
    //  - 0%~100% 스크럽 타임라인에서 합주 연출
    // ------------------------------------------------------------------
    const tl = gsap.timeline({
      defaults: { ease: 'none' },
      scrollTrigger: {
        trigger: '#scroll',
        start: 'top top',
        end: 'bottom bottom',
        scrub: true,
      }
    });

    // 카메라 느낌: 스테이지 전체 스케일 조절(살짝 줌)
    const stageProxy = { s: 1, x: 0 };
    tl.to(stageProxy, { s: 1.06 }, 0.0)
      .to(stageProxy, { x: 10 }, 0.20); // 미세 패닝

    app.ticker.add(()=>{
      app.stage.scale.set(stageProxy.s);
      app.stage.x = stageProxy.x;
    });

    // 35%~60%: 베이스 입장 + 페이드인
    tl.to(bass, { alpha: 1, duration: 0.6 }, 0.38)
      .to(bass, { x: ()=> app.renderer.width*0.60, duration: 1.0 }, 0.35)
      // 첼로는 살짝 왼쪽으로 비켜주기
      .to(cello, { x: ()=> app.renderer.width*0.32, duration: 1.0 }, 0.38)
      // 피날레 근처: 둘 다 약간 확대
      .to([cello, bass], { pixi: { } , duration: 0.0 }, 0.8) // placeholder
      .to([cello, bass], { scaleX: '+=0.04', scaleY: '+=0.04', duration: 0.6 }, 0.82);

    // (선택) 스크롤 방향에 따라 연주 속도 살짝 변주
    let lastY = window.scrollY;
    let speedMod = 1;
    function updateSpeed(){
      const dy = window.scrollY - lastY;
      lastY = window.scrollY;
      const t = Math.max(-1, Math.min(1, dy / 200));
      speedMod = 0.7 + Math.abs(t)*0.4; // 0.7~1.1
      cello.animationSpeed = speedMod;
      bass.animationSpeed  = speedMod;
    }
    window.addEventListener('scroll', updateSpeed, { passive: true });

    // 저전력 모드: requestAnimationFrame은 Pixi가 내부에서 관리
    // 필요 시 app.ticker.maxFPS = 60; 조절

  })();
  </script>

  <!--
  ▶︎ 애셋 제작 가이드 (실전)
  1) 일러스트 레이어를 분리해서 캐릭터 리깅(Spine/DragonBones/Rive) 또는 프레임 애니메이션 제작
  2) 프레임 애니메이션이라면 TexturePacker로 atlas(json+png) 출력
     - 프레임명 접두어 통일: cello_0001.png .. bass_0001.png
     - 캔버스 여백 최소화, Trim 사용, Max Size 2048~4096
  3) 상단 src 경로를 네 경로로 교체
  4) 퍼포먼스: 해상도 제한(resolution), 프레임 수(≤60), 이미지 2K 이하

  ▶︎ Spine/Live2D/Rive로 하고 싶다면
  - Spine: pixi-spine 런타임으로 skeleton.json+.atlas+.png 로드 후 state.setAnimation('play', true)
  - Live2D: pixi-live2d-display로 .model3.json 로드, 모션/파츠 파라미터 스크립팅
  - Rive: @rive-app/canvas 로 .riv 로드, StateMachine 입력값을 ScrollTrigger로 제어
  -->
</body>
</html>
