<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í˜„ì‹¤ì ì¸ ê¸°íƒ€ í˜„ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            flex-direction: column;
            overflow: hidden;
            color: #e0e0e0;
        }
        canvas {
            border: 2px solid #555;
            background-color: #2c2c2c;
            cursor: crosshair;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        h1 {
            color: #f0f0f0;
            text-shadow: 2px 2px 4px #000;
        }
        p {
            color: #b0b0b0;
            text-align: center;
            margin-top: 10px;
            font-size: 1.1em;
        }
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
        }
        #controls label {
            font-size: 0.9em;
        }
        #controls input[type="range"] {
            -webkit-appearance: none;
            width: 150px;
            height: 8px;
            background: #555;
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
            border-radius: 5px;
        }
        #controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00aaff;
            cursor: pointer;
            border-radius: 50%;
        }
        #controls input[type="range"]:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <h1>í˜„ì‹¤ì ì¸ ê¸°íƒ€ í˜„ ì‹œë®¬ë ˆì´í„° ğŸ¸</h1>
    <p>ë§ˆìš°ìŠ¤ë¥¼ í˜„ì— ê°€ì ¸ë‹¤ ëŒ€ê³  í´ë¦­í•˜ì—¬ ë‹¹ê²¼ë‹¤ê°€ ë†“ì•„ë³´ì„¸ìš”!</p>
    <canvas id="stringCanvas" width="800" height="400"></canvas>
    
    <div id="controls">
        <label for="tension">ì¥ë ¥: <span id="tensionValue">32</span></label>
        <input type="range" id="tension" min="0.01" max="0.2" step="0.01" value="0.12">
        
        <label for="damping">ê°ì‡ : <span id="dampingValue">0.998</span></label>
        <input type="range" id="damping" min="0.9" max="0.999" step="0.001" value="0.998">
        
        <label for="friction">ë§ˆì°°: <span id="frictionValue">0.999</span></label>
        <input type="range" id="friction" min="0.98" max="0.999" step="0.001" value="0.999">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('stringCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            const tensionControl = document.getElementById('tension');
            const dampingControl = document.getElementById('damping');
            const frictionControl = document.getElementById('friction');

            const tensionValueSpan = document.getElementById('tensionValue');
            const dampingValueSpan = document.getElementById('dampingValue');
            const frictionValueSpan = document.getElementById('frictionValue');

            let tension = parseFloat(tensionControl.value);
            let damping = parseFloat(dampingControl.value);
            let friction = parseFloat(frictionControl.value);

            tensionControl.addEventListener('input', (e) => {
                tension = parseFloat(e.target.value);
                tensionValueSpan.textContent = tension.toFixed(2);
            });
            dampingControl.addEventListener('input', (e) => {
                damping = parseFloat(e.target.value);
                dampingValueSpan.textContent = damping.toFixed(3);
            });
            frictionControl.addEventListener('input', (e) => {
                friction = parseFloat(e.target.value);
                frictionValueSpan.textContent = friction.toFixed(3);
            });

            // í˜„ì˜ ì†ì„± ì •ì˜
            class StringPoint {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.oldY = y;
                    this.velocity = 0;
                    this.acceleration = 0;
                }
            }
            
            // í˜„ì˜ ë¶€ë“œëŸ¬ì›€ì„ ìœ„í•´ ì ì˜ ìˆ˜ë¥¼ ë” ëŠ˜ë¦¼
            const numPoints = 400; 
            const string = [];
            const initialY = height / 2;

            // í˜„ì˜ ì´ˆê¸°í™”
            for (let i = 0; i < numPoints; i++) {
                string.push(new StringPoint((i / (numPoints - 1)) * width, initialY));
            }

            let isDragging = false;
            let dragPointIndex = -1;

            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                let closestDist = Infinity;
                for (let i = 0; i < numPoints; i++) {
                    const point = string[i];
                    const dist = Math.sqrt(Math.pow(point.x - mouseX, 2) + Math.pow(point.y - mouseY, 2));
                    if (dist < closestDist) {
                        closestDist = dist;
                        dragPointIndex = i;
                    }
                }
                
                if (closestDist < 20) {
                    isDragging = true;
                    string[dragPointIndex].y = mouseY;
                    string[dragPointIndex].oldY = mouseY;
                    handleDrag(mouseY);
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || dragPointIndex === -1) return;
                const rect = canvas.getBoundingClientRect();
                const mouseY = e.clientY - rect.top;
                string[dragPointIndex].y = mouseY;
                string[dragPointIndex].oldY = mouseY;
                handleDrag(mouseY);
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                dragPointIndex = -1;
            });
            
            // ë“œë˜ê·¸ ì‹œ ì£¼ë³€ ì ë“¤ í•¨ê»˜ ì´ë™ì‹œí‚¤ëŠ” í•¨ìˆ˜
            function handleDrag(mouseY) {
                if (dragPointIndex === -1) return;

                const dragPoint = string[dragPointIndex];
                const deltaY = mouseY - initialY;
                const totalWidth = numPoints - 1;

                // ì¢Œì¸¡ ë¶€ë¶„
                for (let i = 0; i < dragPointIndex; i++) {
                    const distRatio = (dragPointIndex - i) / dragPointIndex;
                    string[i].y = initialY + deltaY * (1 - distRatio);
                    string[i].oldY = string[i].y;
                }

                // ìš°ì¸¡ ë¶€ë¶„
                for (let i = dragPointIndex + 1; i < numPoints; i++) {
                    const distRatio = (i - dragPointIndex) / (totalWidth - dragPointIndex);
                    string[i].y = initialY + deltaY * (1 - distRatio);
                    string[i].oldY = string[i].y;
                }
            }


            // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
            function animate() {
                ctx.clearRect(0, 0, width, height);
                
                // í˜„ ì‹œë®¬ë ˆì´ì…˜ ì—…ë°ì´íŠ¸ (Verlet Integration)
                if (!isDragging) {
                    for (let i = 1; i < numPoints - 1; i++) {
                        const prevPoint = string[i - 1];
                        const currPoint = string[i];
                        const nextPoint = string[i + 1];

                        const force = tension * (prevPoint.y + nextPoint.y - 2 * currPoint.y);
                        currPoint.acceleration = force;
                    }

                    for (let i = 1; i < numPoints - 1; i++) {
                        const currPoint = string[i];
                        const tempY = currPoint.y;
                        
                        currPoint.y = currPoint.y * 2 - currPoint.oldY + currPoint.acceleration;
                        currPoint.oldY = tempY;

                        currPoint.y = initialY + (currPoint.y - initialY) * damping * friction;
                    }
                } else {
                    handleDrag(string[dragPointIndex].y);
                }

                // í˜„ ê·¸ë¦¬ê¸° (ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
                ctx.beginPath();
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.moveTo(string[0].x, string[0].y);
                
                for (let i = 1; i < numPoints - 2; i++) {
                    const xc = (string[i].x + string[i + 1].x) / 2;
                    const yc = (string[i].y + string[i + 1].y) / 2;
                    ctx.quadraticCurveTo(string[i].x, string[i].y, xc, yc);
                }
                ctx.quadraticCurveTo(string[numPoints - 2].x, string[numPoints - 2].y, string[numPoints - 1].x, string[numPoints - 1].y);
                ctx.stroke();

                requestAnimationFrame(animate);
            }

            animate();
        });
    </script>
</body>
</html>