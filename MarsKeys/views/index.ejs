<!doctype html>
<html lang="<%= (typeof lang !== 'undefined' ? lang : 'en') %>">
<head>
  <meta charset="utf-8" />
  <title>MarsKeys • three.js Cube</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Inline CSS -->
  <style>
    :root {
      --bg: #0e1016;
      --panel: rgba(255,255,255,.04);
      --text: #cfd6e6;
      --accent: #9bb4ff;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden; /* full-canvas */
    }
    #app {
      position: fixed; inset: 0;
    }
    canvas { display: block; outline: none; }

    /* small on-screen help */
    .hint {
      position: fixed; left: 12px; bottom: 12px;
      padding: .55rem .7rem;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: .7rem;
      backdrop-filter: blur(4px);
      user-select: none;
      pointer-events: none;
      color: var(--text);
      font-size: 13px;
      opacity: .9;
    }
    .hint kbd {
      font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      padding: 0 .35rem;
      border-radius: .35rem;
    }

    /* optional watermark */
    .brand {
      position: fixed; right: 12px; top: 12px;
      padding: .4rem .6rem;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: .6rem;
      backdrop-filter: blur(4px);
      font-weight: 600; font-size: 13px; letter-spacing: .2px;
      user-select: none;
    }
  </style>

  <!-- Import maps (CDN modules) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hint">
    <strong>Cube demo</strong> — <kbd>hover</kbd> grows • drag to orbit • scroll to zoom • tap = toggle
  </div>
  <div class="brand">MarsKeys · three.js</div>

  <!-- Inline JS -->
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

    // --- basics
    const rootEl = document.getElementById("app");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e1016);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(2.2, 1.6, 2.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    rootEl.appendChild(renderer.domElement);

    // --- lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x2b2b2b, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(3, 4, 2);
    dir.castShadow = false;
    scene.add(dir);

    // --- optional ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(20, 20),
      new THREE.MeshStandardMaterial({ color: 0x141826, roughness: 1, metalness: 0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.5;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.target.set(0, 0.25, 0);

    // --- raycasting for hover
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let pointerInside = false;
    function onPointerMove(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      pointerInside = true;
    }
    function onPointerLeave() { pointerInside = false; }
    renderer.domElement.addEventListener("pointermove", onPointerMove);
    renderer.domElement.addEventListener("pointerleave", onPointerLeave);

    // --- load GLB (export your Blender cube to /public/models/cube.glb)
    const MODEL_URL = "/models/cube.glb";
    const loader = new GLTFLoader();

    let cubeRoot = null;
    let hover = false;
    let tapToggle = false;

    loader.load(
      MODEL_URL,
      (gltf) => {
        cubeRoot = gltf.scene;
        cubeRoot.traverse((o) => {
          if (o.isMesh) {
            // If the exported material isn't PBR, swap to a decent standard one
            if (!o.material || !("metalness" in o.material)) {
              o.material = new THREE.MeshStandardMaterial({
                color: 0x9bb4ff,
                roughness: 0.45,
                metalness: 0.2
              });
            }
            o.castShadow = true;
          }
        });
        cubeRoot.position.set(0, 0, 0);
        scene.add(cubeRoot);
      },
      undefined,
      (err) => {
        console.error("GLB load error:", err);
      }
    );

    // --- mobile: tap toggles scale
    renderer.domElement.addEventListener("pointerdown", () => { tapToggle = !tapToggle; });

    // --- resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- animate
    const base = new THREE.Vector3(1, 1, 1);
    const big  = new THREE.Vector3(1.35, 1.35, 1.35);
    const clock = new THREE.Clock();

    function tick() {
      const dt = clock.getDelta();

      if (cubeRoot) {
        // hover detection (desktop)
        if (pointerInside) {
          raycaster.setFromCamera(pointer, camera);
          const hits = raycaster.intersectObject(cubeRoot, true);
          hover = hits.length > 0;
        } else {
          hover = false;
        }

        // scale with smooth lerp
        const target = (hover || tapToggle) ? big : base;
        cubeRoot.scale.lerp(target, 10 * dt);

        // subtle idle rotation
        cubeRoot.rotation.y += 0.4 * dt;
      }

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>
