<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mars Keys — Counter to Welcome (FAST)</title>
  <style>
    :root{
      --bg:#0e1016; 
      --text:#eef2f8; 
      --muted:#9aa3b2;
      --fill:0%;
      --pastel-red-1:#ff8aa1; --pastel-red-2:#ff6b7a; --pastel-red-3:#ff9db0;
      --pastel-blue-1:#78aaff; --pastel-blue-2:#5ea1ff; --pastel-blue-3:#b2d1ff;
    }
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:sans-serif;
      overflow-x:hidden; overflow-y:hidden;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    .wrap{
      position:relative; min-height:100vh; display:flex; flex-direction:column; align-items:stretch; padding:5vw; overflow:visible;
    }
    .brand{margin:0; font-weight:900; line-height:.9;}
    .brand-line{position:relative; display:block; font-size:clamp(56px,14vw,200px);}
    .plain{position:relative; z-index:1;}
    .fill{position:absolute; inset:0; width:var(--fill); overflow:hidden; z-index:2;}
    .fill > span{display:block; color:transparent; -webkit-background-clip:text; background-clip:text;}
    .brand-line[data-c="red"] .fill > span{background-image:linear-gradient(180deg,var(--pastel-red-1),var(--pastel-red-2),var(--pastel-red-3));}
    .brand-line[data-c="blue"] .fill > span{background-image:linear-gradient(180deg,var(--pastel-blue-1),var(--pastel-blue-2),var(--pastel-blue-3));}
    .tagline{font-size:clamp(16px,2.6vw,28px); font-weight:600; margin-top:1rem;}

    /* 텍스트는 폭발 직전에만 숨김 (캔버스가 takeover) */
    .brand-line .plain,.brand-line .fill{transition:opacity .12s linear;}

    /* 캔버스 층들 */
    .text-overlay,.p-canvas{
      position:absolute; inset:0; pointer-events:none;
    }
    .text-overlay{ z-index:3; }   /* 글자 복제/지우기 */
    .p-canvas{ z-index:4; }       /* 파티클 드로잉 */

    /* 카운터 */
    #counter{
      position:fixed; top:50%; right:5%; transform:translateY(-50%);
      font-size:clamp(40px,10vw,120px); font-weight:900; color:white;
      text-shadow:0 0 10px rgba(255,255,255,0.5);
      user-select:none; pointer-events:none; transition:opacity .5s ease; z-index:100;
    }

    /* Welcome */
    .welcome-wrap{ position:relative; width:100%; height:100vh; min-height:0; }
    #welcome{
      position:absolute; top:10%; left:50%; transform:translate(-50%,-50%) scale(0.8);
      opacity:0; font-size:clamp(60px,12vw,180px); font-weight:900; color:white; text-align:center; letter-spacing:.02em;
      pointer-events:none; transition:opacity 1s ease, transform 1s cubic-bezier(.2,.7,.2,1); will-change:opacity, transform; z-index:0;
      text-shadow:0 0 18px rgba(255,255,255,.25);
    }
    #welcome.visible{ opacity:1; transform:translate(-50%,-50%) scale(1.45); z-index:10; }

    /* 이후 컨텐츠 */
    .scrollable-content{ padding:0 5vw; text-align:center; position:relative; display:none; }
    .scrollable-content p{ max-width:800px; margin:0 auto 1.5rem; line-height:1.8; color:var(--muted); font-size:clamp(14px,2vw,18px); }
    .scrollable-content .temp-box{
      background:rgba(255,255,255,0.05); border-radius:12px; padding:2rem; margin-bottom:2rem;
      box-shadow:0 10px 30px rgba(0,0,0,.25); backdrop-filter:blur(2px);
    }
  </style>
</head>
<body>
  <main class="wrap">
    <h1 class="brand">
      <span class="brand-line" data-c="red">
        <span class="plain">Mars</span>
        <span class="fill"><span>Mars</span></span>
        <canvas class="text-overlay"></canvas>
        <canvas class="p-canvas"></canvas>
      </span>
      <span class="brand-line" data-c="blue">
        <span class="plain">Keys</span>
        <span class="fill"><span>Keys</span></span>
        <canvas class="text-overlay"></canvas>
        <canvas class="p-canvas"></canvas>
      </span>
    </h1>
    <p class="tagline">Video Game Music Studio</p>

    <div class="welcome-wrap" aria-hidden="true">
      <div id="welcome">Welcome</div>
    </div>
  </main>

  <div id="counter">0%</div>

  <div id="scrollContent" class="scrollable-content">
    <p>게임 음악 스튜디오 Mars Keys에 오신 것을 환영합니다...</p>
    <div class="temp-box"><h3>우리의 서비스</h3><p>게임 OST, SFX, VO, 인터랙티브 음악 시스템...</p></div>
    <div class="temp-box"><h3>포트폴리오</h3><p>RPG, SF 어드벤처 등...</p></div>
    <div class="temp-box"><h3>문의</h3><p>협업 및 프로젝트 문의는 언제든지 환영합니다.</p></div>
    <div style="height:100vh;"></div>
    <div class="temp-box"><p>마지막 임시 콘텐츠</p></div>
  </div>

  <script>
  (function(){
    // ======== TUNABLES (성능/감성 조절) ========
    const DENSITY   = 8;     // 글자 픽셀 샘플 간격(px, ↑일수록 입자 ↓, 성능↑)  ← 기본 6 → 8로 올려 부하↓
    const BUDGET    = 400;   // 프레임당 스폰 수(↑면 더 빨리 분해되지만 부하↑). 캔버스라 400도 거뜬.
    const SPEED_MIN = 0.08;  // 기본 확산 속도
    const SPEED_RND = 0.12;  // 랜덤 추가 속도
    const FRICTION  = 0.985; // 감쇠
    const SWIRL_AMP = 0.018; // 소용돌이 강도
    const DRIFT_AMP = 0.06;  // 우주 바람 강도
    const STICK_DUR = 220;   // 초반 글자형 유지(ms)  ← 살짝 줄여 체감 지연↓
    const RAMP_DUR  = 520;   // 이동량 0→1(ms)
    const PARTICLE_BASE = 2; // 파티클 기본 크기(px)

    // ============================================
    const html=document.documentElement, body=document.body;
    const counterEl=document.getElementById("counter");
    const welcome=document.getElementById("welcome");
    const scrollContent=document.getElementById("scrollContent");

    let p=0, accel=0.0018;
    let spawners=[]; // per-line state
    let autoAnimating=false, isFinalized=false;

    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const smoothstep=(e0,e1,x)=>{const t=clamp((x-e0)/(e1-e0),0,1); return t*t*(3-2*t);};
    const easeOutCubic=t=>1-Math.pow(1-t,3);

    function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    const colorStops = {
      red:  [getVar('--pastel-red-1')||'#ff8aa1', getVar('--pastel-red-2')||'#ff6b7a', getVar('--pastel-red-3')||'#ff9db0'],
      blue: [getVar('--pastel-blue-1')||'#78aaff', getVar('--pastel-blue-2')||'#5ea1ff', getVar('--pastel-blue-3')||'#b2d1ff']
    };
    const colorMain = (c)=> c==='red' ? (getVar('--pastel-red-1')||'#ff8aa1') : (getVar('--pastel-blue-1')||'#78aaff');

    function setProgress(v){
      p=clamp(v,0,1);
      html.style.setProperty('--fill',(p*100).toFixed(2)+'%');
      if(!isFinalized) counterEl.textContent=Math.floor(p*100)+"%";
      if(p>=1 && !spawners.length && !isFinalized){
        (document.fonts?.ready || Promise.resolve()).then(()=>{
          snapshotToOverlay();
          prepareSpawners();
          explodeAndAnimate();
          showWelcome();
        });
      }
    }

    function startAutoAnimation(){
      if(autoAnimating||isFinalized) return;
      autoAnimating=true;
      (function step(){
        if(p<1){ p+=0.005; setProgress(p); requestAnimationFrame(step); }
        else { p=1; setProgress(1); autoAnimating=false; }
      })();
    }

    // ===== glow sprite 만들기 (캔버스용 라디얼 그라디언트) =====
    function makeGlowSprite(color){
      const sz=32, c=document.createElement('canvas');
      c.width=c.height=sz;
      const ctx=c.getContext('2d');
      const g=ctx.createRadialGradient(sz/2,sz/2,0, sz/2,sz/2,sz/2);
      g.addColorStop(0,'#ffffff');
      g.addColorStop(0.4,color);
      g.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=g;
      ctx.fillRect(0,0,sz,sz);
      return c;
    }

    // ===== 1) 글자를 overlay 캔버스에 복제 (같은 모양 유지) =====
    function snapshotToOverlay(){
      document.querySelectorAll('.brand-line').forEach(line=>{
        const plain = line.querySelector('.plain');
        const text  = plain?.textContent || '';
        const style = getComputedStyle(plain);
        const fontSize = parseInt(style.fontSize)||120;
        const fontFamily= style.fontFamily || 'sans-serif';
        const w = Math.max(2, line.offsetWidth);
        const h = Math.max(2, line.offsetHeight);
        const dpr = Math.max(1, window.devicePixelRatio||1);

        const overlay = line.querySelector('.text-overlay');
        overlay.width=w*dpr; overlay.height=h*dpr;
        overlay.style.width=w+'px'; overlay.style.height=h+'px';
        const octx = overlay.getContext('2d');
        octx.setTransform(dpr,0,0,dpr,0,0);
        octx.clearRect(0,0,w,h);

        const key = line.dataset.c==='red' ? 'red' : 'blue';
        const [c1,c2,c3] = colorStops[key];
        const grad = octx.createLinearGradient(0,0,0,h);
        grad.addColorStop(0,c1); grad.addColorStop(0.5,c2); grad.addColorStop(1,c3);

        octx.font = `900 ${fontSize}px ${fontFamily}`;
        octx.textBaseline='middle'; octx.textAlign='left';
        octx.fillStyle=grad;
        octx.fillText(text,0,h/2);

        // DOM 텍스트는 즉시 숨김 (캔버스가 takeover)
        line.querySelector('.plain').style.opacity=0;
        line.querySelector('.fill').style.opacity=0;
      });
    }

    // ===== 2) 스포너/파티클 준비 (라인별) =====
    function prepareSpawners(){
      spawners=[];
      document.querySelectorAll('.brand-line').forEach(line=>{
        const overlay = line.querySelector('.text-overlay');
        const pcanvas = line.querySelector('.p-canvas');
        const dpr = Math.max(1, window.devicePixelRatio||1);

        const w = Math.max(2, line.offsetWidth);
        const h = Math.max(2, line.offsetHeight);
        // p-canvas 세팅
        pcanvas.width=w*dpr; pcanvas.height=h*dpr;
        pcanvas.style.width=w+'px'; pcanvas.style.height=h+'px';
        const pctx = pcanvas.getContext('2d', { alpha:true });
        pctx.setTransform(dpr,0,0,dpr,0,0);

        // overlay 픽셀 읽기
        const octx = overlay.getContext('2d');
        const img = octx.getImageData(0,0,w,h).data;

        // 소스 좌표 만들기
        const cx=w/2, cy=h/2;
        const sources=[];
        for(let y=0;y<h;y+=DENSITY){
          for(let x=0;x<w;x+=DENSITY){
            const idx=((y|0)*w+(x|0))*4;
            if(img[idx+3]>128){
              const jx=x+(Math.random()-0.5)*1.0;
              const jy=y+(Math.random()-0.5)*1.0;
              const dx=jx-cx, dy=jy-cy, len=Math.hypot(dx,dy)||1;
              const dirx=dx/len, diry=dy/len;
              sources.push({
                x:jx, y:jy,
                vx: dirx*(SPEED_MIN+Math.random()*SPEED_RND),
                vy: diry*(SPEED_MIN+Math.random()*SPEED_RND),
                z: 0.6+Math.random()*0.8,
                seed1: Math.random()*Math.PI*2,
                seed2: Math.random()*Math.PI*2
              });
            }
          }
        }
        // 랜덤 셔플
        for(let i=sources.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [sources[i],sources[j]]=[sources[j],sources[i]]; }

        const col = colorMain(line.dataset.c);
        const sprite = makeGlowSprite(col);

        spawners.push({
          line, overlay, octx, pcanvas, pctx, sprite,
          w,h,dpr,
          sources, index:0,
          particles:[], // {x,y,vx,vy,z,alpha,born,life,seed1,seed2}
          cleared:0, removed:false
        });
      });
    }

    // ===== 3) 폭발 & 애니메이션 =====
    function explodeAndAnimate(){
      const startT = performance.now();
      let lastT = startT;

      function frame(now){
        const dt = clamp(now-lastT,0,40); lastT=now;

        let anyAlive=false, anySpawning=false;

        for(const sp of spawners){
          const {octx, overlay, pctx, sprite, w, h, particles} = sp;

          // 스폰: 한 프레임에 일정량만
          let budget=BUDGET;
          while(budget>0 && sp.index < sp.sources.length){
            const s = sp.sources[sp.index++];
            octx.clearRect(s.x, s.y, DENSITY, DENSITY); // 해당 픽셀 지우기 → 진짜 분해
            particles.push({
              x:s.x, y:s.y, vx:s.vx, vy:s.vy, z:s.z,
              alpha:0, born:now+Math.random()*300,
              life: 5000+Math.random()*2600,
              seed1:s.seed1, seed2:s.seed2
            });
            budget--;
          }
          if(sp.index < sp.sources.length) anySpawning=true;
          else if(!sp.removed){
            overlay.style.transition='opacity .35s ease';
            overlay.style.opacity='0';
            sp.removed=true; setTimeout(()=>overlay.remove(), 380);
          }

          // 파티클 업데이트 & 그리기
          pctx.clearRect(0,0,w,h);
          pctx.globalCompositeOperation='source-over';
          // 배경 블러 잔상 없음 (깨끗이)
          pctx.globalCompositeOperation='lighter'; // 글로우 합성

          for(let i=0;i<particles.length;i++){
            const pt=particles[i];
            const age=now-pt.born;
            if(age<0) continue;
            const lifeT=age/pt.life;
            if(lifeT>=1){ pt.alpha=0; continue; }

            // 알파
            if(lifeT<0.15) pt.alpha=lerp(0,0.95,lifeT/0.15);
            else if(lifeT>0.82) pt.alpha=lerp(0.95,0,(lifeT-0.82)/0.18);
            else pt.alpha=0.95;

            const moveGain=smoothstep(STICK_DUR,STICK_DUR+RAMP_DUR,age);
            const tt=now*0.001;
            const swirlX=Math.sin(tt*0.9+pt.seed1)*SWIRL_AMP;
            const swirlY=Math.cos(tt*0.8+pt.seed2)*SWIRL_AMP;
            pt.vx += (swirlX + Math.sin(pt.seed1+tt*0.25)*DRIFT_AMP*0.001)*moveGain;
            pt.vy += (swirlY + Math.cos(pt.seed2+tt*0.22)*DRIFT_AMP*0.001)*moveGain;
            pt.vx*=FRICTION; pt.vy*=FRICTION;
            pt.x += pt.vx*dt*moveGain; pt.y += pt.vy*dt*moveGain;

            const s = (0.8+pt.z*0.6)*PARTICLE_BASE;
            pctx.globalAlpha = pt.alpha;
            // 스프라이트 드로우 (중심 정렬)
            pctx.drawImage(sprite, pt.x - s, pt.y - s, s*2, s*2);

            if(pt.alpha>0) anyAlive=true;
          }
          pctx.globalAlpha=1;
        }

        if(anyAlive || anySpawning) requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    function showWelcome(){
      setTimeout(()=>{ counterEl.style.opacity=0; }, 300);
      setTimeout(()=>{ welcome.classList.add("visible"); }, 900);
      setTimeout(()=>{
        scrollContent.style.display="block";
        isFinalized=true; body.style.overflowY="auto";
      }, 1400);
    }

    // 입력
    function onWheel(e){
      if(isFinalized) return;
      const dy=e.deltaY;
      if(p<0.5){ e.preventDefault(); setProgress(p+dy*accel); if(p>=0.5) startAutoAnimation(); }
      else{ e.preventDefault(); if(!autoAnimating) startAutoAnimation(); }
    }
    function onTouchMove(e){
      if(isFinalized) return;
      const t=e.touches[0], y=t.clientY;
      if(onTouchMove.lastY!=null){
        const dy=onTouchMove.lastY-y;
        if(dy>0&&p<0.5){ e.preventDefault(); setProgress(p+dy*accel*2); if(p>=0.5) startAutoAnimation(); }
        else if(dy>0&&p>=0.5&&!autoAnimating){ e.preventDefault(); startAutoAnimation(); }
      }
      onTouchMove.lastY=y;
    }
    function onTouchEnd(){ if(!isFinalized) onTouchMove.lastY=undefined; }

    window.addEventListener('wheel',onWheel,{passive:false});
    window.addEventListener('touchstart',e=>{ onTouchMove.lastY=e.touches[0].clientY; });
    window.addEventListener('touchmove',onTouchMove,{passive:false});
    window.addEventListener('touchend',onTouchEnd);

    // 진행바
    setProgress(0);
  })();
  </script>
</body>
</html>
