<!DOCTYPE html>
<% const isKorean = (lang || '').toLowerCase().startsWith('ko'); %>
<html lang="<%= lang %>">
  <%- include('partials/head') %>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>
    <% if (isSearch) { %>
      <%= locale.search_results_for %>: <%= searchKeyword %>
    <% } else if (selectedCategory) { %>
      <%= selectedCategory %>
    <% } else { %>
      <%= locale.marskeys_title %>
    <% } %>
  </title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Michroma&display=swap" rel="stylesheet">
  <% if (isKorean) { %>
    <link href="https://fonts.googleapis.com/css2?family=Yeon+Sung&display=swap" rel="stylesheet">
  <% } %>

  <style>
    :root {
      --bg: #0e1016;
      --text: #eef2f8;
      --muted: #9aa3b2;
      --fill-int: 0%;
      --pastel-red-1: #ff8aa1;
      --pastel-blue-1: #78aaff;
      --pastel-red-2: #ff6b7a;
      --pastel-blue-2: #5ea1ff;
      --pastel-red-3: #ff9db0;
      --pastel-blue-3: #b2d1ff;
    }

    * { box-sizing: border-box }

    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow-x: hidden; overflow-y: hidden;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    body.lang-ko #welcome{ font-family: 'Yeon Sung','Michroma',system-ui,sans-serif; font-weight:400; }

    body.show-background {
      background-image: url('https://images.unsplash.com/photo-1502126428-175f0881ed53?q=80&w=2670&auto=format&fit=crop');
      background-repeat: no-repeat; background-position: center; background-size: cover; background-attachment: fixed;
      transition: background-image 2s ease;
    }

    .wrap { position: relative; min-height: 100svh; padding: 5vw; overflow: visible; }

    .brand { margin: 0; line-height: 1; font-family: "Michroma",system-ui,sans-serif; position: relative; z-index: 40; }
    .brand-line { display:block; font-size: clamp(56px, min(14vw, 28vh), 200px); line-height:1.06; padding-bottom: .18em; position:relative; }
    .brand-line+.brand-line{ margin-top:-0.32em; }

    .ink{
      display:inline-block; color:transparent; -webkit-text-fill-color:transparent;
      -webkit-background-clip:text; background-clip:text; background-repeat:no-repeat,no-repeat;
      background-size:var(--fill-int) 100%, 100% 100%;
      background-image:var(--grad), linear-gradient(#fff,#fff);
      letter-spacing:0; padding-bottom:.28em; transform:translateZ(0);
    }
    .brand-line:nth-child(1) .ink{ --grad:linear-gradient(180deg,var(--pastel-red-1),var(--pastel-red-2),var(--pastel-red-3)); }
    .brand-line:nth-child(2) .ink{ --grad:linear-gradient(180deg,var(--pastel-blue-1),var(--pastel-blue-2),var(--pastel-blue-3)); }

    .tagline {
      font-size: clamp(16px, 2.6vw, 28px); font-weight: 600; margin: 1rem 0 0; color: var(--muted);
      position: relative; transition: color .55s ease; will-change: color;
    }
    .tagline.shine-to-white{ overflow:visible; }
    .tagline.shine-to-white::before{
      content: attr(data-text); position:absolute; inset:0; pointer-events:none; color:transparent; -webkit-text-fill-color:transparent;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.16) 32%, rgba(255,255,255,.9) 50%, rgba(255,255,255,.16) 68%, rgba(255,255,255,0) 100%);
      -webkit-background-clip:text; background-clip:text; transform: translateX(-120%) skewX(-18deg);
      filter: blur(.3px); animation: shine-sweep 900ms cubic-bezier(.2,.7,.2,1) forwards;
    }
    .tagline.to-white{ color:#fff; }
    @keyframes shine-sweep{ to{ transform: translateX(120%) skewX(-18deg); } }

    #counter{
      position:absolute; right:5vw; bottom: clamp(16px, 6vh, 48px);
      text-align:right; font-size: clamp(28px, min(7vw, 10vh), 96px); font-family:"Michroma",system-ui,sans-serif; font-weight:900; color:#fff;
      user-select:none; pointer-events:none; transition:opacity .6s ease; z-index:40; margin:0;
    }

    #particleCanvas{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:50; }

    /* 🔥 새로 추가: 고정 파형 라인 캔버스 */
    #lineViz{
      position: fixed; pointer-events: none; z-index: 55;
      /* top/left/size는 JS에서 동적으로 */
    }

    #welcome{
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(.86);
      opacity:0; font-size:clamp(48px,10vw,130px); font-family:"Michroma",system-ui,sans-serif; color:#fff; letter-spacing:.01em;
      max-width:92vw; white-space:nowrap; transition: opacity 1s ease, transform 1s cubic-bezier(.2,.7,.2,1), text-shadow 1s ease-out;
      will-change: opacity, transform, text-shadow; pointer-events:none; z-index:60; text-shadow:0 0 0 transparent;
    }
    #welcome.visible{ opacity:1; transform:translate(-50%,-50%) scale(1.22); }
    #welcome.welcome-glow{ text-shadow:0 0 20px rgba(255,255,255,.8),0 0 40px rgba(255,255,255,.6),0 0 60px rgba(255,255,255,.4); }

    .scrollable-content{
      padding:0 5vw 6rem; text-align:center; display:none; max-width:1200px; margin:0 auto; position:relative; z-index:10;
    }
    .scrollable-content p{ max-width:800px; margin:0 auto 1.5rem; line-height:1.8; color:var(--muted); font-size:clamp(14px,2vw,18px); }
    .scrollable-content .temp-box{ background:rgba(255,255,255,.05); border-radius:12px; padding:2rem; margin:2rem auto; max-width:900px; }

    @media (max-width: 768px){
      .brand-line{ line-height:1.08; padding-bottom:.16em; }
      .brand-line+.brand-line{ margin-top:-0.26em; }
    }
  </style>
</head>

<body class="<%= isKorean ? 'lang-ko' : '' %>">
  <main class="wrap" id="wrap">
    <canvas id="particleCanvas"></canvas>
    <!-- 고정 파형 라인 -->
    <canvas id="lineViz"></canvas>

    <h1 class="brand" id="brand">
      <span class="brand-line" data-c="red"><span class="ink" id="mars"><%= locale.mars_keys.split(' ')[0] %></span></span>
      <span class="brand-line" data-c="blue"><span class="ink" id="keys"><%= locale.mars_keys.split(' ')[1] %></span></span>
    </h1>

    <p class="tagline" data-text="<%= locale.game_music_studio %>"><%= locale.game_music_studio %></p>

    <div id="counter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">0%</div>
    <div id="welcome"><%= locale.welcome %></div>
  </main>

  <div id="scrollContent" class="scrollable-content">
    <p><%= locale.game_music_studio %> <%= locale.marskeys_title %>에 오신 것을 환영합니다...</p>
    <div class="temp-box"><h3>우리의 서비스</h3><p>게임 OST, SFX, VO, 인터랙티브 음악 시스템...</p></div>
    <div class="temp-box"><h3>포트폴리오</h3><p>RPG, SF 어드벤처 등...</p></div>
    <div class="temp-box"><h3>문의</h3><p>협업 및 프로젝트 문의는 언제든지 환영합니다.</p></div>
    <div style="height:60vh;"></div>
    <div class="temp-box"><p>마지막 임시 콘텐츠</p></div>
  </div>

  <script>
    (function(){
      const html = document.documentElement;
      const body = document.body;
      const wrap = document.getElementById('wrap');
      const counterEl = document.getElementById("counter");
      const welcome = document.getElementById("welcome");
      const scrollContent = document.getElementById("scrollContent");

      // ===== 기존 파티클 효과 코드 (생략 없이 유지) =====
      const particleCanvas = document.getElementById('particleCanvas');
      const pctx = particleCanvas.getContext('2d');
      const tagline = document.querySelector('.tagline');

      let p = 0, autoAnimating = false, isFinalized = false, particlesGenerated = false;
      const IS_MOBILE = window.matchMedia("(max-width: 768px)").matches;
      const CSS = getComputedStyle(document.documentElement);
      const COL_RED = (CSS.getPropertyValue('--pastel-red-2') || '#ff6b7a').trim();
      const COL_BLUE = (CSS.getPropertyValue('--pastel-blue-2') || '#5ea1ff').trim();
      let particles = [];
      let particlePhase = 'idle';
      let phaseStartTime = 0;

      function resizeParticleCanvas(){
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = wrap.getBoundingClientRect();
        particleCanvas.width = Math.floor(rect.width * dpr);
        particleCanvas.height = Math.floor(rect.height * dpr);
        particleCanvas.style.width = rect.width + 'px';
        particleCanvas.style.height = rect.height + 'px';
        pctx.setTransform(dpr,0,0,dpr,0,0);
        pctx.clearRect(0,0,rect.width,rect.height);
      }

      function setProgress(v){
        p = Math.max(0, Math.min(1, v));
        const pct = Math.round(p*100);
        html.style.setProperty('--fill-int', pct + '%');
        if(!isFinalized){ counterEl.textContent = pct + "%"; counterEl.setAttribute('aria-valuenow', String(pct)); }
        if(p>=1 && !particlesGenerated && !isFinalized){ generateParticles(); fadeOutText(); showWelcome(); runParticleShow(); }
      }

      function startAutoAnimation(){
        if(autoAnimating || isFinalized) return;
        autoAnimating = true;
        (function step(){
          if(p<1){ p=Math.min(1,p+0.005); setProgress(p); requestAnimationFrame(step); }
          else autoAnimating=false;
        })();
      }

      function drawTextToCanvas(text, fontSize, fontFamily){
        const off = document.createElement('canvas'); const ctx = off.getContext('2d');
        ctx.font = `${fontSize}px ${fontFamily}`; const m = ctx.measureText(text);
        const h = (m.actualBoundingBoxAscent||fontSize)+(m.actualBoundingBoxDescent||fontSize*0.25);
        off.width = Math.ceil(m.width); off.height = Math.ceil(h);
        ctx.font = `${fontSize}px ${fontFamily}`; ctx.fillStyle='#fff'; ctx.textBaseline='top'; ctx.fillText(text,0,0);
        return { canvas: off };
      }
      function computeStepForTarget(canvas, target){
        const area = canvas.width*canvas.height; const est = area*0.45;
        return Math.max(3, Math.floor(Math.sqrt(est/Math.max(1,target))));
      }
      function generateParticles(){
        particlesGenerated=true; particles.length=0;
        const wrapRect = wrap.getBoundingClientRect();
        const lines = [
          { el: document.getElementById('mars').parentElement, color: 'red', textEl: document.getElementById('mars') },
          { el: document.getElementById('keys').parentElement, color: 'blue', textEl: document.getElementById('keys') }
        ];
        const centerX = wrapRect.width*0.5, centerY = wrapRect.height*0.5;
        const TARGET_PER_LINE = IS_MOBILE ? 4000 : 1500;

        lines.forEach(({el,color,textEl})=>{
          const rect = el.getBoundingClientRect(); const style = getComputedStyle(textEl);
          const { canvas } = drawTextToCanvas(textEl.textContent, parseFloat(style.fontSize), style.fontFamily);
          const data = canvas.getContext('2d').getImageData(0,0,canvas.width,canvas.height).data;
          const STEP = computeStepForTarget(canvas, TARGET_PER_LINE);
          for(let y=0;y<canvas.height;y+=STEP){
            for(let x=0;x<canvas.width;x+=STEP){
              const idx=(y*canvas.width+x)*4;
              if(data[idx+3]>128){
                const px = rect.left - wrapRect.left + x;
                const py = rect.top  - wrapRect.top  + y;
                const dx = px-centerX, dy=py-centerY, dist=Math.hypot(dx,dy)+1e-4, boost=0.6+Math.random()*1.1;
                particles.push({ x:px,y:py, vx:(Math.random()-0.5)*0.6+(dx/dist)*boost, vy:(Math.random()-0.5)*0.6+(dy/dist)*boost, alpha:1, color, tx:null,ty:null,reached:false });
              }
            }
          }
        });
        const cap = IS_MOBILE?8000:3000; if(particles.length>cap){ const s=[]; for(let i=0;i<cap;i++) s.push(particles[(Math.random()*particles.length)|0]); particles=s; }
      }
      function fadeOutText(){ document.querySelectorAll('.ink').forEach(el=>{ el.style.transition='opacity .3s ease'; el.style.opacity='0'; }); }
      function showWelcome(){
        setTimeout(()=>{ counterEl.style.opacity=0; },350);
        setTimeout(()=>{ welcome.classList.add("visible"); welcome.classList.add("welcome-glow"); },900);
        setTimeout(()=>{ scrollContent.style.display="block"; isFinalized=true; body.style.overflowY="auto"; },1500);
      }

      function buildTaegeukTargets(minRed,minBlue){
        const rect = wrap.getBoundingClientRect();
        const cx=rect.width*.5, cy=rect.height*.5, R=Math.min(rect.width,rect.height)*.26;
        let step=Math.max(4,Math.round(Math.min(rect.width,rect.height)/(IS_MOBILE?120:150)));
        function sample(s){
          const red=[], blue=[], rSmall=R*.5, r2=rSmall*rSmall, offX=R*.5;
          for(let y=-R;y<=R;y+=s){ for(let x=-R;x<=R;x+=s){
            if(x*x+y*y>R*R) continue;
            let tgt=null;
            const dL=(x+offX)*(x+offX)+y*y, dR=(x-offX)*(x-offX)+y*y;
            if(dL<=r2) tgt='red'; else if(dR<=r2) tgt='blue'; else tgt=(y<0)?'red':'blue';
            (tgt==='red'?red:blue).push({x:cx+x,y:cy+y});
          }}
          return {red,blue};
        }
        let tgs=sample(step);
        while((tgs.red.length<minRed||tgs.blue.length<minBlue)&&step>2){ step=Math.max(2,Math.floor(step*.85)); tgs=sample(step); }
        function down(a,n){ if(a.length<=n) return a; const out=[]; for(let i=0;i<n;i++) out.push(a[(Math.random()*a.length)|0]); return out; }
        const cr=Math.max(minRed*1.15|0,minRed), cb=Math.max(minBlue*1.15|0,minBlue);
        if(tgs.red.length>cr) tgs.red=down(tgs.red,cr); if(tgs.blue.length>cb) tgs.blue=down(tgs.blue,cb);
        function shuf(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }
        shuf(tgs.red); shuf(tgs.blue); return tgs;
      }
      function assignTaegeukTargets(){
        const reds=particles.filter(p=>p.color==='red'), blues=particles.filter(p=>p.color==='blue');
        const t=buildTaegeukTargets(reds.length,blues.length);
        reds.forEach((pt,i)=>{ const k=t.red[i%t.red.length]; pt.tx=k.x; pt.ty=k.y; pt.reached=false; });
        blues.forEach((pt,i)=>{ const k=t.blue[i%t.blue.length]; pt.tx=k.x; pt.ty=k.y; pt.reached=false; });
      }
      function runParticleShow(){
        particlePhase='explode'; phaseStartTime=performance.now();
        function frame(now){
          const rect=wrap.getBoundingClientRect(); const W=rect.width,H=rect.height;
          pctx.clearRect(0,0,W,H);
          if(particlePhase==='explode' && now-phaseStartTime>=2000){ assignTaegeukTargets(); particlePhase='morph'; phaseStartTime=now; }
          else if(particlePhase==='morph'){
            const allReached=particles.every(pt=>pt.reached);
            if(allReached || (now-phaseStartTime)>1600){ particlePhase='hold'; phaseStartTime=now; }
          } else if(particlePhase==='hold' && now-phaseStartTime>=900){
            welcome.classList.remove("welcome-glow");
            if(tagline){ tagline.classList.add('shine-to-white'); setTimeout(()=>tagline.classList.add('to-white'),900); }
            for(const pt of particles){ const ang=Math.random()*Math.PI*2, spd=0.05+Math.random()*0.1; pt.vx=Math.cos(ang)*spd; pt.vy=Math.sin(ang)*spd; pt.reached=false; }
            particlePhase='disperse'; phaseStartTime=now;
          }
          let any=false;
          for(const pt of particles){
            if(pt.alpha<=0) continue; any=true;
            if(particlePhase==='explode'){ pt.vx*=0.985; pt.vy*=0.985; pt.vx+=(Math.random()-0.5)*0.02; pt.vy+=(Math.random()-0.5)*0.02; pt.alpha=Math.max(0.8, pt.alpha-0.0006); }
            else if(particlePhase==='morph'){ if(pt.tx!=null){ const dx=pt.tx-pt.x, dy=pt.ty-pt.y; pt.vx=pt.vx*0.82+dx*0.06; pt.vy=pt.vy*0.82+dy*0.06; if(Math.hypot(dx,dy)<1.6){ pt.x=pt.tx; pt.y=pt.ty; pt.vx=pt.vy=0; pt.reached=true; } } pt.alpha=Math.min(1, pt.alpha+0.01); }
            else if(particlePhase==='hold'){ const t=(now-phaseStartTime)*0.004; pt.x+=Math.sin(t+(pt.tx||pt.x)*0.01)*0.06; pt.y+=Math.cos(t+(pt.ty||pt.y)*0.01)*0.06; pt.alpha=1; }
            else if(particlePhase==='disperse'){ pt.vx*=0.995; pt.vy*=0.995; pt.alpha-= (pt.color==='blue'?0.0015:0.002); }
            pt.x+=pt.vx; pt.y+=pt.vy;
          }
          if(particlePhase==='disperse' && !any){ body.classList.add('show-background'); particlePhase='done'; return; }
          pctx.globalCompositeOperation='source-over'; pctx.shadowBlur=10; pctx.shadowOffsetX=0; pctx.shadowOffsetY=0;
          function drawPass(name,col){ pctx.shadowColor=col; pctx.fillStyle=col; for(const pt of particles){ if(pt.alpha<=0||pt.color!==name) continue; pctx.globalAlpha=Math.max(0,pt.alpha); pctx.beginPath(); pctx.arc(pt.x,pt.y,1.6,0,Math.PI*2); pctx.fill(); } }
          drawPass('red',COL_RED); drawPass('blue',COL_BLUE);
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      function onWheel(e){ if(isFinalized) return; e.preventDefault(); const dy=e.deltaY; if(p<0.5){ setProgress(p+dy*0.0018); if(p>=0.5) startAutoAnimation(); } else if(!autoAnimating){ startAutoAnimation(); } }
      function onTouchMove(e){ if(isFinalized) return; const t=e.touches[0]; const y=t.clientY; if(typeof onTouchMove.lastY!=='undefined'){ const dy=onTouchMove.lastY-y; if(p<0.5){ setProgress(p+dy*0.0018*2); if(p>=0.5) startAutoAnimation(); } else if(!autoAnimating && dy>0){ startAutoAnimation(); } } onTouchMove.lastY=y; }
      function onTouchEnd(){ if(!isFinalized) onTouchMove.lastY=undefined; }

      window.addEventListener('resize', resizeParticleCanvas);
      window.addEventListener('wheel', onWheel, { passive:false });
      window.addEventListener('touchstart', e=>{ onTouchMove.lastY=e.touches[0].clientY; });
      window.addEventListener('touchmove', onTouchMove, { passive:false });
      window.addEventListener('touchend', onTouchEnd);

      resizeParticleCanvas(); setProgress(0);

      /* ============================================================
         🔊 ‘각진’ 고정 파형 라인 (ECG/Visualizer 스타일)
         - 데스크톱: Mars/Keys 사이
         - 모바일: 화면 정중앙
         - 왼쪽 시작점 더 오른쪽에서 시작 + 좌 베이스 길게
         ============================================================ */
      const lineCanvas = document.getElementById('lineViz');
      const lctx = lineCanvas.getContext('2d');

      function placeLineViz(){
        const isMobile = window.matchMedia("(max-width: 768px)").matches;
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const wrapRect = wrap.getBoundingClientRect();
        const brand = document.getElementById('brand');
        const brandRect = brand.getBoundingClientRect();
        const wrapCS = getComputedStyle(wrap);
        const padL = parseFloat(wrapCS.paddingLeft) || 0;
        const padR = parseFloat(wrapCS.paddingRight) || 0;
        let cssLeft, cssTop, cssWidth, cssHeight;

        if(isMobile){
          // 중앙 정렬 (모바일)
          const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
          const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
          cssWidth = Math.max(240, Math.min(vw * 0.88, brandRect.width)); // 넓게
          cssHeight = Math.max(30, Math.min(56, Math.round(brandRect.height * 0.14)));
          cssLeft = Math.round((vw - cssWidth) / 2);
          cssTop  = Math.round(vh * 0.5 - cssHeight / 2);
        }else{
          // 글자 사이 중앙 (데스크톱)
          const marsLine = document.getElementById('mars')?.parentElement;
          const keysLine = document.getElementById('keys')?.parentElement;
          if(!marsLine || !keysLine) return;
          const marsRect = marsLine.getBoundingClientRect();
          const keysRect = keysLine.getBoundingClientRect();

          const midY = (marsRect.bottom + keysRect.top) / 2;
          const rightLimit = Math.min(keysRect.right, wrapRect.right - padL * 0.25);
          cssLeft = wrapRect.left + padL;
          cssWidth = Math.max(240, rightLimit - cssLeft - padR);
          cssHeight = Math.max(30, Math.min(64, Math.round((marsRect.height + keysRect.height) * 0.14)));
          cssTop = Math.round(midY - cssHeight / 2);
        }

        // 적용
        lineCanvas.style.left = cssLeft + 'px';
        lineCanvas.style.top = cssTop + 'px';
        lineCanvas.style.width = cssWidth + 'px';
        lineCanvas.style.height = cssHeight + 'px';
        lineCanvas.width = Math.floor(cssWidth * dpr);
        lineCanvas.height= Math.floor(cssHeight * dpr);
        lctx.setTransform(dpr,0,0,dpr,0,0);
      }

      function drawLineViz(time){
        const W = lineCanvas.clientWidth|0, H = lineCanvas.clientHeight|0;
        if(W===0||H===0){ return requestAnimationFrame(drawLineViz); }
        lctx.clearRect(0,0,W,H);

        const y0 = H/2;
        // ✨ 각진 스타일
        lctx.lineWidth = Math.max(6, Math.min(10, Math.round(H * 0.26)));
        lctx.lineJoin  = 'miter';
        lctx.miterLimit = 8;
        lctx.lineCap   = 'butt';
        lctx.strokeStyle = '#ffffff';
        lctx.globalAlpha = 0.95;

        // 구성 비율
        const startShift = Math.max(16, W * 0.10);   // ⬅️ 왼쪽 시작점을 더 안쪽에서 시작
        const leftBase   = Math.max(40, W * 0.32);   // 왼쪽 베이스(길게)
        const waveLen    = Math.max(60, W * 0.46);   // 파형 길이
        const rightBase  = Math.max(8,  W - startShift - leftBase - waveLen); // 오른쪽 짧게

        const t = (time||performance.now()) * 0.0009; // 느린 이동
        const period = Math.max(16, W * 0.08);        // 삼각 주기
        const A = H * 0.42;                           // 기본 진폭(뾰족)
        const step = Math.max(2, Math.min(5, Math.round(W / 180)));

        // 삼각파 함수 (각짐)
        function tri(u){
          u = u - Math.floor(u); // [0,1)
          return 1 - 4 * Math.abs(u - 0.5); // [-1,1]
        }
        // ECG 스파이크 위치 (주기적)
        const beatPeriod = W * 0.22;
        const beatPos = (t * beatPeriod * 0.65) % waveLen;
        function spikeMul(x){
          const d = Math.abs(x - beatPos);
          const w = Math.max(4, W * 0.012);
          return 1 + 2.0 * Math.max(0, 1 - d / w); // 폭 좁은 쐐기
        }
        // 엔벌로프: 양끝은 살짝 줄이고 중앙 강조
        function env(u){ // u in [0,1]
          return 0.8 + 0.2 * (1 - Math.abs(2*u - 1));
        }

        lctx.beginPath();
        // 왼쪽 빈 구간 -> 시작점
        lctx.moveTo(startShift, y0);
        // 왼쪽 베이스
        lctx.lineTo(startShift + leftBase, y0);

        // 파형(각진): 삼각 + 고주파 삼각 + 스파이크
        for(let i=0;i<=waveLen;i+=step){
          const x = startShift + leftBase + i;
          const u = (i / period) + t;               // 이동
          const sharp = tri(u);                     // 기본 각진
          const grit  = 0.45 * tri(u*2.7 + 0.13);   // 고주파 각진
          const e = env(i / waveLen) * spikeMul(i); // 엔벌로프 * 스파이크
          const y = y0 - (A * e * (0.72*sharp + 0.28*grit)); // 위쪽도, 아래쪽도 나오게 하려면 부호 섞기
          lctx.lineTo(x, y);
          // 아래로 톱니 한 번 더 (지그재그 강화)
          const y2 = y0 + (A * 0.45 * e * (0.55*sharp - 0.45*grit));
          lctx.lineTo(Math.min(x+step*0.6, startShift + leftBase + waveLen), y2);
        }

        // 오른쪽 짧은 베이스
        lctx.lineTo(startShift + leftBase + waveLen + rightBase, y0);
        lctx.stroke();

        requestAnimationFrame(drawLineViz);
      }

      // 배치 & 리사이즈
      const ro = new ResizeObserver(()=>placeLineViz());
      ro.observe(document.body);
      ro.observe(document.getElementById('brand'));
      window.addEventListener('resize', placeLineViz);
      window.addEventListener('orientationchange', placeLineViz);
      if(document.fonts && document.fonts.ready){ document.fonts.ready.then(placeLineViz); }

      placeLineViz();
      requestAnimationFrame(drawLineViz);
    })();
  </script>
</body>
</html>
