<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mars Keys — Counter to Welcome</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Michroma&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0e1016; 
      --text:#eef2f8; 
      --muted:#9aa3b2;

      --fill-int: 0%;

      --pastel-red-1:#ff8aa1; 
      --pastel-blue-1:#78aaff;
      --pastel-red-2:#ff6b7a; 
      --pastel-blue-2:#5ea1ff;
      --pastel-red-3:#ff9db0; 
      --pastel-blue-3:#b2d1ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow-x:hidden;
      overflow-y:hidden; /* 초기엔 잠금 → 애니 이후 auto */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* ===== Hero ===== */
    .wrap{
      position:relative;
      min-height:100svh; /* iOS 주소창 영향 최소화 */
      padding:5vw;
      overflow:visible; /* descender/파티클 오버플로 허용 */
    }

    /* ===== 브랜드 텍스트 ===== */
    .brand{
      margin:0;
      line-height:1;
      font-family:"Michroma", system-ui, sans-serif;
      position:relative;
      z-index:40;
    }
    .brand-line{
      display:block;
      font-size:clamp(56px, min(14vw, 28vh), 200px);
      line-height:1.06;
      padding-bottom:0.18em;
      overflow:visible;
      position:relative;
    }
    .brand-line + .brand-line{
      margin-top:-0.32em;
    }
    .ink{
      display:inline-block;
      color:transparent;
      -webkit-text-fill-color:transparent;
      -webkit-background-clip:text; background-clip:text;
      background-repeat:no-repeat,no-repeat;
      background-size: var(--fill-int) 100%, 100% 100%;
      background-image: var(--grad), linear-gradient(#fff,#fff);
      letter-spacing:0;
      padding-bottom:0.28em;
      transform: translateZ(0);
    }
    .brand-line:nth-child(1) .ink{ --grad: linear-gradient(180deg,var(--pastel-red-1),var(--pastel-red-2),var(--pastel-red-3)); }
    .brand-line:nth-child(2) .ink{ --grad: linear-gradient(180deg,var(--pastel-blue-1),var(--pastel-blue-2),var(--pastel-blue-3)); }

    .tagline{
      font-size:clamp(16px,2.6vw,28px); font-weight:600; margin:1rem 0 0; color:var(--muted);
    }

    /* ===== 퍼센트 ===== */
    #counter{
      position:absolute; right:5vw; 
      bottom:clamp(16px, 6vh, 48px);
      text-align:right;
      font-size:clamp(28px, min(7vw, 10vh), 96px);
      font-family:"Michroma", system-ui, sans-serif;
      font-weight:900;
      color:white;
      user-select:none;
      pointer-events:none;
      transition:opacity .6s ease;
      z-index:40;
      margin:0;
    }

    /* ===== 파티클 Canvas ===== */
    #particleCanvas{
      position:absolute; inset:0; width:100%; height:100%;
      pointer-events:none; z-index:50;
    }

    /* ===== Welcome ===== */
    #welcome{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%) scale(0.86);
      opacity:0;
      font-size:clamp(48px,10vw,130px);
      font-family:"Michroma", system-ui, sans-serif;
      color:white;
      letter-spacing:0.01em;
      max-width:92vw; white-space:nowrap;
      transition:opacity 1s ease, transform 1s cubic-bezier(.2,.7,.2,1);
      will-change:opacity, transform;
      pointer-events:none;
      z-index:60;
    }
    #welcome.visible{
      opacity:1;
      transform:translate(-50%,-50%) scale(1.22);
    }

    /* ===== 이후 스크롤 콘텐츠 ===== */
    .scrollable-content{
      padding:0 5vw 6rem; 
      text-align:center; 
      display:none;
      max-width:1200px; margin:0 auto;
      position:relative; z-index:10;
    }
    .scrollable-content p{
      max-width:800px; margin:0 auto 1.5rem; line-height:1.8; 
      color:var(--muted); font-size:clamp(14px,2vw,18px);
    }
    .scrollable-content .temp-box{
      background:rgba(255,255,255,0.05); border-radius:12px; padding:2rem; margin:2rem auto; max-width:900px;
    }

    @media (max-width: 768px){
      .brand-line{ line-height:1.08; padding-bottom:0.16em; }
      .brand-line + .brand-line{ margin-top:-0.26em; }
    }
  </style>
</head>
<body>
  <main class="wrap" id="wrap">
    <canvas id="particleCanvas"></canvas>

    <h1 class="brand" id="brand">
      <span class="brand-line" data-c="red"><span class="ink" id="mars">Mars</span></span>
      <span class="brand-line" data-c="blue"><span class="ink" id="keys">Keys</span></span>
    </h1>

    <div id="counter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">0%</div>
    <p class="tagline">Video Game Music Studio</p>

    <div id="welcome">Welcome</div>
  </main>

  <div id="scrollContent" class="scrollable-content">
    <p>게임 음악 스튜디오 Mars Keys에 오신 것을 환영합니다...</p>
    <div class="temp-box"><h3>우리의 서비스</h3><p>게임 OST, SFX, VO, 인터랙티브 음악 시스템...</p></div>
    <div class="temp-box"><h3>포트폴리오</h3><p>RPG, SF 어드벤처 등...</p></div>
    <div class="temp-box"><h3>문의</h3><p>협업 및 프로젝트 문의는 언제든지 환영합니다.</p></div>
    <div style="height:60vh;"></div>
    <div class="temp-box"><p>마지막 임시 콘텐츠</p></div>
  </div>

  <script>
  (function(){
    const html=document.documentElement;
    const body=document.body;
    const wrap=document.getElementById('wrap');
    const counterEl=document.getElementById("counter");
    const welcome=document.getElementById("welcome");
    const scrollContent=document.getElementById("scrollContent");
    const particleCanvas=document.getElementById('particleCanvas');
    const pctx=particleCanvas.getContext('2d');

    // ===== Progress =====
    let p=0;
    const accel=0.0018;
    let autoAnimating=false, isFinalized=false, particlesGenerated=false;

    // ===== Env & palette cache =====
    const IS_MOBILE = window.matchMedia("(max-width: 768px)").matches;
    const CSS = getComputedStyle(document.documentElement);
    const COL_RED  = (CSS.getPropertyValue('--pastel-red-2')  || '#ff6b7a').trim();
    const COL_BLUE = (CSS.getPropertyValue('--pastel-blue-2') || '#5ea1ff').trim();

    // ===== Particles =====
    let particles=[];
    const MAX_PARTICLES = IS_MOBILE ? 2000 : 2600; // 기기별 상한 높임
    const GLOW_THRESHOLD = 100;

    // ===== Taegeuk timeline params =====
    const TAEGUK_DELAY = 2000;   // 터진 뒤 몇 ms 후 태극으로 모을지
    const TAEGUK_HOLD  = 900;    // 태극 모양 유지 시간
    const TAEGUK_SCALE = 0.26;   // 화면 대비 태극 반지름 비율(0~0.5)

    let particlePhase = 'idle';  // 'explode'|'morph'|'hold'|'disperse'|'done'
    let phaseStartTime = 0;

    function resizeParticleCanvas(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = wrap.getBoundingClientRect();
      particleCanvas.width  = Math.floor(rect.width * dpr);
      particleCanvas.height = Math.floor(rect.height * dpr);
      particleCanvas.style.width  = rect.width + 'px';
      particleCanvas.style.height = rect.height + 'px';
      pctx.setTransform(dpr,0,0,dpr,0,0);
      pctx.clearRect(0,0,rect.width,rect.height);
    }

    function setProgress(v){
      p=Math.max(0,Math.min(1,v));
      const pct = Math.round(p*100);
      html.style.setProperty('--fill-int', pct+'%');
      if(!isFinalized){
        counterEl.textContent = pct + "%";
        counterEl.setAttribute('aria-valuenow', String(pct));
      }
      if(p>=1 && !particlesGenerated && !isFinalized){
        generateParticles();
        fadeOutText();
        showWelcome();
        runParticleShow(); // ✨ 타임라인 시작
      }
    }

    function startAutoAnimation(){
      if(autoAnimating||isFinalized) return;
      autoAnimating=true;
      function step(){
        if(p<1){ p = Math.min(1, p+0.005); setProgress(p); requestAnimationFrame(step); }
        else { autoAnimating=false; }
      }
      step();
    }

    function drawTextToCanvas(text, fontSize, fontFamily){
      const offCanvas = document.createElement('canvas');
      const offCtx = offCanvas.getContext('2d');
      offCtx.font = `${fontSize}px ${fontFamily}`;
      const metrics = offCtx.measureText(text);
      const actualHeight = (metrics.actualBoundingBoxAscent||fontSize) + (metrics.actualBoundingBoxDescent||fontSize*0.25);
      const width = Math.ceil(metrics.width);
      offCanvas.width = Math.ceil(width);
      offCanvas.height = Math.ceil(actualHeight);
      offCtx.font = `${fontSize}px ${fontFamily}`;
      offCtx.fillStyle = 'white';
      offCtx.textBaseline = 'top';
      offCtx.fillText(text, 0, 0);
      return { canvas: offCanvas };
    }

    // === 동적 샘플링: 기기/텍스트 크기에 따라 목표 입자 수로 step 산정
    function computeStepForTarget(canvas, target){
      const area = canvas.width * canvas.height; // 대략치(문자 내부만은 아님)
      // 대략 35~50%가 실제 글립이라고 보고 보정값 0.45
      const estGlyphArea = area * 0.45;
      const step = Math.max(4, Math.floor(Math.sqrt(estGlyphArea / Math.max(1, target))));
      return step;
    }

    function generateParticles(){
      particlesGenerated=true; particles.length=0;
      const wrapRect = wrap.getBoundingClientRect();
      const lines = [
        { el: document.getElementById('mars').parentElement, color:'red',  textEl: document.getElementById('mars')  },
        { el: document.getElementById('keys').parentElement, color:'blue', textEl: document.getElementById('keys') }
      ];
      const centerX = wrapRect.width * 0.5;
      const centerY = wrapRect.height * 0.5;

      // 라인별 목표 개수(기기별 균일한 체감 밀도)
      const TARGET_PER_LINE = IS_MOBILE ? 1000 : 1300;

      lines.forEach(({el, color, textEl})=>{
        const rect = el.getBoundingClientRect();
        const style = getComputedStyle(textEl);
        const fontSize = parseFloat(style.fontSize);
        const fontFamily = style.fontFamily;
        const { canvas } = drawTextToCanvas(textEl.textContent, fontSize, fontFamily);
        const ctx = canvas.getContext('2d');
        const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = img.data;

        const STEP = computeStepForTarget(canvas, TARGET_PER_LINE);

        for(let y=0;y<canvas.height;y+=STEP){
          for(let x=0;x<canvas.width;x+=STEP){
            const idx=(y*canvas.width+x)*4;
            if(data[idx+3]>128){
              const px = rect.left - wrapRect.left + x;
              const py = rect.top  - wrapRect.top  + y;

              // 초기 폭발 방향(중심에서 바깥쪽)
              const dx = px - centerX;
              const dy = py - centerY;
              const dist = Math.hypot(dx,dy) + 0.0001;
              const boost = 0.6 + Math.random()*1.1;

              particles.push({
                x: px, y: py,
                vx: (Math.random()-0.5)*0.6 + (dx/dist)*boost,
                vy: (Math.random()-0.5)*0.6 + (dy/dist)*boost,
                alpha: 1,
                color,
                tx: null, ty: null, // 목표(태극)
                reached: false
              });
            }
          }
        }
      });

      // 상한 캡
      if(particles.length > MAX_PARTICLES){
        const sampled=[];
        for(let i=0;i<MAX_PARTICLES;i++){
          sampled.push(particles[(Math.random()*particles.length)|0]);
        }
        particles = sampled;
      }
    }

    function fadeOutText(){
      document.querySelectorAll('.ink').forEach(el=>{
        el.style.transition='opacity .3s ease';
        el.style.opacity='0';
      });
    }

    function showWelcome(){
      setTimeout(()=>{ counterEl.style.opacity=0; }, 350);
      setTimeout(()=>{ welcome.classList.add("visible"); }, 900);
      setTimeout(()=>{
        scrollContent.style.display="block";
        isFinalized=true;  
        body.style.overflowY="auto";
      }, 1500);
    }

    // ===== Taegeuk target builder (analytic classification) =====
    function buildTaegeukTargets(){
      const rect = wrap.getBoundingClientRect();
      const cx = rect.width*0.5, cy = rect.height*0.5;
      const R = Math.min(rect.width, rect.height) * TAEGUK_SCALE; // 반지름

      // 화면 크기에 비례한 샘플 간격(모양 품질/성능 균형)
      const step = Math.max(5, Math.round(Math.min(rect.width, rect.height) / (IS_MOBILE ? 120 : 150)));

      const red = [], blue = [];
      const rSmall = R*0.5, r2 = rSmall*rSmall;

      for(let yy=-R; yy<=R; yy+=step){
        for(let xx=-R; xx<=R; xx+=step){
          const x = xx, y = yy;
          if(x*x + y*y > R*R) continue; // 큰 원 밖이면 패스

          let isRed;
          if(y >= 0){
            // 위쪽: 위 작은 원의 바깥쪽이면 red
            const d2 = x*x + (y - rSmall)*(y - rSmall);
            isRed = d2 >= r2;
          }else{
            // 아래쪽: 아래 작은 원의 안쪽이면 red
            const d2 = x*x + (y + rSmall)*(y + rSmall);
            isRed = d2 <= r2;
          }

          if(isRed) red.push({x: cx + x, y: cy + y});
          else      blue.push({x: cx + x, y: cy + y});
        }
      }

      // 셔플
      function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]];} }
      shuffle(red); shuffle(blue);
      return {red, blue};
    }

    // 강제 색 매칭(반대편으로 안 보냄). 부족하면 반복 할당.
    function assignTaegeukTargets(){
      const { red, blue } = buildTaegeukTargets();
      const redPts  = particles.filter(pt => pt.color === 'red');
      const bluePts = particles.filter(pt => pt.color === 'blue');

      function expandTo(pool, n){
        if (pool.length === 0) return [];
        const out = [];
        for (let i=0;i<n;i++) out.push(pool[i % pool.length]);
        for (let i=out.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [out[i],out[j]]=[out[j],out[i]]; }
        return out;
      }

      const redTargets  = expandTo(red,  redPts.length);
      const blueTargets = expandTo(blue, bluePts.length);

      redPts.forEach((pt,i)=>{ const t = redTargets[i];  pt.tx=t.x;  pt.ty=t.y;  pt.reached=false; });
      bluePts.forEach((pt,i)=>{ const t = blueTargets[i]; pt.tx=t.x; pt.ty=t.y; pt.reached=false; });
    }

    // ===== Particle Show (timeline) =====
    function runParticleShow(){
      particlePhase = 'explode';
      phaseStartTime = performance.now();

      function frame(now){
        const rect = wrap.getBoundingClientRect();
        const W = rect.width, H = rect.height;
        pctx.clearRect(0,0,W,H);

        // phase 전환
        if(particlePhase==='explode' && now - phaseStartTime >= TAEGUK_DELAY){
          assignTaegeukTargets();
          particlePhase = 'morph';
          phaseStartTime = now;
        }else if(particlePhase==='morph'){
          const allReached = particles.every(pt=>pt.reached);
          if(allReached || (now - phaseStartTime) > 1600){
            particlePhase = 'hold';
            phaseStartTime = now;
          }
        }else if(particlePhase==='hold' && now - phaseStartTime >= TAEGUK_HOLD){
          // 재분산 준비
          for(const pt of particles){
            const ang = Math.random()*Math.PI*2;
            const spd = 1.4 + Math.random()*1.8;
            pt.vx = Math.cos(ang)*spd;
            pt.vy = Math.sin(ang)*spd;
            pt.reached=false;
          }
          particlePhase = 'disperse';
          phaseStartTime = now;
        }

        // ===== 물리 업데이트 =====
        let anyAlive = false;
        for(const pt of particles){
          if(pt.alpha<=0) continue;
          anyAlive = true;

          if(particlePhase==='explode'){
            pt.vx *= 0.985; pt.vy *= 0.985;
            pt.vx += (Math.random()-0.5)*0.02;
            pt.vy += (Math.random()-0.5)*0.02;
            pt.alpha = Math.max(0.8, pt.alpha - 0.0006);
          }else if(particlePhase==='morph'){
            if(pt.tx!=null){
              const dx = pt.tx - pt.x;
              const dy = pt.ty - pt.y;
              pt.vx = pt.vx*0.82 + dx*0.06;
              pt.vy = pt.vy*0.82 + dy*0.06;
              if(Math.hypot(dx,dy) < 1.6){
                pt.x = pt.tx; pt.y = pt.ty;
                pt.vx = pt.vy = 0;
                pt.reached = true;
              }
            }
            pt.alpha = Math.min(1, pt.alpha + 0.01);
          }else if(particlePhase==='hold'){
            const t = (now - phaseStartTime)*0.004;
            pt.x += Math.sin(t + (pt.tx||pt.x)*0.01)*0.06;
            pt.y += Math.cos(t + (pt.ty||pt.y)*0.01)*0.06;
            pt.alpha = 1;
          }else if(particlePhase==='disperse'){
            pt.vx *= 1.012; pt.vy *= 1.012;
            pt.alpha -= 0.006;
          }

          pt.x += pt.vx; 
          pt.y += pt.vy;
        }

        if(particlePhase==='disperse' && !anyAlive){
          particlePhase = 'done';
          return;
        }

        // ===== 드로잉(항상 source-over, 2패스) =====
        const aliveCount = particles.filter(pt=>pt.alpha>0).length;
        const useGlow = aliveCount < GLOW_THRESHOLD;

        pctx.globalCompositeOperation = 'source-over';
        pctx.shadowBlur  = useGlow ? 14 : 0;

        function drawPass(colorName, colorHex){
          pctx.shadowColor = useGlow ? (colorHex || '#fff') : 'transparent';
          for(const pt of particles){
            if(pt.alpha<=0 || pt.color!==colorName) continue;
            pctx.globalAlpha = Math.max(0, pt.alpha);
            pctx.fillStyle   = colorHex || '#fff';
            if(useGlow){
              pctx.beginPath(); pctx.arc(pt.x, pt.y, 2.4, 0, Math.PI*2); pctx.fill();
            }else{
              pctx.fillRect(pt.x-1.1, pt.y-1.1, 2.2, 2.2);
            }
          }
        }

        // 색이 섞이지 않도록 순차 렌더
        drawPass('red',  COL_RED);
        drawPass('blue', COL_BLUE);

        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    /* === 입력: 50%까지 수동, 그 뒤 자동 === */
    function onWheel(e){
      if(isFinalized) return;
      e.preventDefault();
      const dy=e.deltaY;
      if(p<0.5){
        setProgress(p+dy*accel);
        if(p>=0.5) startAutoAnimation();
      }else if(!autoAnimating){
        startAutoAnimation();
      }
    }
    function onTouchMove(e){
      if(isFinalized) return;
      const touch=e.touches[0]; 
      const currentY=touch.clientY;
      if(typeof onTouchMove.lastY!=="undefined"){
        const dy=onTouchMove.lastY-currentY;
        if(p<0.5){
          setProgress(p+dy*accel*2);
          if(p>=0.5) startAutoAnimation();
        }else if(!autoAnimating && dy>0){
          startAutoAnimation();
        }
      }
      onTouchMove.lastY=currentY;
    }
    function onTouchEnd(){ if(!isFinalized){ onTouchMove.lastY=undefined; } }

    window.addEventListener('resize', resizeParticleCanvas);
    window.addEventListener('wheel',onWheel,{passive:false});
    window.addEventListener('touchstart',(e)=>{onTouchMove.lastY=e.touches[0].clientY;});
    window.addEventListener('touchmove',onTouchMove,{passive:false});
    window.addEventListener('touchend',onTouchEnd);

    resizeParticleCanvas();
    setProgress(0);
  })();
  </script>
</body>
</html>
