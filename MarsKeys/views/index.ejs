<!DOCTYPE html>
<% const isKorean = (lang || '').toLowerCase().startsWith('ko'); %>
<html lang="<%= lang %>">
  <%- include('partials/head') %>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>
    <% if (isSearch) { %>
      <%= locale.search_results_for %>: <%= searchKeyword %>
    <% } else if (selectedCategory) { %>
      <%= selectedCategory %>
    <% } else { %>
      <%= locale.marskeys_title %>
    <% } %>
  </title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Michroma&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <% if (isKorean) { %>
    <link href="https://fonts.googleapis.com/css2?family=Yeon+Sung&display=swap" rel="stylesheet">
  <% } %>

  <style>
    :root {
      --bg: #0e1016;
      --text: #eef2f8;
      --muted: #9aa3b2;
      --fill-int: 0%;

      /* ✨ 더 진한 은하 텍스처(보라/핑크/파랑 믹스 + 별빛) */
      --galaxy-text:
        radial-gradient(1.4px 1.4px at 8% 12%, rgba(255,255,255,.98), transparent 60%),
        radial-gradient(1.6px 1.6px at 18% 64%, rgba(255,155,230,.95), transparent 60%),
        radial-gradient(1.4px 1.4px at 32% 22%, rgba(150,180,255,.95), transparent 60%),
        radial-gradient(1.2px 1.2px at 44% 78%, rgba(255,225,180,.92),  transparent 60%),
        radial-gradient(1.8px 1.8px at 58% 36%, rgba(205,220,255,.98),  transparent 60%),
        radial-gradient(1.3px 1.3px at 70% 18%, rgba(235,160,255,.95),  transparent 60%),
        radial-gradient(1.5px 1.5px at 80% 70%, rgba(120,160,255,.95),  transparent 60%),
        radial-gradient(1.2px 1.2px at 92% 42%, rgba(255,245,225,.95),  transparent 60%),
        conic-gradient(from 130deg at 50% 50%,
          rgba(130,160,255,.42) 0%,
          rgba(255,120,220,.45) 14%,
          rgba(90,130,255,.44) 28%,
          rgba(255,90,190,.45) 42%,
          rgba(130,170,255,.44) 58%,
          rgba(230,150,255,.45) 72%,
          rgba(210,230,255,.42) 100%);
    }

    * { box-sizing: border-box }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow-x: hidden;
      overflow-y: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body.lang-ko #welcome { font-family: 'Montserrat', 'Michroma', system-ui, sans-serif; font-weight: 400; }

    body.show-background {
      background-image: url('https://images.unsplash.com/photo-1502126428-175f0881ed53?q=80&w=2670&auto=format&fit=crop');
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
      background-attachment: fixed;
      transition: background-image 2s ease;
    }

    .wrap { position: relative; min-height: 100svh; padding: 5vw; overflow: visible; contain: layout paint; }

    .brand { margin: 0; line-height: 1; font-family: "Michroma", system-ui, sans-serif; position: relative; z-index: 40; }

    .brand-line { display: block; font-size: clamp(56px, min(14vw, 28vh), 200px); line-height: 1.06; padding-bottom: 0.18em; overflow: visible; position: relative; will-change: background-position; }
    .brand-line+.brand-line { margin-top: -0.32em; }

    /* 🔤 텍스트 채움(은하) — 기존 채움 애니 유지 */
    .ink{
      display:inline-block; color:transparent; -webkit-text-fill-color:transparent;
      -webkit-background-clip:text; background-clip:text;
      background-repeat:no-repeat,no-repeat;
      background-size:var(--fill-int) 100%, 100% 100%;
      background-image:var(--galaxy-text), linear-gradient(#fff,#fff);
      letter-spacing:0; padding-bottom:.28em; transform:translateZ(0);
      animation: galaxy-pan 30s linear infinite;
      will-change: background-size, opacity;
    }
    @keyframes galaxy-pan {
      0%   { background-position: 0 0, center; }
      50%  { background-position: -2% -1%, center; }
      100% { background-position: 0 0, center; }
    }

    .tagline { font-size: clamp(16px, 2.6vw, 28px); font-weight: 600; margin: 1rem 0 0; color: var(--muted); position: relative; transition: color .55s ease; will-change: color; }
    .tagline.shine-to-white { overflow: visible; }
    .tagline.shine-to-white::before{
      content: attr(data-text); position: absolute; inset: 0; pointer-events: none;
      color: transparent; -webkit-text-fill-color: transparent;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.16) 32%, rgba(255,255,255,.85) 50%, rgba(255,255,255,.16) 68%, rgba(255,255,255,0) 100%);
      -webkit-background-clip: text; background-clip: text;
      transform: translateX(-120%) skewX(-18deg); filter: blur(.3px);
      animation: shine-sweep 900ms cubic-bezier(.2,.7,.2,1) forwards;
    }
    .tagline.to-white { color: #fff; }
    @keyframes shine-sweep { to { transform: translateX(120%) skewX(-18deg); } }

    #counter {
      position: absolute; right: 5vw; bottom: clamp(16px, 6vh, 48px); text-align: right;
      font-size: clamp(28px, min(7vw, 10vh), 96px); font-family: "Michroma", system-ui, sans-serif;
      font-weight: 900; color: white; user-select: none; pointer-events: none; transition: opacity .6s ease; z-index: 40; margin: 0;
    }

    #particleCanvas { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }

    /* 🎸 현 시뮬레이터 */
    #lineViz { position: fixed; pointer-events: auto; z-index: 55; }

    #welcome {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) scale(0.86);
      opacity: 0; font-size: clamp(48px, 10vw, 130px); font-family: 'Montserrat', system-ui, sans-serif; color: white;
      letter-spacing: 0.01em; max-width: 92vw; white-space: nowrap;
      transition: opacity 1s ease, transform 1s cubic-bezier(.2, .7, .2, 1), text-shadow 1s ease-out;
      will-change: opacity, transform, text-shadow; pointer-events: none; z-index: 60; text-shadow: 0 0 0 transparent;
    }
    #welcome.visible { opacity: 1; transform: translate(-50%, -50%) scale(1.22); }
    #welcome.welcome-glow { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.6), 0 0 60px rgba(255, 255, 255, 0.4); }

    .scrollable-content { padding: 0 5vw 6rem; text-align: center; display: none; max-width: 1200px; margin: 0 auto; position: relative; z-index: 10; }
    .scrollable-content p { max-width: 800px; margin: 0 auto 1.5rem; line-height: 1.8; color: var(--muted); font-size: clamp(14px, 2vw, 18px); }
    .scrollable-content .temp-box { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 2rem; margin: 2rem auto; max-width: 900px; }

    @media (max-width: 768px) {
      .brand-line { line-height: 1.08; padding-bottom: 0.16em; }
      .brand-line+.brand-line { margin-top: -0.26em; }
    }
  </style>
</head>

<body class="<%= isKorean ? 'lang-ko' : '' %>">
  <main class="wrap" id="wrap">
    <canvas id="particleCanvas"></canvas>
    <canvas id="lineViz"></canvas>

    <h1 class="brand" id="brand">
      <span class="brand-line" data-c="red"><span class="ink" id="mars"><%= locale.mars_keys.split(' ')[0] %></span></span>
      <span class="brand-line" data-c="blue"><span class="ink" id="keys"><%= locale.mars_keys.split(' ')[1] %></span></span>
    </h1>

    <p class="tagline shine-to-white" data-text="<%= locale.game_music_studio %>"><%= locale.game_music_studio %></p>

    <div id="counter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">0%</div>
    <div id="welcome"><%= locale.welcome %></div>
  </main>

  <div id="scrollContent" class="scrollable-content">
    <p><%= locale.game_music_studio %> <%= locale.marskeys_title %>에 오신 것을 환영합니다...</p>
    <div class="temp-box">
      <h3>우리의 서비스</h3>
      <p>게임 OST, SFX, VO, 인터랙티브 음악 시스템...</p>
    </div>
    <div class="temp-box">
      <h3>포트폴리오</h3>
      <p>RPG, SF 어드벤처 등...</p>
    </div>
    <div class="temp-box">
      <h3>문의</h3>
      <p>협업 및 프로젝트 문의는 언제든지 환영합니다.</p>
    </div>
    <div style="height:60vh;"></div>
    <div class="temp-box">
      <p>마지막 임시 콘텐츠</p>
    </div>
  </div>

  <script>
    (function() {
      const html = document.documentElement;
      const body = document.body;
      const wrap = document.getElementById('wrap');
      const counterEl = document.getElementById("counter");
      const welcome = document.getElementById("welcome");
      const scrollContent = document.getElementById("scrollContent");
      const particleCanvas = document.getElementById('particleCanvas');
      const pctx = particleCanvas.getContext('2d', { alpha: true, desynchronized: true });

      const tagline = document.querySelector('.tagline');
      tagline.addEventListener('animationend', (event) => {
        if (event.animationName === 'shine-sweep') tagline.classList.add('to-white');
      });

      // ===== Progress =====
      let p = 0;
      let autoAnimating = false,
          isFinalized = false,
          particlesGenerated = false;

      const VANISH_START = 0.5;
      const IS_MOBILE = window.matchMedia("(max-width: 768px)").matches;

      // ===== Particles =====
      let particles = [];
      const MAX_PARTICLES = 1000; // 수 유지(이미 적음)
      let particlePhase = 'idle';
      let phaseStartTime = 0;

      // 🔧 스프라이트(그림자/블러 없이 글로우 느낌 대체)
      const COLOR_LIST = [
        'rgba(255,255,255,1.0)',     // 0 white
        'rgba(120,160,255,1.0)',     // 1 blue
        'rgba(235,160,255,1.0)',     // 2 violet
        'rgba(255,120,220,1.0)'      // 3 hot pink
      ];
      const SPRITES = createSprites(COLOR_LIST);

      function createSprites(colors){
        const map = {};
        colors.forEach((c, i) => {
          const s = 64;
          const cvs = document.createElement('canvas');
          cvs.width = s; cvs.height = s;
          const ctx = cvs.getContext('2d');
          const g = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
          // 중심 밝고 바깥 희미
          g.addColorStop(0.0, c.replace('1.0','0.95'));
          g.addColorStop(0.3, c.replace('1.0','0.65'));
          g.addColorStop(0.7, c.replace('1.0','0.18'));
          g.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(s/2, s/2, s/2, 0, Math.PI*2);
          ctx.fill();
          map[i] = cvs;
        });
        return map;
      }

      function resizeParticleCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = wrap.getBoundingClientRect();
        particleCanvas.width = Math.floor(rect.width * dpr);
        particleCanvas.height = Math.floor(rect.height * dpr);
        particleCanvas.style.width = rect.width + 'px';
        particleCanvas.style.height = rect.height + 'px';
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.clearRect(0, 0, rect.width, rect.height);
      }

      function setProgress(v) {
        p = Math.max(0, Math.min(1, v));
        const pct = Math.round(p * 100);
        html.style.setProperty('--fill-int', pct + '%');
        if (!isFinalized) {
          counterEl.textContent = pct + "%";
          counterEl.setAttribute('aria-valuenow', String(pct));
        }
        // 💡 파티클 시드(글리프 샘플) 사전 계산 트리거
        if (!glyphSeedsReady && p > 0.32) prepareGlyphSeeds();

        if (p >= 1 && !particlesGenerated && !isFinalized) {
          generateParticlesFromSeeds();  // 사전 계산 덕분에 즉시
          fadeOutText();
          showWelcome();
          runParticleShow();
        }
      }

      function startAutoAnimation() {
        if (autoAnimating || isFinalized) return;
        autoAnimating = true;
        function step() {
          if (p < 1) {
            p = Math.min(1, p + 0.005);
            setProgress(p);
            requestAnimationFrame(step);
          } else autoAnimating = false;
        }
        step();
      }

      // ---------- 글리프 시드 사전 계산 ----------
      let glyphSeedsReady = false;
      let seedPoints = []; // {x, y} 배열(랩 기준 좌표)
      let lastGlyphForLayout = { left: 0, top: 0, width: 0, height: 0 };

      function drawTextToCanvas(text, fontSize, fontFamily, width, height) {
        const off = document.createElement('canvas');
        off.width = Math.ceil(width);
        off.height = Math.ceil(height);
        const ctx = off.getContext('2d');
        ctx.font = `${fontSize}px ${fontFamily}`;
        ctx.fillStyle = 'white';
        ctx.textBaseline = 'middle';
        // 중앙 배치(좌측정렬로 모양 샘플은 충분)
        const y = off.height / 2;
        ctx.fillText(text, 0, y);
        return off;
      }

      function computeStepForTarget(canvasW, canvasH) {
        const area = canvasW * canvasH;
        const target = IS_MOBILE ? 600 : 300; // 밀도 유지(수는 줄이지 않음)
        const estGlyphArea = area * 0.45;
        const step = Math.max(5, Math.floor(Math.sqrt(estGlyphArea / Math.max(1, target))));
        return step;
      }

      async function prepareGlyphSeeds() {
        if (glyphSeedsReady) return;
        // 폰트 로드 보장
        try { if (document.fonts && document.fonts.ready) await document.fonts.ready; } catch(e){}
        seedPoints.length = 0;

        const wrapRect = wrap.getBoundingClientRect();
        const lines = [
          { el: document.getElementById('mars').parentElement, textEl: document.getElementById('mars') },
          { el: document.getElementById('keys').parentElement, textEl: document.getElementById('keys') }
        ];

        lines.forEach(({ el, textEl }) => {
          if (!el || !textEl) return;
          const rect = el.getBoundingClientRect();
          const style = getComputedStyle(textEl);
          const fontSize = parseFloat(style.fontSize);
          const fontFamily = style.fontFamily;

          const canvas = drawTextToCanvas(textEl.textContent, fontSize, fontFamily, rect.width, rect.height);
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = img.data;

          const STEP = computeStepForTarget(canvas.width, canvas.height);

          for (let y = 0; y < canvas.height; y += STEP) {
            for (let x = 0; x < canvas.width; x += STEP) {
              const idx = (y * canvas.width + x) * 4;
              if (data[idx + 3] > 128) {
                const px = rect.left - wrapRect.left + x;
                const py = rect.top - wrapRect.top + y;
                seedPoints.push({ x: px, y: py });
              }
            }
          }
        });

        // 너무 많으면 표본추출(총량 유지감)
        if (seedPoints.length > MAX_PARTICLES) {
          const sampled = [];
          for (let i = 0; i < MAX_PARTICLES; i++) {
            sampled.push(seedPoints[(Math.random() * seedPoints.length) | 0]);
          }
          seedPoints = sampled;
        }

        // 레이아웃 기준 저장(리사이즈 시 스케일 보정용)
        lastGlyphForLayout = { 
          left: wrapRect.left, top: wrapRect.top, 
          width: wrapRect.width, height: wrapRect.height 
        };
        glyphSeedsReady = true;
      }

      function pickColorKey(){
        const r = Math.random();
        if (r < 0.25) return 0; // white
        if (r < 0.50) return 1; // blue
        if (r < 0.75) return 2; // violet
        return 3;              // hot pink
      }

      function generateParticlesFromSeeds() {
        particlesGenerated = true;
        particles.length = 0;

        const wrapRect = wrap.getBoundingClientRect();
        const sx = wrapRect.width / Math.max(1, lastGlyphForLayout.width);
        const sy = wrapRect.height / Math.max(1, lastGlyphForLayout.height);

        // 객체 풀 느낌의 가벼운 생성
        for (let i = 0; i < seedPoints.length; i++) {
          const s = seedPoints[i];
          const px = (s.x - lastGlyphForLayout.left) * sx;
          const py = (s.y - lastGlyphForLayout.top) * sy;

          // 큰 파티클 확률 낮춤(스프라이트라 부담 적지만 그래도 살짝)
          let targetSize = 1.4 + Math.random() * 3.2;
          if (Math.random() < 0.02) { // 2%만 크게
            targetSize = 8 + Math.random() * 6;
          }

          const spd = 0.35 + Math.random() * 0.4;
          const ang = Math.random() * Math.PI * 2;
          particles.push({
            x: px, y: py,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd,
            alpha: 1,
            colorKey: pickColorKey(),
            currentSize: 0,
            targetSize,
            sizeGrowthRate: 0.12 + Math.random() * 0.08, // 스프라이트라 빠르게 커져도 부담 적음
            tw: 0.5 + Math.random() * 0.8,
            twPhase: Math.random() * Math.PI * 2
          });
        }
      }

      function fadeOutText() {
        document.querySelectorAll('.ink').forEach(el => {
          el.style.transition = 'opacity .25s ease';
          el.style.opacity = '0';
        });
      }

      function showWelcome() {
        // 카운터 먼저 페이드
        setTimeout(() => { counterEl.style.opacity = 0; }, 250);
        // 스크롤 컨텐츠 공개 + 오버플로우 복구
        setTimeout(() => { scrollContent.style.display = "block"; isFinalized = true; body.style.overflowY = "auto"; }, 1200);
        // 웰컴 등장
        setTimeout(() => { welcome.classList.add("visible"); welcome.classList.add("welcome-glow"); }, 1600);
      }

      // ===== 파티클 쇼: break -> float(부유) =====
      function runParticleShow() {
        particlePhase = 'break';
        phaseStartTime = performance.now();

        function frame(now) {
          const rect = wrap.getBoundingClientRect();
          const W = rect.width, H = rect.height;
          pctx.clearRect(0, 0, W, H);

          const phaseDuration = 1200;
          if (particlePhase === 'break' && now - phaseStartTime >= phaseDuration) {
            for (const pt of particles) {
              pt.vx *= 0.18 + Math.random() * 0.1;
              pt.vy *= 0.18 + Math.random() * 0.1;
            }
            particlePhase = 'float';
            phaseStartTime = now;
          }

          // 업데이트
          for (const pt of particles) {
            // 크기 이징
            if (pt.currentSize < pt.targetSize) {
              pt.currentSize += (pt.targetSize - pt.currentSize) * pt.sizeGrowthRate;
              if (pt.currentSize > pt.targetSize) pt.currentSize = pt.targetSize;
            }

            if (particlePhase === 'break') {
              pt.vx *= 0.97; pt.vy *= 0.97;
              pt.vx += (Math.random() - 0.5) * 0.03;
              pt.vy += (Math.random() - 0.5) * 0.03;
            } else {
              pt.vx += (Math.random() - 0.5) * 0.006;
              pt.vy += (Math.random() - 0.5) * 0.006;

              const maxV = 0.22;
              const sp = Math.hypot(pt.vx, pt.vy);
              if (sp > maxV) { pt.vx = (pt.vx / sp) * maxV; pt.vy = (pt.vy / sp) * maxV; }
              pt.alpha *= 0.9995;
            }

            pt.x += pt.vx; pt.y += pt.vy;

            const m = 24;
            if (pt.x < -m) pt.x = W + m;
            if (pt.x > W + m) pt.x = -m;
            if (pt.y < -m) pt.y = H + m;
            if (pt.y > H + m) pt.y = -m;
          }

          // 드로잉: 스프라이트로 가볍게 + 일부만 트윙클 강조
          pctx.globalCompositeOperation = 'lighter';

          const twinkleN = 120; // 강조 스파클 개수(적당히)
          // 기본 레이어
          for (let i = 0; i < particles.length; i++) {
            const pt = particles[i];
            if (pt.alpha <= 0.02) continue;
            const s = pt.currentSize;
            const spr = SPRITES[pt.colorKey];
            pctx.globalAlpha = Math.max(0, Math.min(1, pt.alpha * 0.9));
            const d = s * 2;
            pctx.drawImage(spr, pt.x - s, pt.y - s, d, d);
          }
          // 트윙클(가벼운 알파 변조만)
          for (let k = 0; k < twinkleN && k < particles.length; k++) {
            const i = (Math.random() * particles.length) | 0;
            const pt = particles[i];
            const tw = 0.85 + 0.15 * Math.sin(now * 0.006 * pt.tw + pt.twPhase);
            const s = pt.currentSize * (1 + 0.08 * tw);
            const spr = SPRITES[pt.colorKey];
            pctx.globalAlpha = Math.max(0, Math.min(1, pt.alpha * tw));
            const d = s * 2;
            pctx.drawImage(spr, pt.x - s, pt.y - s, d, d);
          }

          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      // -------- 입력/프로그레스 ----------
      function onWheel(e) {
        if (isFinalized) return;
        e.preventDefault();
        const dy = e.deltaY;
        if (p < 0.5) { setProgress(p + dy * 0.0018); startAutoAnimation(); }
        else if (!autoAnimating) { startAutoAnimation(); }
      }
      function onTouchMove(e) {
        if (isFinalized) return;
        const touch = e.touches[0]; const currentY = touch.clientY;
        if (typeof onTouchMove.lastY !== "undefined") {
          const dy = onTouchMove.lastY - currentY;
          if (p < 0.5) { setProgress(p + dy * 0.0018 * 2); if (p >= 0.5) startAutoAnimation(); }
          else if (!autoAnimating && dy > 0) { startAutoAnimation(); }
        }
        onTouchMove.lastY = currentY;
      }
      function onTouchEnd() { if (!isFinalized) onTouchMove.lastY = undefined; }

      window.addEventListener('resize', resizeParticleCanvas, { passive: true });
      window.addEventListener('wheel', onWheel, { passive: false });
      window.addEventListener('touchstart', (e) => { onTouchMove.lastY = e.touches[0].clientY; }, { passive: true });
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', onTouchEnd, { passive: true });

      resizeParticleCanvas();
      setProgress(0);

      /* ============================================================
         🎸 현 시뮬레이터 (신호선) — 그대로 유지
         ============================================================ */
      const lineCanvas = document.getElementById('lineViz');
      const lctx = lineCanvas.getContext('2d');

      const LINE_THICK = 8;
      const LINE_H_DESKTOP = 72;
      const LINE_H_MOBILE  = 96;
      const V_PAD_VH = 18;

      let tension    = 0.8;
      let loss       = 0.986;
      let SUBSTEPS   = 10;
      let radiusPx   = 80;
      const K_MOUSE  = 1.5;
      const C_MOUSE  = 0.08;
      const HARD_FACTOR = 0.4;
      const RELEASE_KICK = 0.25;

      let numPoints = 240;
      let dx = 1, invDX2 = 1;
      let initialY = 0;
      let string = [];
      let MAX_PULL = 0;

      class StringPoint { constructor(x, y){ this.x=x; this.y=y; this.oldY=y; this.acc=0; } }

      let vanishBaseWidth = null, vanishBaseLeft = null;

      function placeLineViz() {
        const Wwin = window.innerWidth;
        const Hwin = window.innerHeight;
        const isMobile = window.matchMedia("(max-width: 768px)").matches;

        if (isMobile) {
          const desiredWidth = Math.round(Wwin * 0.9);
          const midY   = Math.round(Hwin / 2);
          const cssHeightBase = LINE_H_MOBILE;
          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = cssHeightBase + padPx * 2;
          const left = Math.round((Wwin - desiredWidth) / 2);

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = desiredWidth + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(desiredWidth  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(desiredWidth, cssHeight);
          if (vanishBaseWidth === null) {
            vanishBaseWidth = desiredWidth;
            vanishBaseLeft  = left;
          }
        } else {
          const marsLine = document.getElementById('mars')?.parentElement || null;
          const keysLine = document.getElementById('keys')?.parentElement || null;
          let left   = Math.round(Wwin * 0.2);
          let width  = Math.round(Wwin * 0.6);
          let midY   = Math.round(Hwin / 2);
          try {
            if (marsLine && keysLine) {
              const wrapRect = wrap.getBoundingClientRect();
              const wrapCS = getComputedStyle(wrap);
              const padLeft = parseFloat(wrapCS.paddingLeft) || 0;
              const additionalPadding = 250;

              left = Math.round(wrapRect.left + padLeft + additionalPadding);
              const rightLimit = Math.min(keysLine.getBoundingClientRect().right, wrapRect.right - padLeft * 0.25);
              width = Math.max(260, Math.round(rightLimit - left));

              const marsBottom = marsLine.getBoundingClientRect().bottom;
              const keysTop = keysLine.getBoundingClientRect().top;
              midY = Math.round((marsBottom + keysTop) / 2);
            }
          } catch(e) { /* fallback */ }

          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = LINE_H_DESKTOP + padPx * 2;
          width = Math.min(width, Wwin);
          left  = Math.max(0, Math.min(left, Wwin - width));

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = width + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(width  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(width, cssHeight);
          if (vanishBaseWidth === null) {
            vanishBaseWidth = width;
            vanishBaseLeft  = left;
          }
        }
      }

      function setupString(W, H){
        numPoints = Math.max(160, Math.min(360, Math.round(W / 4)));
        string = [];
        for (let i=0;i<numPoints;i++){
          const x = (i/(numPoints-1)) * W;
          string.push(new StringPoint(x, H/2));
        }
        initialY = H/2;
        dx = W / (numPoints - 1);
        invDX2 = 1 / (dx*dx);
      }

      const mouse = { active:false, x:0, y:0 };
      function getPos(e){
        const r = lineCanvas.getBoundingClientRect();
        const cx = (e.clientX??e.touches?.[0].clientX) - r.left;
        const cy = (e.clientY??e.touches?.[0].clientY) - r.top;
        return {x:cx, y:cy};
      }

      lineCanvas.addEventListener('mousedown', e=>{
        const {x,y} = getPos(e); mouse.active = true; mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mousemove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mouseup', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      lineCanvas.addEventListener('touchstart', e=>{
        const {x,y} = getPos(e); e.preventDefault(); mouse.active = true; mouse.x = x; mouse.y = y;
      }, {passive:false});
      lineCanvas.addEventListener('touchmove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); e.preventDefault(); mouse.x = x; mouse.y = y;
      }, {passive:false});
      window.addEventListener('touchend', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      function hannWeight(dist, R){
        if (dist >= R) return 0;
        const r = dist / R;
        return 0.5 * (1 + Math.cos(Math.PI * r));
      }

      function applyMouseForce(){
        if (!mouse.active) return;

        let pullY = mouse.y - initialY;
        if (Math.abs(pullY) > MAX_PULL) {
          pullY = Math.sign(pullY) * MAX_PULL;
        }

        const FcapBase = 12;
        const Fcap = FcapBase / (1 + HARD_FACTOR * tension);

        for (let i = 1; i < numPoints - 1; i++) {
          const p = string[i];
          const distX = Math.abs(p.x - mouse.x);
          const w = hannWeight(distX, radiusPx);
          if (w <= 0) continue;

          const vel = p.y - p.oldY;
          const Fspring = K_MOUSE * (initialY + pullY - p.y);
          const Fdamp   = -C_MOUSE * vel;
          let F = (Fspring + Fdamp) * w;

          if (F >  Fcap * w) F =  Fcap * w;
          if (F < -Fcap * w) F = -Fcap * w;

          p.acc += F;
        }
      }

      function physicsStep(){
        for (let i=1;i<numPoints-1;i++){
          const prev = string[i-1].y, curr = string[i].y, next = string[i+1].y;
          const lap = (prev - 2*curr + next) * invDX2;
          string[i].acc = tension * lap;
        }
        applyMouseForce();

        string[0].acc = 0; string[numPoints-1].acc = 0;

        for (let i=1;i<numPoints-1;i++){
          const p = string[i];
          const tempY = p.y;
          p.y = p.y*2 - p.oldY + p.acc;
          p.oldY = tempY;
          p.y = initialY + (p.y - initialY) * loss;
        }
        string[0].y = string[0].oldY = initialY;
        string[numPoints-1].y = string[numPoints-1].oldY = initialY;
      }

      function drawString(){
        const rect = lineCanvas.getBoundingClientRect();
        const Wdraw = Math.max(0, Math.round(rect.width));
        const Hdraw = Math.max(0, Math.round(rect.height));
        if (!Wdraw || !Hdraw) return;

        lctx.clearRect(0,0,Wdraw,Hdraw);

        const smoothstep = (x) => x < 0 ? 0 : x > 1 ? 1 : x * x * (3 - 2 * x);
        const f = (p < VANISH_START) ? 0 : smoothstep((p - VANISH_START) / (1 - VANISH_START));
        const thickness = Math.max(0.6, LINE_THICK * (1 - 0.9 * f));
        lctx.globalAlpha = 1 - f;

        lctx.beginPath();
        lctx.strokeStyle = '#ffffff';
        lctx.lineWidth = thickness;
        lctx.lineCap = 'round';
        lctx.lineJoin = 'round';

        const baseW = (vanishBaseWidth || Wdraw);
        const baseC = baseW / 2;
        const scaleX = Wdraw / baseW;
        const mapX = x => baseC + (x - baseC) * scaleX;

        lctx.moveTo(mapX(string[0].x), string[0].y);
        for (let i=1;i<numPoints-2;i++){
          const xc = mapX((string[i].x + string[i+1].x)/2);
          const yc = (string[i].y + string[i+1].y)/2;
          lctx.quadraticCurveTo(mapX(string[i].x), string[i].y, xc, yc);
        }
        lctx.quadraticCurveTo(mapX(string[numPoints-2].x), string[numPoints-2].y, mapX(string[numPoints-1].x), string[numPoints-1].y);
        lctx.stroke();

        lctx.globalAlpha = 1;
      }

      function animateString(){
        for (let s=0; s<SUBSTEPS; s++) physicsStep();
        drawString();
        if(!isFinalized) requestAnimationFrame(animateString);
      }

      const ro = new ResizeObserver(() => { placeLineViz(); /* 리사이즈 시 파티클 캔버스만 갱신 */ resizeParticleCanvas(); });
      ro.observe(document.body);
      ro.observe(document.getElementById('brand'));
      window.addEventListener('resize', placeLineViz, { passive: true });
      window.addEventListener('orientationchange', placeLineViz, { passive: true });
      if (document.fonts && document.fonts.ready) { document.fonts.ready.then(placeLineViz); }

      placeLineViz();
      requestAnimationFrame(animateString);
    })();
  </script>
</body>
</html>
