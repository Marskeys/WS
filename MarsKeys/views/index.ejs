<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mars Keys — Counter to Welcome</title>
  <style>
    :root{
      --bg:#0e1016; 
      --text:#eef2f8; 
      --muted:#9aa3b2;
      --fill:0%;
      --pastel-red-1:#ff8aa1; --pastel-blue-1:#78aaff;
      --pastel-red-2:#ff6b7a; --pastel-red-3:#ff9db0;
      --pastel-blue-2:#5ea1ff; --pastel-blue-3:#b2d1ff;
    }
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:sans-serif;
      overflow-x:hidden;
      overflow-y:hidden; /* 초기엔 스크롤 잠금 */
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* ===== Hero ===== */
    .wrap{
      position:relative;
      min-height:100vh; 
      display:flex; 
      flex-direction:column; 
      align-items:stretch;
      padding:5vw;
      overflow:visible;
    }
    .brand{margin:0; font-weight:900; line-height:.9;}
    .brand-line{position:relative; display:block; font-size:clamp(56px,14vw,200px);}
    .plain{position:relative; z-index:1;}
    .fill{position:absolute; inset:0; width:var(--fill); overflow:hidden; z-index:2;}
    .fill > span{display:block; color:transparent; -webkit-background-clip:text; background-clip:text;}
    .brand-line[data-c="red"] .fill > span{background-image:linear-gradient(180deg,var(--pastel-red-1),var(--pastel-red-2),var(--pastel-red-3));}
    .brand-line[data-c="blue"] .fill > span{background-image:linear-gradient(180deg,var(--pastel-blue-1),var(--pastel-blue-2),var(--pastel-blue-3));}
    .tagline{font-size:clamp(16px,2.6vw,28px); font-weight:600; margin-top:1rem;}

    /* 텍스트는 폭발 직전에만 숨김 (캔버스가 takeover) */
    .brand-line .plain, .brand-line .fill{
      transition: opacity .15s linear;
    }

    /* ===== overlay canvas (글자 픽셀 캡처) ===== */
    .text-overlay{
      position:absolute; inset:0; 
      z-index:3;           /* 텍스트 위 */
      pointer-events:none;
    }

    /* ===== Particles (우주 부유 + 글로우) ===== */
    .particles{
      position:absolute; inset:0; pointer-events:none; overflow:visible;
      mix-blend-mode:screen;
      z-index:4;           /* overlay 위 (진짜로 분해되는 느낌) */
      transform: translateZ(0);
    }
    .particle{
      position:absolute; 
      left:0; top:0;
      width:2px; height:2px; border-radius:50%;
      background: radial-gradient(circle at center, #fff 0 28%, var(--c, #ffffff) 45%, rgba(0,0,0,0) 70%);
      box-shadow:
        0 0 6px var(--c, #ffffff),
        0 0 14px var(--c, #ffffff),
        0 0 24px rgba(255,255,255,0.35);
      opacity:0;
      will-change: transform, opacity, filter;
      transform: translate3d(0,0,0) scale(1);
      animation: twinkle 2.6s ease-in-out infinite;
      animation-delay: var(--twinkle-delay, 0s);
      filter: blur(.2px);
    }
    @keyframes twinkle{
      0%,100%{ filter: blur(.2px) brightness(1); }
      50%   { filter: blur(.2px) brightness(1.35); }
    }

    /* ===== 퍼센트 카운터 ===== */
    #counter{
      position:fixed;
      top:50%; right:5%;
      transform:translateY(-50%);
      font-size:clamp(40px,10vw,120px);
      font-weight:900;
      color:white;
      text-shadow:0 0 10px rgba(255,255,255,0.5);
      user-select:none;
      pointer-events:none;
      transition:opacity .5s ease;
      z-index:100;
    }

    /* ===== Welcome ===== */
    .welcome-wrap{
      position: relative;
      width: 100%;
      height: 100vh;
      min-height:0;
    }
    #welcome{
      position:absolute; 
      top:10%; left:50%;
      transform:translate(-50%, -50%) scale(0.8);
      opacity:0;
      font-size:clamp(60px,12vw,180px);
      font-weight:900;
      color:white;
      text-align:center;
      letter-spacing:0.02em;
      pointer-events:none;
      transition:opacity 1s ease, transform 1s cubic-bezier(.2,.7,.2,1);
      will-change: opacity, transform;
      z-index:0;
      text-shadow: 0 0 18px rgba(255,255,255,0.25);
    }
    #welcome.visible{
      opacity:1;
      transform:translate(-50%, -50%) scale(1.45);
      z-index:10;
    }

    /* ===== 이후 스크롤 콘텐츠 ===== */
    .scrollable-content{
      padding:0 5vw; 
      text-align:center; 
      position:relative; 
      display:none;
    }
    .scrollable-content p{
      max-width:800px; margin:0 auto 1.5rem; line-height:1.8; 
      color:var(--muted); font-size:clamp(14px,2vw,18px);
    }
    .scrollable-content .temp-box{
      background:rgba(255,255,255,0.05); border-radius:12px; padding:2rem; margin-bottom:2rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      backdrop-filter: blur(2px);
    }
  </style>
</head>
<body>
  <img src="/assets/images/glow-circuit-bg.webp" style="display:none" alt="preload background" />

  <main class="wrap">
    <canvas id="textCanvas" style="display:none;"></canvas>

    <h1 class="brand">
      <span class="brand-line" data-c="red">
        <span class="plain">Mars</span>
        <span class="fill"><span>Mars</span></span>
        <canvas class="text-overlay"></canvas>
        <div class="particles"></div>
      </span>
      <span class="brand-line" data-c="blue">
        <span class="plain">Keys</span>
        <span class="fill"><span>Keys</span></span>
        <canvas class="text-overlay"></canvas>
        <div class="particles"></div>
      </span>
    </h1>
    <p class="tagline">Video Game Music Studio</p>

    <div class="welcome-wrap" aria-hidden="true">
      <div id="welcome">Welcome</div>
    </div>
  </main>
  
  <div id="counter">0%</div>

  <div id="scrollContent" class="scrollable-content">
    <p>게임 음악 스튜디오 Mars Keys에 오신 것을 환영합니다...</p>
    <div class="temp-box"><h3>우리의 서비스</h3><p>게임 OST, SFX, VO, 인터랙티브 음악 시스템...</p></div>
    <div class="temp-box"><h3>포트폴리오</h3><p>RPG, SF 어드벤처 등...</p></div>
    <div class="temp-box"><h3>문의</h3><p>협업 및 프로젝트 문의는 언제든지 환영합니다.</p></div>
    <div style="height:100vh;"></div>
    <div class="temp-box"><p>마지막 임시 콘텐츠</p></div>
  </div>

  <script>
  (function(){
    const html=document.documentElement;
    const body=document.body;
    const counterEl=document.getElementById("counter");
    const welcome=document.getElementById("welcome");
    const scrollContent=document.getElementById("scrollContent");

    // ===== 파라미터 =====
    const DENSITY   = 6;        // 샘플 간격(px)
    const BUDGET    = 140;      // 프레임당 스폰 수
    const SPEED_MIN = 0.08;     // 기본 확산 속도
    const SPEED_RND = 0.12;     // 랜덤 추가 속도
    const FRICTION  = 0.985;    // 감쇠
    const SWIRL_AMP = 0.018;    // 소용돌이
    const DRIFT_AMP = 0.06;     // 우주 바람

    const STICK_DUR = 280;      // 초반 글자형 유지
    const RAMP_DUR  = 650;      // 이동량 0→1

    let p=0, accel=0.0018;
    let particles=[], spawners=[], particlesGenerated=false;
    let autoAnimating=false, isFinalized=false;

    function setProgress(v){
      p=Math.max(0,Math.min(1,v));
      html.style.setProperty('--fill',(p*100).toFixed(2)+'%');
      if(!isFinalized){counterEl.textContent=Math.floor(p*100)+"%";}
      if(p>=1 && !particlesGenerated && !isFinalized){
        (document.fonts?.ready || Promise.resolve()).then(()=>{
          snapshotToCanvas();  // ★ 글자를 overlay canvas에 그대로 복제
          generateParticles(); // ★ 그 캔버스 픽셀에서 파티클 뽑음
          explodeFromCanvas(); // ★ 캔버스 픽셀을 지워가며 분해
          showWelcome();
        });
      }
    }

    function startAutoAnimation(){
      if(autoAnimating||isFinalized) return;
      autoAnimating=true;
      function step(){
        if(p<1){p+=0.005; setProgress(p); requestAnimationFrame(step);}
        else{p=1; setProgress(1); autoAnimating=false;}
      } 
      step();
    }

    // ===== 유틸 =====
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const smoothstep = (e0,e1,x)=>{
      const t = Math.max(0, Math.min(1, (x-e0)/(e1-e0)));
      return t*t*(3-2*t);
    };
    const getVar = (name)=>getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    const colorStops = {
      red:  [getVar('--pastel-red-1')||'#ff8aa1', getVar('--pastel-red-2')||'#ff6b7a', getVar('--pastel-red-3')||'#ff9db0'],
      blue: [getVar('--pastel-blue-1')||'#78aaff', getVar('--pastel-blue-2')||'#5ea1ff', getVar('--pastel-blue-3')||'#b2d1ff']
    };
    const colorMain = (c)=> c==='red' ? getVar('--pastel-red-1')||'#ff8aa1' : getVar('--pastel-blue-1')||'#78aaff';

    // === 1) 글자를 overlay canvas에 그려서 "같은 픽셀" 확보
    function snapshotToCanvas(){
      document.querySelectorAll('.brand-line').forEach(line=>{
        const plain = line.querySelector('.plain');
        const text  = plain?.textContent || '';
        const style = getComputedStyle(plain);
        const fontSize = parseInt(style.fontSize)||120;
        const fontFamily= style.fontFamily || 'sans-serif';
        const w = Math.max(2, line.offsetWidth);
        const h = Math.max(2, line.offsetHeight);

        const cvs = line.querySelector('.text-overlay');
        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        cvs.width  = w * dpr;
        cvs.height = h * dpr;
        cvs.style.width = w+'px';
        cvs.style.height= h+'px';

        const ctx = cvs.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.clearRect(0,0,w,h);

        // gradient 채워진 텍스트로 동일하게 렌더
        ctx.font = `900 ${fontSize}px ${fontFamily}`;
        ctx.textBaseline='middle';
        ctx.textAlign='left';

        const ckey = line.dataset.c === 'red' ? 'red' : 'blue';
        const g = ctx.createLinearGradient(0,0,0,h);
        const [c1,c2,c3] = colorStops[ckey];
        g.addColorStop(0,   c1);
        g.addColorStop(0.5, c2);
        g.addColorStop(1,   c3);
        ctx.fillStyle = g;

        // DOM과 맞추기 위해 h/2에 그린다(기존 코드와 동일)
        ctx.fillText(text, 0, h/2);

        // ★ 이제 DOM 텍스트는 바로 숨김 (캔버스가 takeover)
        line.querySelector('.plain').style.opacity = 0;
        line.querySelector('.fill').style.opacity  = 0;
      });
    }

    // === 2) overlay canvas 픽셀을 샘플링 해서 파티클 소스 좌표를 만든다
    function generateParticles(){
      particles=[]; spawners=[]; particlesGenerated=true;
      document.querySelectorAll('.brand-line').forEach(line=>{
        const cvs = line.querySelector('.text-overlay');
        const ctx = cvs.getContext('2d');
        const w = cvs.width  / (window.devicePixelRatio||1);
        const h = cvs.height / (window.devicePixelRatio||1);
        const img = ctx.getImageData(0,0,w,h).data;
        const cx=w/2, cy=h/2;
        const col=colorMain(line.dataset.c);
        const container=line.querySelector('.particles');

        const sources=[];
        for(let y=0;y<h;y+=DENSITY){
          for(let x=0;x<w;x+=DENSITY){
            const idx=( (y|0)*w + (x|0) )*4;
            if(img[idx+3]>128){ // 알파 있는 픽셀만
              const jx = x + (Math.random()-0.5)*1.0;
              const jy = y + (Math.random()-0.5)*1.0;
              const dx = jx - cx, dy = jy - cy;
              const len = Math.hypot(dx,dy) || 1;
              const dirx = dx/len, diry = dy/len;

              sources.push({
                x:jx, y:jy,
                vx: dirx * (SPEED_MIN + Math.random()*SPEED_RND),
                vy: diry * (SPEED_MIN + Math.random()*SPEED_RND),
                z: 0.6 + Math.random()*0.8,
                seed1: Math.random()*Math.PI*2,
                seed2: Math.random()*Math.PI*2
              });
            }
          }
        }

        // 스폰 순서를 랜덤 셔플 → 전체적으로 고르게 분해
        for(let i=sources.length-1;i>0;i--){
          const j=(Math.random()* (i+1))|0;
          const t=sources[i]; sources[i]=sources[j]; sources[j]=t;
        }

        spawners.push({line, cvs, ctx, container, col, sources, index:0, cleared:0, w, h});
      });
    }

    // === 3) 캔버스 픽셀을 지워가며 그 자리에서 파티클 스폰 → 진짜 분해
    function explodeFromCanvas(){
      const startT = performance.now();
      let lastT = startT;

      function animate(now){
        const dt = clamp(now - lastT, 0, 40); // ms
        lastT = now;

        // 3-1) 각 라인에서 일정 수의 소스를 꺼내 캔버스 픽셀을 삭제 + 파티클 생성
        spawners.forEach(sp=>{
          const {ctx, cvs, container, col, sources, w, h} = sp;
          let budget = BUDGET;
          while(budget>0 && sp.index < sources.length){
            const s = sources[sp.index++];
            // 해당 셀을 캔버스에서 지움 → 그 픽셀만 사라짐
            ctx.clearRect(s.x, s.y, DENSITY, DENSITY);
            sp.cleared++;

            // 파티클 DOM 생성
            const el=document.createElement('div');
            el.className='particle';
            el.style.setProperty('--c', col);
            el.style.setProperty('--twinkle-delay', (Math.random()*2.5).toFixed(2)+'s');
            container.appendChild(el);

            particles.push({
              x:s.x, y:s.y, vx:s.vx, vy:s.vy,
              z:s.z, alpha:0,
              born: now + Math.random()*450,     // 아주 짧은 지연
              life: 5200 + Math.random()*2800,
              seed1:s.seed1, seed2:s.seed2,
              el
            });
            budget--;
          }

          // 다 지웠으면 overlay canvas를 서서히 숨김 후 제거
          if(sp.index >= sources.length && sp._removed !== true){
            // 잔여 픽셀 거의 없으면 페이드 아웃
            cvs.style.transition = 'opacity .4s ease';
            cvs.style.opacity = '0';
            sp._removed = true;
            setTimeout(()=>{ cvs.remove(); }, 450);
          }
        });

        // 3-2) 파티클 업데이트(부유 + 감쇠)
        let alive = false;
        for(const pt of particles){
          const age = now - pt.born;
          if(age < 0){ continue; }

          const lifeT = age / pt.life;
          if(lifeT >= 1){ pt.alpha = 0; continue; }

          // 알파: 등장→유지→사라짐
          if(lifeT < 0.15) pt.alpha = lerp(0, 0.95, lifeT/0.15);
          else if(lifeT > 0.82) pt.alpha = lerp(0.95, 0, (lifeT-0.82)/0.18);
          else pt.alpha = 0.95;

          // 형태 유지 후 이동량 증가
          const moveGain = smoothstep(STICK_DUR, STICK_DUR + RAMP_DUR, age);

          const tt = now * 0.001;
          const swirlX = Math.sin(tt*0.9 + pt.seed1) * SWIRL_AMP;
          const swirlY = Math.cos(tt*0.8 + pt.seed2) * SWIRL_AMP;

          pt.vx += (swirlX + Math.sin(pt.seed1 + tt*0.25) * DRIFT_AMP * 0.001) * moveGain;
          pt.vy += (swirlY + Math.cos(pt.seed2 + tt*0.22) * DRIFT_AMP * 0.001) * moveGain;

          pt.vx *= FRICTION;
          pt.vy *= FRICTION;

          pt.x += pt.vx * dt * moveGain;
          pt.y += pt.vy * dt * moveGain;

          const s = 0.8 + pt.z * 0.6;
          const e = pt.el;
          e.style.opacity = pt.alpha.toFixed(3);
          e.style.transform = `translate3d(${pt.x}px, ${pt.y}px, 0) scale(${s})`;

          if(pt.alpha > 0) alive = true;
        }

        if(alive || spawners.some(sp=>sp.index < sp.sources.length)){
          requestAnimationFrame(animate);
        }
      }
      requestAnimationFrame(animate);
    }

    function showWelcome(){
      setTimeout(()=>{ counterEl.style.opacity=0; }, 400);
      setTimeout(()=>{ welcome.classList.add("visible"); }, 1000);
      setTimeout(()=>{
        scrollContent.style.display="block";
        isFinalized=true; 
        body.style.overflowY="auto";
      }, 1600);
    }

    // ===== 입력 =====
    function onWheel(e){
      if(isFinalized) return;
      const dy=e.deltaY;
      if(p<0.5){
        e.preventDefault(); 
        setProgress(p+dy*accel); 
        if(p>=0.5) startAutoAnimation();
      }else{
        e.preventDefault(); 
        if(!autoAnimating) startAutoAnimation();
      }
    }
    function onTouchMove(e){
      if(isFinalized) return;
      const touch=e.touches[0]; 
      const currentY=touch.clientY;
      if(typeof onTouchMove.lastY!=="undefined"){
        const dy=onTouchMove.lastY-currentY;
        if(dy>0&&p<0.5){
          e.preventDefault(); 
          setProgress(p+dy*accel*2); 
          if(p>=0.5) startAutoAnimation();
        } else if(dy>0&&p>=0.5&&!autoAnimating){
          e.preventDefault(); 
          startAutoAnimation();
        }
      }
      onTouchMove.lastY=currentY;
    }
    function onTouchEnd(){if(!isFinalized){onTouchMove.lastY=undefined;}}

    window.addEventListener('wheel',onWheel,{passive:false});
    window.addEventListener('touchstart',(e)=>{onTouchMove.lastY=e.touches[0].clientY;});
    window.addEventListener('touchmove',onTouchMove,{passive:false});
    window.addEventListener('touchend',onTouchEnd);

    setProgress(0);
  })();
  </script>
</body>
</html>
