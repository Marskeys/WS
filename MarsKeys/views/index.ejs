<!DOCTYPE html>
<% const isKorean = (lang || '').toLowerCase().startsWith('ko'); %>
<html lang="<%= lang %>">
  <%- include('partials/head') %>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>
    <% if (isSearch) { %>
      <%= locale.search_results_for %>: <%= searchKeyword %>
    <% } else if (selectedCategory) { %>
      <%= selectedCategory %>
    <% } else { %>
      <%= locale.marskeys_title %>
    <% } %>
  </title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Michroma&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <% if (isKorean) { %>
    <link href="https://fonts.googleapis.com/css2?family=Yeon+Sung&display=swap" rel="stylesheet">
  <% } %>

  <style>
    :root {
      --bg: #0e1016;
      --text: #eef2f8;
      --muted: #9aa3b2;
      --fill-int: 0%;

      /* ✨ 더 진한 은하 텍스처(보라/핑크/파랑 + 별빛) */
      --galaxy-text:
        radial-gradient(1.4px 1.4px at 8% 12%, rgba(255,255,255,.98), transparent 60%),
        radial-gradient(1.6px 1.6px at 18% 64%, rgba(255,155,230,.95), transparent 60%),
        radial-gradient(1.4px 1.4px at 32% 22%, rgba(150,180,255,.95), transparent 60%),
        radial-gradient(1.2px 1.2px at 44% 78%, rgba(255,225,180,.92),  transparent 60%),
        radial-gradient(1.8px 1.8px at 58% 36%, rgba(205,220,255,.98),  transparent 60%),
        radial-gradient(1.3px 1.3px at 70% 18%, rgba(235,160,255,.95),  transparent 60%),
        radial-gradient(1.5px 1.5px at 80% 70%, rgba(120,160,255,.95),  transparent 60%),
        radial-gradient(1.2px 1.2px at 92% 42%, rgba(255,245,225,.95),  transparent 60%),
        conic-gradient(from 130deg at 50% 50%,
          rgba(130,160,255,.42) 0%,
          rgba(255,120,220,.45) 14%,
          rgba(90,130,255,.44) 28%,
          rgba(255,90,190,.45) 42%,
          rgba(130,170,255,.44) 58%,
          rgba(230,150,255,.45) 72%,
          rgba(210,230,255,.42) 100%);
    }

    * { box-sizing: border-box }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow-x: hidden;
      overflow-y: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body.lang-ko #welcome { font-family: 'Montserrat', 'Michroma', system-ui, sans-serif; font-weight: 400; }

    body.show-background {
      background-image: url('https://images.unsplash.com/photo-1502126428-175f0881ed53?q=80&w=2670&auto=format&fit=crop');
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
      background-attachment: fixed;
      transition: background-image 2s ease;
    }

    .wrap { position: relative; min-height: 100svh; padding: 5vw; overflow: visible; }

    .brand { margin: 0; line-height: 1; font-family: "Michroma", system-ui, sans-serif; position: relative; z-index: 40; }

    .brand-line { display: block; font-size: clamp(56px, min(14vw, 28vh), 200px); line-height: 1.06; padding-bottom: 0.18em; overflow: visible; position: relative; }
    .brand-line+.brand-line { margin-top: -0.32em; }

    .ink{
      display:inline-block; color:transparent; -webkit-text-fill-color:transparent;
      -webkit-background-clip:text; background-clip:text;
      background-repeat:no-repeat,no-repeat;
      background-size:var(--fill-int) 100%, 100% 100%;
      background-image:var(--galaxy-text), linear-gradient(#fff,#fff);
      letter-spacing:0; padding-bottom:.28em; transform:translateZ(0);
      animation: galaxy-pan 30s linear infinite;
    }
    @keyframes galaxy-pan {
      0%   { background-position: 0 0, center; }
      50%  { background-position: -2% -1%, center; }
      100% { background-position: 0 0, center; }
    }

    .tagline { font-size: clamp(16px, 2.6vw, 28px); font-weight: 600; margin: 1rem 0 0; color: var(--muted); position: relative; transition: color .55s ease; will-change: color; }
    .tagline.shine-to-white { overflow: visible; }
    .tagline.shine-to-white::before{
      content: attr(data-text); position: absolute; inset: 0; pointer-events: none;
      color: transparent; -webkit-text-fill-color: transparent;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.16) 32%, rgba(255,255,255,.85) 50%, rgba(255,255,255,.16) 68%, rgba(255,255,255,0) 100%);
      -webkit-background-clip: text; background-clip: text;
      transform: translateX(-120%) skewX(-18deg); filter: blur(.3px);
      animation: shine-sweep 900ms cubic-bezier(.2,.7,.2,1) forwards;
    }
    .tagline.to-white { color: #fff; }
    @keyframes shine-sweep { to { transform: translateX(120%) skewX(-18deg); } }

    #counter {
      position: absolute; right: 5vw; bottom: clamp(16px, 6vh, 48px); text-align: right;
      font-size: clamp(28px, min(7vw, 10vh), 96px); font-family: "Michroma", system-ui, sans-serif;
      font-weight: 900; color: white; user-select: none; pointer-events: none; transition: opacity .6s ease; z-index: 40; margin: 0;
    }

    #particleCanvas { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }

    #lineViz { position: fixed; pointer-events: auto; z-index: 55; }

    #welcome {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) scale(0.86);
      opacity: 0; font-size: clamp(48px, 10vw, 130px); font-family: 'Montserrat', system-ui, sans-serif; color: white;
      letter-spacing: 0.01em; max-width: 92vw; white-space: nowrap;
      transition: opacity 1s ease, transform 1s cubic-bezier(.2, .7, .2, 1), text-shadow 1s ease-out;
      will-change: opacity, transform, text-shadow; pointer-events: none; z-index: 60; text-shadow: 0 0 0 transparent;
    }
    #welcome.visible { opacity: 1; transform: translate(-50%, -50%) scale(1.22); }
    #welcome.welcome-glow { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.6), 0 0 60px rgba(255, 255, 255, 0.4); }

    .scrollable-content { padding: 0 5vw 6rem; text-align: center; display: none; max-width: 1200px; margin: 0 auto; position: relative; z-index: 10; }
    .scrollable-content p { max-width: 800px; margin: 0 auto 1.5rem; line-height: 1.8; color: var(--muted); font-size: clamp(14px, 2vw, 18px); }
    .scrollable-content .temp-box { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 2rem; margin: 2rem auto; max-width: 900px; }

    @media (max-width: 768px) {
      .brand-line { line-height: 1.08; padding-bottom: 0.16em; }
      .brand-line+.brand-line { margin-top: -0.26em; }
    }
  </style>
</head>

<body class="<%= isKorean ? 'lang-ko' : '' %>">
  <main class="wrap" id="wrap">
    <canvas id="particleCanvas"></canvas>
    <canvas id="lineViz"></canvas>

    <h1 class="brand" id="brand">
      <span class="brand-line" data-c="red"><span class="ink" id="mars"><%= locale.mars_keys.split(' ')[0] %></span></span>
      <span class="brand-line" data-c="blue"><span class="ink" id="keys"><%= locale.mars_keys.split(' ')[1] %></span></span>
    </h1>

    <p class="tagline shine-to-white" data-text="<%= locale.game_music_studio %>"><%= locale.game_music_studio %></p>

    <div id="counter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">0%</div>
    <div id="welcome"><%= locale.welcome %></div>
  </main>

  <div id="scrollContent" class="scrollable-content">
    <p><%= locale.game_music_studio %> <%= locale.marskeys_title %>에 오신 것을 환영합니다...</p>
    <div class="temp-box">
      <h3>우리의 서비스</h3>
      <p>게임 OST, SFX, VO, 인터랙티브 음악 시스템...</p>
    </div>
    <div class="temp-box">
      <h3>포트폴리오</h3>
      <p>RPG, SF 어드벤처 등...</p>
    </div>
    <div class="temp-box">
      <h3>문의</h3>
      <p>협업 및 프로젝트 문의는 언제든지 환영합니다.</p>
    </div>
    <div style="height:60vh;"></div>
    <div class="temp-box">
      <p>마지막 임시 콘텐츠</p>
    </div>
  </div>

  <script>
    (function() {
      const html = document.documentElement;
      const body = document.body;
      const wrap = document.getElementById('wrap');
      const counterEl = document.getElementById("counter");
      const welcome = document.getElementById("welcome");
      const scrollContent = document.getElementById("scrollContent");
      const particleCanvas = document.getElementById('particleCanvas');
      const pctx = particleCanvas.getContext('2d');

      const tagline = document.querySelector('.tagline');
      tagline.addEventListener('animationend', (event) => {
        if (event.animationName === 'shine-sweep') tagline.classList.add('to-white');
      });

      // ===== Progress =====
      let p = 0;
      let autoAnimating = false,
          isFinalized = false,
          particlesGenerated = false;
      const VANISH_START = 0.5;

      const IS_MOBILE = window.matchMedia("(max-width: 768px)").matches;

      // ===== Particles (부유 + 스파클) =====
      let particles = [];
      const MAX_PARTICLES = IS_MOBILE ? 5200 : 2600; // 성능 여유
      let phase = 'idle';
      let phaseStart = 0;
      let floatStart = 0;

      function resizeParticleCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = wrap.getBoundingClientRect();
        particleCanvas.width = Math.floor(rect.width * dpr);
        particleCanvas.height = Math.floor(rect.height * dpr);
        particleCanvas.style.width = rect.width + 'px';
        particleCanvas.style.height = rect.height + 'px';
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.clearRect(0, 0, rect.width, rect.height);
      }

      function setProgress(v) {
        p = Math.max(0, Math.min(1, v));
        const pct = Math.round(p * 100);
        html.style.setProperty('--fill-int', pct + '%');
        if (!isFinalized) {
          counterEl.textContent = pct + "%";
          counterEl.setAttribute('aria-valuenow', String(pct));
        }
        if (p >= 1 && !particlesGenerated && !isFinalized) {
          generateParticles();
          fadeOutText();
          showWelcome();
          runParticles();
        }
      }

      function startAutoAnimation() {
        if (autoAnimating || isFinalized) return;
        autoAnimating = true;
        function step() {
          if (p < 1) {
            p = Math.min(1, p + 0.005);
            setProgress(p);
            requestAnimationFrame(step);
          } else autoAnimating = false;
        }
        step();
      }

      function drawTextToCanvas(text, fontSize, fontFamily) {
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');
        offCtx.font = `${fontSize}px ${fontFamily}`;
        const metrics = offCtx.measureText(text);
        const actualHeight = (metrics.actualBoundingBoxAscent || fontSize) + (metrics.actualBoundingBoxDescent || fontSize * 0.25);
        const width = Math.ceil(metrics.width);
        offCanvas.width = Math.ceil(width);
        offCanvas.height = Math.ceil(actualHeight);
        offCtx.font = `${fontSize}px ${fontFamily}`;
        offCtx.fillStyle = 'white';
        offCtx.textBaseline = 'top';
        offCtx.fillText(text, 0, 0);
        return { canvas: offCanvas };
      }

      function computeStepForTarget(canvas, target) {
        const area = canvas.width * canvas.height;
        const estGlyphArea = area * 0.45;
        return Math.max(3, Math.floor(Math.sqrt(estGlyphArea / Math.max(1, target))));
      }

      // ✨ 진한 별색 팔레트
      function pickStarColor(){
        const r = Math.random();
        if (r < 0.25) return 'rgba(255,255,255,0.98)';
        if (r < 0.50) return 'rgba(120,160,255,0.96)';
        if (r < 0.75) return 'rgba(235,160,255,0.96)';
        return 'rgba(255,120,220,0.96)';
      }

      function generateParticles() {
        particlesGenerated = true;
        particles.length = 0;

        const wrapRect = wrap.getBoundingClientRect();
        const lines = [
          { el: document.getElementById('mars').parentElement, textEl: document.getElementById('mars') },
          { el: document.getElementById('keys').parentElement, textEl: document.getElementById('keys') }
        ];

        const TARGET_PER_LINE = IS_MOBILE ? 3200 : 1400;

        lines.forEach(({ el, textEl }) => {
          const rect = el.getBoundingClientRect();
          const style = getComputedStyle(textEl);
          const fontSize = parseFloat(style.fontSize);
          const fontFamily = style.fontFamily;
          const { canvas } = drawTextToCanvas(textEl.textContent, fontSize, fontFamily);
          const ctx = canvas.getContext('2d');
          const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = img.data;

          const STEP = computeStepForTarget(canvas, TARGET_PER_LINE);

          for (let y = 0; y < canvas.height; y += STEP) {
            for (let x = 0; x < canvas.width; x += STEP) {
              const idx = (y * canvas.width + x) * 4;
              if (data[idx + 3] > 128) {
                const px = rect.left - wrapRect.left + x;
                const py = rect.top - wrapRect.top + y;

                // 초기 '깨짐' → 바깥으로 살짝 튕김
                const spd = 0.35 + Math.random() * 0.4;
                const ang = Math.random() * Math.PI * 2;
                particles.push({
                  x: px, y: py,
                  vx: Math.cos(ang) * spd,
                  vy: Math.sin(ang) * spd,
                  alpha: 1,
                  color: pickStarColor(),
                  size0: 1.1 + Math.random() * 1.3, // 기본 크기
                  size: 0,                           // 그려질 크기(트윙클/글로우 반영)
                  tw: 0.5 + Math.random() * 0.8,
                  twPhase: Math.random() * Math.PI * 2,
                  glow: 0,                           // 스파클 강도 0..1
                  sparkCooldown: 400 + Math.random()*3000 // 다음 스파클까지 남은 ms
                });
              }
            }
          }
        });

        // 캡 적용
        if (particles.length > MAX_PARTICLES) {
          const sampled = [];
          for (let i = 0; i < MAX_PARTICLES; i++) sampled.push(particles[(Math.random() * particles.length) | 0]);
          particles = sampled;
        }
      }

      function fadeOutText() {
        document.querySelectorAll('.ink').forEach(el => {
          el.style.transition = 'opacity .3s ease';
          el.style.opacity = '0';
        });
      }

      function showWelcome() {
        setTimeout(() => { counterEl.style.opacity = 0; }, 350);
        setTimeout(() => { welcome.classList.add("visible"); welcome.classList.add("welcome-glow"); }, 2000);
        setTimeout(() => { scrollContent.style.display = "block"; isFinalized = true; body.style.overflowY = "auto"; }, 1500);
      }

      // ===== 유틸: 플로우 필드(부드러운 전체 드리프트) =====
      function flowField(x, y, t){
        // 가벼운 준-노이즈 필드 (sin/cos 결합)
        const ax = 0.0006, ay = 0.0007;
        const a = Math.sin(x * ax + t * 0.00022) + Math.cos(y * ay - t * 0.00018);
        const ang = a * Math.PI; // [-2π..2π] 범위 비슷
        const mag = 0.03 + 0.01 * Math.sin(t * 0.00013); // 서서히 진폭 변화
        return { fx: Math.cos(ang) * mag, fy: Math.sin(ang) * mag };
      }

      function runParticles() {
        phase = 'break';
        phaseStart = performance.now();
        let last = phaseStart;

        function frame(now) {
          const dt = Math.min(40, now - last); // ms, 프레임 드랍 방지
          last = now;

          const rect = wrap.getBoundingClientRect();
          const W = rect.width, H = rect.height;
          const cx = W * 0.5, cy = H * 0.5;

          pctx.clearRect(0, 0, W, H);

          // 단계 전환
          if (phase === 'break' && now - phaseStart >= 900) {
            // float 시작: 전역 확산을 위한 약한 바깥쪽 푸시 적용
            for (const pt of particles) {
              const dx = pt.x - cx, dy = pt.y - cy;
              const dist = Math.hypot(dx, dy) + 0.0001;
              const push = 0.25 + Math.random() * 0.15;
              pt.vx *= 0.35; pt.vy *= 0.35;
              pt.vx += (dx / dist) * push;
              pt.vy += (dy / dist) * push;
            }
            phase = 'float';
            floatStart = now;
          }

          // 업데이트
          const elapsedFloat = Math.max(0, now - floatStart);
          for (const pt of particles) {
            if (phase === 'break') {
              // 초기 튕김 감쇠 + 약한 난류
              pt.vx *= 0.985; pt.vy *= 0.985;
              pt.vx += (Math.random() - 0.5) * 0.02;
              pt.vy += (Math.random() - 0.5) * 0.02;
            } else {
              // ===== float 단계 =====
              // 1) 플로우 필드 기반 부유
              const f = flowField(pt.x, pt.y, now);
              pt.vx += f.fx; pt.vy += f.fy;

              // 2) 느린 전역 회전 드리프트로 화면 전역 순환
              const rot = now * 0.00005;
              pt.vx += Math.cos(rot) * 0.012;
              pt.vy += Math.sin(rot) * 0.012;

              // 3) 시작 초반 전체 확산(점점 사라지는 바깥쪽 압력)
              if (elapsedFloat < 8000) {
                const dx = pt.x - cx, dy = pt.y - cy;
                const dist = Math.hypot(dx, dy) + 0.0001;
                const outward = (0.04 * Math.exp(-elapsedFloat / 5000));
                pt.vx += (dx / dist) * outward;
                pt.vy += (dy / dist) * outward;
              }

              // 4) 속도 제한 (너무 빠르게 모이지 않게)
              const maxV = 0.30;
              const sp = Math.hypot(pt.vx, pt.vy);
              if (sp > maxV) { pt.vx = (pt.vx / sp) * maxV; pt.vy = (pt.vy / sp) * maxV; }

              // 5) 랜덤 킥 (한 자리에 너무 오래 머무르지 않도록)
              if (Math.random() < 0.0025) {
                pt.vx += (Math.random() - 0.5) * 0.06;
                pt.vy += (Math.random() - 0.5) * 0.06;
              }

              // ===== 스파클(글로우 펄스) 타이머 =====
              pt.sparkCooldown -= dt;
              if (pt.sparkCooldown <= 0) {
                if (Math.random() < 0.25) {
                  pt.glow = 1;                            // 글로우 시작
                }
                pt.sparkCooldown = 600 + Math.random()*5000; // 다음 스파클까지
              }
              // 글로우 감쇠
              if (pt.glow > 0) pt.glow *= 0.92;
            }

            // 위치 이동
            pt.x += pt.vx; pt.y += pt.vy;

            // 스크린 래핑
            const m = 32;
            if (pt.x < -m) pt.x = W + m;
            if (pt.x > W + m) pt.x = -m;
            if (pt.y < -m) pt.y = H + m;
            if (pt.y > H + m) pt.y = -m;
          }

          // ===== 드로잉 =====
          pctx.globalCompositeOperation = 'source-over';
          pctx.shadowBlur = 10; pctx.shadowOffsetX = 0; pctx.shadowOffsetY = 0;

          for (const pt of particles) {
            // 트윙클 + 글로우 반영
            const twinkle = 0.85 + 0.15 * Math.sin(now * 0.006 * pt.tw + pt.twPhase);
            const glowBoost = 1 + 0.9 * pt.glow; // 밝기 업
            const sizeBoost = 1 + 0.9 * pt.glow; // 크기 업
            pt.size = pt.size0 * sizeBoost;

            // 기본 별
            pctx.globalAlpha = Math.max(0, Math.min(1, twinkle * glowBoost));
            pctx.shadowColor = pt.color; pctx.fillStyle = pt.color;
            pctx.beginPath(); pctx.arc(pt.x, pt.y, pt.size, 0, Math.PI * 2); pctx.fill();

            // 글로우 중이면 라이트 블룸 링
            if (pt.glow > 0.02) {
              pctx.save();
              pctx.globalCompositeOperation = 'lighter';
              pctx.globalAlpha = 0.35 * pt.glow;
              pctx.beginPath(); pctx.arc(pt.x, pt.y, pt.size * 2.2, 0, Math.PI * 2); pctx.fill();
              pctx.restore();
            }
          }

          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      function onWheel(e) {
        if (isFinalized) return;
        e.preventDefault();
        const dy = e.deltaY;
        if (p < 0.5) { setProgress(p + dy * 0.0018); startAutoAnimation(); }
        else if (!autoAnimating) { startAutoAnimation(); }
      }
      function onTouchMove(e) {
        if (isFinalized) return;
        const touch = e.touches[0]; const currentY = touch.clientY;
        if (typeof onTouchMove.lastY !== "undefined") {
          const dy = onTouchMove.lastY - currentY;
          if (p < 0.5) { setProgress(p + dy * 0.0018 * 2); if (p >= 0.5) startAutoAnimation(); }
          else if (!autoAnimating && dy > 0) { startAutoAnimation(); }
        }
        onTouchMove.lastY = currentY;
      }
      function onTouchEnd() { if (!isFinalized) onTouchMove.lastY = undefined; }

      window.addEventListener('resize', resizeParticleCanvas);
      window.addEventListener('wheel', onWheel, { passive: false });
      window.addEventListener('touchstart', (e) => { onTouchMove.lastY = e.touches[0].clientY; });
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', onTouchEnd);

      resizeParticleCanvas();
      setProgress(0);

      /* ================================
         🎸 현 시뮬레이터 — 기존 유지
         ================================ */
      const lineCanvas = document.getElementById('lineViz');
      const lctx = lineCanvas.getContext('2d');

      const LINE_THICK = 8;
      const LINE_H_DESKTOP = 72;
      const LINE_H_MOBILE  = 96;
      const V_PAD_VH = 18;

      let tension    = 0.8;
      let loss       = 0.986;
      let SUBSTEPS   = 10;
      let radiusPx   = 80;
      let handPower  = 0.95;
      const K_MOUSE  = 1.5;
      const C_MOUSE  = 0.08;
      const HARD_FACTOR = 0.4;
      const RELEASE_KICK = 0.25;

      let numPoints = 240;
      let dx = 1, invDX2 = 1;
      let initialY = 0;
      let string = [];
      let MAX_PULL = 0;

      class StringPoint { constructor(x, y){ this.x=x; this.y=y; this.oldY=y; this.acc=0; } }

      let vanishBaseWidth = null, vanishBaseLeft = null;

      function placeLineViz() {
        const Wwin = window.innerWidth;
        const Hwin = window.innerHeight;
        const isMobile = window.matchMedia("(max-width: 768px)").matches;

        if (isMobile) {
          const desiredWidth = Math.round(Wwin * 0.9);
          const midY   = Math.round(Hwin / 2);
          const cssHeightBase = LINE_H_MOBILE;
          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = cssHeightBase + padPx * 2;
          const left = Math.round((Wwin - desiredWidth) / 2);

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = desiredWidth + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(desiredWidth  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(desiredWidth, cssHeight);
          if (vanishBaseWidth === null) {
            vanishBaseWidth = desiredWidth;
            vanishBaseLeft  = left;
          }
        } else {
          const marsLine = document.getElementById('mars')?.parentElement || null;
          const keysLine = document.getElementById('keys')?.parentElement || null;
          let left   = Math.round(Wwin * 0.2);
          let width  = Math.round(Wwin * 0.6);
          let midY   = Math.round(Hwin / 2);
          try {
            if (marsLine && keysLine) {
              const wrapRect = wrap.getBoundingClientRect();
              const wrapCS = getComputedStyle(wrap);
              const padLeft = parseFloat(wrapCS.paddingLeft) || 0;
              const additionalPadding = 250;

              left = Math.round(wrapRect.left + padLeft + additionalPadding);
              const rightLimit = Math.min(keysLine.getBoundingClientRect().right, wrapRect.right - padLeft * 0.25);
              width = Math.max(260, Math.round(rightLimit - left));

              const marsBottom = marsLine.getBoundingClientRect().bottom;
              const keysTop = keysLine.getBoundingClientRect().top;
              midY = Math.round((marsBottom + keysTop) / 2);
            }
          } catch(e) { /* fallback */ }

          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = LINE_H_DESKTOP + padPx * 2;
          width = Math.min(width, Wwin);
          left  = Math.max(0, Math.min(left, Wwin - width));

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = width + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(width  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(width, cssHeight);
          if (vanishBaseWidth === null) {
            vanishBaseWidth = width;
            vanishBaseLeft  = left;
          }
        }
      }

      function setupString(W, H){
        numPoints = Math.max(160, Math.min(360, Math.round(W / 4)));
        string = [];
        for (let i=0;i<numPoints;i++){
          const x = (i/(numPoints-1)) * W;
          string.push(new StringPoint(x, H/2));
        }
        initialY = H/2;
        dx = W / (numPoints - 1);
        invDX2 = 1 / (dx*dx);
      }

      const mouse = { active:false, x:0, y:0 };
      function getPos(e){
        const r = lineCanvas.getBoundingClientRect();
        const cx = (e.clientX??e.touches?.[0].clientX) - r.left;
        const cy = (e.clientY??e.touches?.[0].clientY) - r.top;
        return {x:cx, y:cy};
      }

      lineCanvas.addEventListener('mousedown', e=>{
        const {x,y} = getPos(e); mouse.active = true; mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mousemove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mouseup', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      lineCanvas.addEventListener('touchstart', e=>{
        const {x,y} = getPos(e); e.preventDefault(); mouse.active = true; mouse.x = x; mouse.y = y;
      }, {passive:false});
      lineCanvas.addEventListener('touchmove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); e.preventDefault(); mouse.x = x; mouse.y = y;
      }, {passive:false});
      window.addEventListener('touchend', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      function hannWeight(dist, R){
        if (dist >= R) return 0;
        const r = dist / R;
        return 0.5 * (1 + Math.cos(Math.PI * r));
      }

      function applyMouseForce(){
        if (!mouse.active) return;

        let pullY = mouse.y - initialY;
        if (Math.abs(pullY) > MAX_PULL) {
          pullY = Math.sign(pullY) * MAX_PULL;
        }

        const FcapBase = 12;
        const Fcap = FcapBase / (1 + HARD_FACTOR * tension);

        for (let i = 1; i < numPoints - 1; i++) {
          const p = string[i];
          const distX = Math.abs(p.x - mouse.x);
          const w = hannWeight(distX, radiusPx);
          if (w <= 0) continue;

          const vel = p.y - p.oldY;
          const Fspring = K_MOUSE * (initialY + pullY - p.y);
          const Fdamp   = -C_MOUSE * vel;
          let F = (Fspring + Fdamp) * w;

          if (F >  Fcap * w) F =  Fcap * w;
          if (F < -Fcap * w) F = -Fcap * w;

          p.acc += F;
        }
      }

      function physicsStep(){
        for (let i=1;i<numPoints-1;i++){
          const prev = string[i-1].y, curr = string[i].y, next = string[i+1].y;
          const lap = (prev - 2*curr + next) * invDX2;
          string[i].acc = tension * lap;
        }
        applyMouseForce();

        string[0].acc = 0; string[numPoints-1].acc = 0;

        for (let i=1;i<numPoints-1;i++){
          const p = string[i];
          const tempY = p.y;
          p.y = p.y*2 - p.oldY + p.acc;
          p.oldY = tempY;
          p.y = initialY + (p.y - initialY) * loss;
        }
        string[0].y = string[0].oldY = initialY;
        string[numPoints-1].y = string[numPoints-1].oldY = initialY;
      }

      function drawString(){
        const rect = lineCanvas.getBoundingClientRect();
        const Wdraw = Math.max(0, Math.round(rect.width));
        const Hdraw = Math.max(0, Math.round(rect.height));
        if (!Wdraw || !Hdraw) return;

        lctx.clearRect(0,0,Wdraw,Hdraw);

        const smoothstep = (x) => x < 0 ? 0 : x > 1 ? 1 : x * x * (3 - 2 * x);
        const f = (p < VANISH_START) ? 0 : smoothstep((p - VANISH_START) / (1 - VANISH_START));
        const thickness = Math.max(0.6, LINE_THICK * (1 - 0.9 * f));
        lctx.globalAlpha = 1 - f;

        lctx.beginPath();
        lctx.strokeStyle = '#ffffff';
        lctx.lineWidth = thickness;
        lctx.lineCap = 'round';
        lctx.lineJoin = 'round';

        const baseW = (vanishBaseWidth || Wdraw);
        const baseC = baseW / 2;
        const scaleX = Wdraw / baseW;
        const mapX = x => baseC + (x - baseC) * scaleX;

        lctx.moveTo(mapX(string[0].x), string[0].y);
        for (let i=1;i<numPoints-2;i++){
          const xc = mapX((string[i].x + string[i+1].x)/2);
          const yc = (string[i].y + string[i+1].y)/2;
          lctx.quadraticCurveTo(mapX(string[i].x), string[i].y, xc, yc);
        }
        lctx.quadraticCurveTo(mapX(string[numPoints-2].x), string[numPoints-2].y, mapX(string[numPoints-1].x), string[numPoints-1].y);
        lctx.stroke();

        lctx.globalAlpha = 1;
      }

      function animateString(){
        for (let s=0; s<SUBSTEPS; s++) physicsStep();
        drawString();
        if(!isFinalized) requestAnimationFrame(animateString);
      }

      const ro = new ResizeObserver(() => placeLineViz());
      ro.observe(document.body);
      ro.observe(document.getElementById('brand'));
      window.addEventListener('resize', placeLineViz);
      window.addEventListener('orientationchange', placeLineViz);
      if (document.fonts && document.fonts.ready) { document.fonts.ready.then(placeLineViz); }

      placeLineViz();
      requestAnimationFrame(animateString);
    })();
  </script>
</body>
</html>
