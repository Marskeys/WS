<!DOCTYPE html>
<% const isKorean = (lang || '').toLowerCase().startsWith('ko'); %>
<html lang="<%= lang %>">
  <%- include('partials/head') %>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>
    <% if (isSearch) { %>
      <%= locale.search_results_for %>: <%= searchKeyword %>
    <% } else if (selectedCategory) { %>
      <%= selectedCategory %>
    <% } else { %>
      <%= locale.marskeys_title %>
    <% } %>
  </title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Michroma&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <% if (isKorean) { %>
    <link href="https://fonts.googleapis.com/css2?family=Yeon+Sung&display=swap" rel="stylesheet">
  <% } %>

  <style>
    :root {
      --bg: #0e1016;
      --text: #eef2f8;
      --muted: #9aa3b2;
      --fill-int: 0%;

      /* í…ìŠ¤íŠ¸ ì±„ì›€: ë³´ë¼/í•‘í¬/ë¸”ë£¨ & ë³„ë¹› ìŠ¤íŒŒí´ */
      --galaxy-text:
        radial-gradient(1.2px 1.2px at 8% 12%, rgba(255,255,255,.95), transparent 60%),
        radial-gradient(1.3px 1.3px at 18% 64%, rgba(255,210,245,.92), transparent 60%),
        radial-gradient(1.1px 1.1px at 32% 22%, rgba(190,210,255,.95), transparent 60%),
        radial-gradient(1.0px 1.0px at 44% 78%, rgba(255,229,170,.9),  transparent 60%),
        radial-gradient(1.6px 1.6px at 58% 36%, rgba(210,226,255,1),   transparent 60%),
        radial-gradient(1.1px 1.1px at 70% 18%, rgba(250,205,255,.9),  transparent 60%),
        radial-gradient(1.2px 1.2px at 80% 70%, rgba(176,198,255,.95), transparent 60%),
        radial-gradient(1.0px 1.0px at 92% 42%, rgba(255,246,230,.9),  transparent 60%),
        conic-gradient(from 130deg at 50% 50%,
          rgba(200,210,255,.28) 0%,
          rgba(255,160,240,.30) 14%,
          rgba(140,170,255,.32) 28%,
          rgba(255,120,200,.30) 42%,
          rgba(170,210,255,.30) 58%,
          rgba(250,190,255,.30) 72%,
          rgba(220,232,255,.28) 100%);
    }

    * { box-sizing: border-box }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow-x: hidden;
      overflow-y: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body.lang-ko #welcome { font-family: 'Montserrat', 'Michroma', system-ui, sans-serif; font-weight: 400; }

    body.show-background {
      background-image: url('https://images.unsplash.com/photo-1502126428-175f0881ed53?q=80&w=2670&auto=format&fit=crop');
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
      background-attachment: fixed;
      transition: background-image 2s ease;
    }

    .wrap { position: relative; min-height: 100svh; padding: 5vw; overflow: visible; }

    .brand { margin: 0; line-height: 1; font-family: "Michroma", system-ui, sans-serif; position: relative; z-index: 40; }

    .brand-line { display: block; font-size: clamp(56px, min(14vw, 28vh), 200px); line-height: 1.06; padding-bottom: 0.18em; overflow: visible; position: relative; }
    .brand-line+.brand-line { margin-top: -0.32em; }

    .ink{
      display:inline-block; color:transparent; -webkit-text-fill-color:transparent;
      -webkit-background-clip:text; background-clip:text;
      background-repeat:no-repeat,no-repeat;
      background-size:var(--fill-int) 100%, 100% 100%;
      background-image:var(--galaxy-text), linear-gradient(#fff,#fff);
      letter-spacing:0; padding-bottom:.28em; transform:translateZ(0);
      animation: galaxy-pan 30s linear infinite;
    }
    @keyframes galaxy-pan {
      0%   { background-position: 0 0, center; }
      50%  { background-position: -2% -1%, center; }
      100% { background-position: 0 0, center; }
    }

    .tagline { font-size: clamp(16px, 2.6vw, 28px); font-weight: 600; margin: 1rem 0 0; color: var(--muted); position: relative; transition: color .55s ease; will-change: color; }
    .tagline.shine-to-white { overflow: visible; }
    .tagline.shine-to-white::before{
      content: attr(data-text); position: absolute; inset: 0; pointer-events: none;
      color: transparent; -webkit-text-fill-color: transparent;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.16) 32%, rgba(255,255,255,.85) 50%, rgba(255,255,255,.16) 68%, rgba(255,255,255,0) 100%);
      -webkit-background-clip: text; background-clip: text;
      transform: translateX(-120%) skewX(-18deg); filter: blur(.3px);
      animation: shine-sweep 900ms cubic-bezier(.2,.7,.2,1) forwards;
    }
    .tagline.to-white { color: #fff; }
    @keyframes shine-sweep { to { transform: translateX(120%) skewX(-18deg); } }

    #counter {
      position: absolute; right: 5vw; bottom: clamp(16px, 6vh, 48px); text-align: right;
      font-size: clamp(28px, min(7vw, 10vh), 96px); font-family: "Michroma", system-ui, sans-serif;
      font-weight: 900; color: white; user-select: none; pointer-events: none; transition: opacity .6s ease; z-index: 40; margin: 0;
    }

    #particleCanvas { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
    #lineViz { position: fixed; pointer-events: auto; z-index: 55; }

    #welcome {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) scale(0.86);
      opacity: 0; font-size: clamp(48px, 10vw, 130px); font-family: 'Montserrat', system-ui, sans-serif; color: white;
      letter-spacing: 0.01em; max-width: 92vw; white-space: nowrap;
      transition: opacity 1s ease, transform 1s cubic-bezier(.2, .7, .2, 1), text-shadow 1s ease-out;
      will-change: opacity, transform, text-shadow; pointer-events: none; z-index: 60; text-shadow: 0 0 0 transparent;
    }
    #welcome.visible { opacity: 1; transform: translate(-50%, -50%) scale(1.22); }
    #welcome.welcome-glow { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.6), 0 0 60px rgba(255, 255, 255, 0.4); }

    .scrollable-content { padding: 0 5vw 6rem; text-align: center; display: none; max-width: 1200px; margin: 0 auto; position: relative; z-index: 10; }
    .scrollable-content p { max-width: 800px; margin: 0 auto 1.5rem; line-height: 1.8; color: var(--muted); font-size: clamp(14px, 2vw, 18px); }
    .scrollable-content .temp-box { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 2rem; margin: 2rem auto; max-width: 900px; }

    @media (max-width: 768px) {
      .brand-line { line-height: 1.08; padding-bottom: 0.16em; }
      .brand-line+.brand-line { margin-top: -0.26em; }
    }
  </style>
</head>

<body class="<%= isKorean ? 'lang-ko' : '' %>">
  <main class="wrap" id="wrap">
    <canvas id="particleCanvas"></canvas>
    <canvas id="lineViz"></canvas>

    <h1 class="brand" id="brand">
      <span class="brand-line" data-c="red"><span class="ink" id="mars"><%= locale.mars_keys.split(' ')[0] %></span></span>
      <span class="brand-line" data-c="blue"><span class="ink" id="keys"><%= locale.mars_keys.split(' ')[1] %></span></span>
    </h1>

    <p class="tagline shine-to-white" data-text="<%= locale.game_music_studio %>"><%= locale.game_music_studio %></p>

    <div id="counter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">0%</div>
    <div id="welcome"><%= locale.welcome %></div>
  </main>

  <div id="scrollContent" class="scrollable-content">
    <p><%= locale.game_music_studio %> <%= locale.marskeys_title %>ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤...</p>
    <div class="temp-box">
      <h3>ìš°ë¦¬ì˜ ì„œë¹„ìŠ¤</h3>
      <p>ê²Œì„ OST, SFX, VO, ì¸í„°ë™í‹°ë¸Œ ìŒì•… ì‹œìŠ¤í…œ...</p>
    </div>
    <div class="temp-box">
      <h3>í¬íŠ¸í´ë¦¬ì˜¤</h3>
      <p>RPG, SF ì–´ë“œë²¤ì²˜ ë“±...</p>
    </div>
    <div class="temp-box">
      <h3>ë¬¸ì˜</h3>
      <p>í˜‘ì—… ë° í”„ë¡œì íŠ¸ ë¬¸ì˜ëŠ” ì–¸ì œë“ ì§€ í™˜ì˜í•©ë‹ˆë‹¤.</p>
    </div>
    <div style="height:60vh;"></div>
    <div class="temp-box">
      <p>ë§ˆì§€ë§‰ ì„ì‹œ ì½˜í…ì¸ </p>
    </div>
  </div>

  <script>
    (function() {
      const html = document.documentElement;
      const body = document.body;
      const wrap = document.getElementById('wrap');
      const counterEl = document.getElementById("counter");
      const welcome = document.getElementById("welcome");
      const scrollContent = document.getElementById("scrollContent");
      const particleCanvas = document.getElementById('particleCanvas');
      const pctx = particleCanvas.getContext('2d');

      const tagline = document.querySelector('.tagline');
      tagline.addEventListener('animationend', (event) => {
        if (event.animationName === 'shine-sweep') tagline.classList.add('to-white');
      });

      // ===== Progress =====
      let p = 0;
      let autoAnimating = false,
          isFinalized = false,
          particlesGenerated = false;
      const VANISH_START = 0.5;

      const IS_MOBILE = window.matchMedia("(max-width: 768px)").matches;

      // ===== Particles / Galaxy fields =====
      let particles = [];
      const MAX_PARTICLES = IS_MOBILE ? 8000 : 3000;
      let particlePhase = 'idle';
      let phaseStartTime = 0;

      // ì¶•ì†Œ(ì™„ì„± í›„) íŒŒë¼ë¯¸í„°
      let tgCenterX = 0, tgCenterY = 0;
      let taegeukScale = 1;
      const TAEGEUK_FINAL_SCALE = 0.38;
      const SHRINK_DURATION_MS = 2600;
      const easeInOutCubic = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;

      // ì„±ìš´(ê°€ìŠ¤ í´ë¼ìš°ë“œ) ë°ì´í„°
      let clouds = [];

      function resizeParticleCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = wrap.getBoundingClientRect();
        particleCanvas.width = Math.floor(rect.width * dpr);
        particleCanvas.height = Math.floor(rect.height * dpr);
        particleCanvas.style.width = rect.width + 'px';
        particleCanvas.style.height = rect.height + 'px';
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.clearRect(0, 0, rect.width, rect.height);
      }

      function setProgress(v) {
        p = Math.max(0, Math.min(1, v));
        const pct = Math.round(p * 100);
        html.style.setProperty('--fill-int', pct + '%');
        if (!isFinalized) {
          counterEl.textContent = pct + "%";
          counterEl.setAttribute('aria-valuenow', String(pct));
        }
        if (p >= 1 && !particlesGenerated && !isFinalized) {
          generateParticles();
          fadeOutText();
          showWelcome();
          runParticleShow();
        }
      }

      function startAutoAnimation() {
        if (autoAnimating || isFinalized) return;
        autoAnimating = true;
        function step() {
          if (p < 1) {
            p = Math.min(1, p + 0.005);
            setProgress(p);
            requestAnimationFrame(step);
          } else autoAnimating = false;
        }
        step();
      }

      function drawTextToCanvas(text, fontSize, fontFamily) {
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');
        offCtx.font = `${fontSize}px ${fontFamily}`;
        const metrics = offCtx.measureText(text);
        const actualHeight = (metrics.actualBoundingBoxAscent || fontSize) + (metrics.actualBoundingBoxDescent || fontSize * 0.25);
        const width = Math.ceil(metrics.width);
        offCanvas.width = Math.ceil(width);
        offCanvas.height = Math.ceil(actualHeight);
        offCtx.font = `${fontSize}px ${fontFamily}`;
        offCtx.fillStyle = 'white';
        offCtx.textBaseline = 'top';
        offCtx.fillText(text, 0, 0);
        return { canvas: offCanvas };
      }

      function computeStepForTarget(canvas, target) {
        const area = canvas.width * canvas.height;
        const estGlyphArea = area * 0.45;
        return Math.max(3, Math.floor(Math.sqrt(estGlyphArea / Math.max(1, target))));
      }

      // ===== Star color palette (H-R ëŠë‚Œ) =====
      function pickStarColorByRegion(rNorm, armBias, ringBias) {
        // ì¤‘ì‹¬ë¶€: ë”°ëœ»í•œ ë°±/í™©ë°±, íŒ”: ì²­ë°±/ë¸”ë£¨, ë§: í•‘í¬/ë³´ë¼ ê°•ì¡°
        const t = Math.random();
        if (rNorm < 0.2) {
          if (t < 0.6) return 'rgba(255,245,230,0.95)';
          if (t < 0.85) return 'rgba(255,255,255,0.95)';
          return 'rgba(255,230,180,0.95)';
        }
        if (ringBias > 0.5 && Math.random() < 0.6) {
          if (t < 0.55) return 'rgba(255,150,230,0.95)'; // í•‘í¬ HII
          if (t < 0.8)  return 'rgba(210,190,255,0.95)'; // ë³´ëë¹›
          return 'rgba(176,198,255,0.95)';               // í‘¸ë¥¸-ë³´ë¼
        }
        if (armBias > 0.45) {
          if (t < 0.55) return 'rgba(200,220,255,0.95)';
          if (t < 0.85) return 'rgba(176,198,255,0.95)';
          return 'rgba(255,255,255,0.95)';
        }
        // ì™¸ê³½/í—¤ì¼ë¡œ: ì°¨ê°‘ê±°ë‚˜ í¬ë¯¸
        if (t < 0.5) return 'rgba(210,226,255,0.9)';
        if (t < 0.8) return 'rgba(255,255,255,0.9)';
        return 'rgba(190,205,235,0.85)';
      }

      function generateParticles() {
        particlesGenerated = true;
        particles.length = 0;
        clouds.length = 0;

        const wrapRect = wrap.getBoundingClientRect();
        const lines = [
          { el: document.getElementById('mars').parentElement, textEl: document.getElementById('mars') },
          { el: document.getElementById('keys').parentElement, textEl: document.getElementById('keys') }
        ];

        // Particles originate from glyphs (ê·¸ ëª¨ì–‘ ê·¸ëŒ€ë¡œ ë¶„í•´)
        const TARGET_PER_LINE = IS_MOBILE ? 4000 : 1500;
        const glyphPts = [];

        lines.forEach(({ el, textEl }) => {
          const rect = el.getBoundingClientRect();
          const style = getComputedStyle(textEl);
          const fontSize = parseFloat(style.fontSize);
          const fontFamily = style.fontFamily;
          const { canvas } = drawTextToCanvas(textEl.textContent, fontSize, fontFamily);
          const ctx = canvas.getContext('2d');
          const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = img.data;
          const STEP = computeStepForTarget(canvas, TARGET_PER_LINE);

          for (let y = 0; y < canvas.height; y += STEP) {
            for (let x = 0; x < canvas.width; x += STEP) {
              const idx = (y * canvas.width + x) * 4;
              if (data[idx + 3] > 128) {
                const px = rect.left - wrapRect.left + x;
                const py = rect.top - wrapRect.top + y;
                glyphPts.push({ x: px, y: py });
              }
            }
          }
        });

        // ì´ˆê¸° í­ë°œ ì†ë„ ë¶€ì—¬
        const centerX = wrapRect.width * 0.5;
        const centerY = wrapRect.height * 0.5;

        for (const g of glyphPts) {
          const dx = g.x - centerX;
          const dy = g.y - centerY;
          const dist = Math.hypot(dx, dy) + 0.0001;
          const boost = 0.6 + Math.random() * 1.1;
          particles.push({
            x: g.x, y: g.y,
            vx: (Math.random() - 0.5) * 0.6 + (dx / dist) * boost,
            vy: (Math.random() - 0.5) * 0.6 + (dy / dist) * boost,
            alpha: 1,
            color: 'rgba(255,255,255,0.95)',
            size: 1.2 + Math.random() * 1.3,
            tw: 0.5 + Math.random() * 0.8,
            twPhase: Math.random() * Math.PI * 2,
            tx: null, ty: null, reached: false,
            tbx: null, tby: null,
            armBias: 0, ringBias: 0, rNorm: 1
          });
        }

        // Trim
        if (particles.length > (IS_MOBILE ? 8000 : 3000)) {
          const cap = IS_MOBILE ? 8000 : 3000;
          const sampled = [];
          for (let i = 0; i < cap; i++) sampled.push(particles[(Math.random() * particles.length) | 0]);
          particles = sampled;
        }
      }

      function fadeOutText() {
        document.querySelectorAll('.ink').forEach(el => {
          el.style.transition = 'opacity .3s ease';
          el.style.opacity = '0';
        });
      }

      function showWelcome() {
        setTimeout(() => { counterEl.style.opacity = 0; }, 350);
        setTimeout(() => { welcome.classList.add("visible"); welcome.classList.add("welcome-glow"); }, 2000);
        setTimeout(() => { scrollContent.style.display = "block"; isFinalized = true; body.style.overflowY = "auto"; }, 1500);
      }

      // ======= ì•ˆë“œë¡œë©”ë‹¤ íƒ€ê¹ƒ ë¹Œë“œ =======
      function buildAndromedaTargets(n) {
        const rect = wrap.getBoundingClientRect();
        const cx = rect.width * 0.5, cy = rect.height * 0.5;
        tgCenterX = cx; tgCenterY = cy;

        const R = Math.min(rect.width, rect.height) * 0.42; // ì „ì²´ ì€í•˜ í¬ê¸°
        const ex = 0.62;    // íƒ€ì› ì••ì¶•(ê¸°ìš¸ê¸°)
        const tilt = -0.18; // ê¸°ìš¸ê¸°

        const targets = [];

        // ë¹„ìœ¨: ì½”ì–´ 22%, íŒ” 50%, ë³„í˜•ì„± ë§ 20%, í—¤ì¼ë¡œ 8%
        const nCore  = Math.max(120, Math.floor(n * 0.22));
        const nArms  = Math.max(300, Math.floor(n * 0.50));
        const nRing  = Math.max(160, Math.floor(n * 0.20));
        const nHalo  = Math.max(60,  Math.floor(n * 0.08));

        // --- ì½”ì–´ (ì„¸ë¥´ì‹-ish) ---
        for (let i = 0; i < nCore; i++) {
          const a = Math.random() * Math.PI * 2;
          const rr = R * 0.16 * Math.pow(Math.random(), 0.55); // ì¤‘ì‹¬ ë°€ì§‘
          const x = cx + rr * Math.cos(a);
          const y = cy + rr * ex * Math.sin(a);
          targets.push({ x, y, armBias: 0.1, ringBias: 0.0 });
        }

        // --- ë‚˜ì„ íŒ” (ë¡œê·¸ ìŠ¤íŒŒì´ëŸ´ + ë…¸ì´ì¦ˆ + ë¶„ê¸°) ---
        const arms = 3;
        const b = 0.21; // ë¡œê·¸ ìŠ¤íŒŒì´ëŸ´ ê³„ìˆ˜ (r = a * e^{bÎ¸})
        const a0 = R * 0.035;
        const turns = 3.4;
        const thetaMax = turns * Math.PI * 2;
        const perArm = Math.max(200, Math.floor(nArms / arms));

        for (let k = 0; k < arms; k++) {
          const armPhase = (k / arms) * (Math.PI * 2);
          for (let j = 0; j < perArm; j++) {
            const t = j / (perArm - 1);
            let theta = t * thetaMax + armPhase;

            // ë¡œê·¸ ìŠ¤íŒŒì´ëŸ´
            let r = a0 * Math.exp(b * theta);

            // íŒ” ë‘ê»˜/í”ŒëŸ­ì¶”ì—ì´ì…˜ + ë¶„ê¸°
            const width = R * (0.015 + 0.06 * t);
            r += (Math.random() - 0.5) * width;
            if (Math.random() < 0.08 && t > 0.2) {
              // ì‘ì€ ë¶„ì§€(ë¸Œëœì¹˜)
              const dt = (Math.random() - 0.5) * 0.35;
              const dr = (Math.random() - 0.5) * width * 0.7;
              theta += dt; r += dr;
            }

            // ì¢Œí‘œ ë³€í™˜(ê¸°ìš¸ê¸°/íƒ€ì›)
            const ct = Math.cos(theta + tilt);
            const st = Math.sin(theta + tilt);
            const x = cx + r * ct;
            const y = cy + r * ex * st;

            // ìœ íš¨ ë°˜ê²½ ì²´í¬ & ì¶”ê°€ ìƒ˜í”Œ
            if (r < R) {
              targets.push({ x, y, armBias: 1.0, ringBias: 0.0 });
              if (Math.random() < 0.35) {
                const rr = r + (Math.random() - 0.5) * width * 0.8;
                const tt = theta + (Math.random() - 0.5) * 0.25;
                const xx = cx + rr * Math.cos(tt + tilt);
                const yy = cy + rr * ex * Math.sin(tt + tilt);
                if (rr < R) targets.push({ x: xx, y: yy, armBias: 0.9, ringBias: 0.05 });
              }
            }
          }
        }

        // --- ë³„í˜•ì„± ë§ (ì•ˆìª½ ë§/íŒ” ì‚¬ì´, í•‘í¬/ë³´ë¼ ê°•ì¡°) ---
        const ringR = R * 0.58;
        for (let i = 0; i < nRing; i++) {
          let ang = Math.random() * Math.PI * 2;
          // ë§ì˜ ì—˜ë¦½ìŠ¤
          let rr = ringR + (Math.random() - 0.5) * (R * 0.05);
          // ì¼ë¶€ êµ¬ê°„ì€ ì¡°ë°€ (HII belt)
          if ((ang % (Math.PI * 2)) > 1.2 && (ang % (Math.PI * 2)) < 2.1) {
            rr += (Math.random() - 0.5) * (R * 0.03);
          }
          const x = cx + rr * Math.cos(ang + tilt);
          const y = cy + rr * ex * Math.sin(ang + tilt);
          if (Math.hypot(x - cx, (y - cy)/ex) < R) {
            targets.push({ x, y, armBias: 0.4, ringBias: 1.0 });
          }
        }

        // --- í—¤ì¼ë¡œ/ì™¸ê³½ ---
        for (let i = 0; i < nHalo; i++) {
          const ang = Math.random() * Math.PI * 2;
          const rr = R * (0.75 + 0.25 * Math.pow(Math.random(), 0.4));
          const x = cx + rr * Math.cos(ang + tilt);
          const y = cy + rr * ex * Math.sin(ang + tilt);
          targets.push({ x, y, armBias: 0.1, ringBias: 0.0 });
        }

        // ì„±ìš´ í´ë¼ìš°ë“œ (íŒ”/ë§ ë”°ë¼)
        const cloudCount = 22;
        for (let i = 0; i < cloudCount; i++) {
          const base = targets[(Math.random() * targets.length) | 0];
          const rr = Math.random() * (R * 0.08) + R * 0.03;
          const col = Math.random();
          // ë³´ë¼/í•‘í¬/ì²­ë³´ë¼/ì²­ë°± ì•ˆê°œ
          let c1 = 'rgba(255,150,230,0.14)', c2 = 'rgba(160,190,255,0.10)';
          if (col < 0.33) { c1 = 'rgba(250,180,255,0.14)'; c2 = 'rgba(190,210,255,0.10)'; }
          else if (col < 0.66){ c1 = 'rgba(200,170,255,0.14)'; c2 = 'rgba(150,190,255,0.10)'; }
          clouds.push({ x: base.x, y: base.y, r: rr, c1, c2 });
        }

        // Dust lanes(ê°ì‚°ìš©) íŒŒë¼ë¯¸í„° ì¤€ë¹„
        const dust = {
          cx, cy, ex, tilt, R,
          bands: [
            { r: 0.45 * R, w: 0.025 * R },
            { r: 0.52 * R, w: 0.020 * R },
            { r: 0.62 * R, w: 0.022 * R }
          ]
        };

        return { targets, dust, cx, cy, ex, R };
      }

      let galaxyMask = null; // dust/params cache

      function assignGalaxyTargets() {
        const { targets, dust, cx, cy, ex, R } = buildAndromedaTargets(particles.length);
        galaxyMask = { dust, cx, cy, ex, R };

        for (let i = 0; i < particles.length; i++) {
          const t = targets[i % targets.length];
          const pt = particles[i];
          pt.tx = t.x; pt.ty = t.y; pt.reached = false;
          pt.tbx = t.x; pt.tby = t.y;
          // region metadata
          const dx = t.x - cx;
          const dy = (t.y - cy) / (ex || 1);
          const r = Math.hypot(dx, dy);
          pt.rNorm = Math.min(1, r / R);
          pt.armBias = t.armBias;
          pt.ringBias = t.ringBias;
          pt.color = pickStarColorByRegion(pt.rNorm, pt.armBias, pt.ringBias);
          // ì‚¬ì´ì¦ˆ/ë°ê¸° ì‚´ì§ ì¡°ì •
          if (pt.rNorm < 0.18) pt.size *= 1.25;
          else if (pt.armBias > 0.7 && Math.random() < 0.15) pt.size *= 1.35;
        }
        taegeukScale = 1;
      }

      function dustFactor(x, y) {
        // ë§ ëª¨ì–‘ì˜ ì–´ë‘ìš´ ë°´ë“œ(íŒ”ê³¼ ë‚˜ë€íˆ)ì—ì„œ ì‚´ì§ ê°ì‡„
        if (!galaxyMask) return 1;
        const { cx, cy, ex, dust } = galaxyMask;
        const dx = x - cx;
        const dy = (y - cy) / (ex || 1);
        const r = Math.hypot(dx, dy);
        let atten = 1;
        for (const b of dust.bands) {
          const d = Math.abs(r - b.r);
          if (d < b.w) {
            const t = (b.w - d) / b.w;
            atten = Math.min(atten, 1 - 0.35 * (0.6 + 0.4 * t)); // ìµœëŒ€ 35% ê°ì‡ 
          }
        }
        return atten;
      }

      function runParticleShow() {
        particlePhase = 'explode';
        phaseStartTime = performance.now();

        function frame(now) {
          const rect = wrap.getBoundingClientRect();
          const W = rect.width, H = rect.height;
          pctx.clearRect(0, 0, W, H);

          // ë‹¨ê³„ ì „í™˜
          if (particlePhase === 'explode' && now - phaseStartTime >= 2000) {
            assignGalaxyTargets(); particlePhase = 'morph'; phaseStartTime = now;
          } else if (particlePhase === 'morph') {
            const allReached = particles.every(pt => pt.reached);
            if (allReached || (now - phaseStartTime) > 2000) { particlePhase = 'hold'; phaseStartTime = now; }
          } else if (particlePhase === 'hold' && now - phaseStartTime >= 900) {
            particlePhase = 'shrink'; phaseStartTime = now;
          } else if (particlePhase === 'shrink') {
            const t = Math.min(1, (now - phaseStartTime) / SHRINK_DURATION_MS);
            taegeukScale = 1 - (1 - TAEGEUK_FINAL_SCALE) * easeInOutCubic(t);
            if (t >= 1) {
              welcome.classList.remove("welcome-glow");
              for (const pt of particles) {
                const ang = Math.random() * Math.PI * 2; const spd = 0.05 + Math.random() * 0.1;
                pt.vx = Math.cos(ang) * spd; pt.vy = Math.sin(ang) * spd; pt.reached = false;
              }
              particlePhase = 'disperse'; phaseStartTime = now;
            }
          }

          // === ì„±ìš´ ë¨¼ì € ë Œë”(ë°ì€ í•©ì„±) ===
          if (particlePhase !== 'explode') {
            pctx.save();
            pctx.globalCompositeOperation = 'lighter';
            for (const c of clouds) {
              const grad = pctx.createRadialGradient(c.x, c.y, c.r * 0.1, c.x, c.y, c.r);
              grad.addColorStop(0, c.c1);
              grad.addColorStop(1, c.c2);
              pctx.fillStyle = grad;
              pctx.beginPath();
              pctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
              pctx.fill();
            }
            pctx.restore();
          }

          // === ë³„ ì—…ë°ì´íŠ¸/ë Œë” ===
          let anyAlive = false;
          for (const pt of particles) {
            if (pt.alpha <= 0) continue; anyAlive = true;

            if (particlePhase === 'explode') {
              pt.vx *= 0.985; pt.vy *= 0.985;
              pt.vx += (Math.random() - 0.5) * 0.02; pt.vy += (Math.random() - 0.5) * 0.02;
              pt.alpha = Math.max(0.8, pt.alpha - 0.0006);
            } else if (particlePhase === 'morph') {
              if (pt.tx != null) {
                const dx = pt.tx - pt.x, dy = pt.ty - pt.y;
                pt.vx = pt.vx * 0.82 + dx * 0.06; pt.vy = pt.vy * 0.82 + dy * 0.06;
                if (Math.hypot(dx, dy) < 1.6) { pt.x = pt.tx; pt.y = pt.ty; pt.vx = pt.vy = 0; pt.reached = true; }
              }
              pt.alpha = Math.min(1, pt.alpha + 0.01);
            } else if (particlePhase === 'hold') {
              const wob = (now - phaseStartTime) * 0.004;
              pt.x += Math.sin(wob + (pt.tx || pt.x) * 0.01) * 0.06;
              pt.y += Math.cos(wob + (pt.ty || pt.y) * 0.01) * 0.06;
              pt.alpha = 1;
            } else if (particlePhase === 'shrink') {
              const sx = tgCenterX + (pt.tbx - tgCenterX) * taegeukScale;
              const sy = tgCenterY + (pt.tby - tgCenterY) * taegeukScale;
              const dx = sx - pt.x, dy = sy - pt.y;
              pt.vx = pt.vx * 0.86 + dx * 0.045;
              pt.vy = pt.vy * 0.86 + dy * 0.045;
              pt.alpha = 1;
            } else if (particlePhase === 'disperse') {
              pt.vx *= 0.995; pt.vy *= 0.995; pt.alpha -= 0.0018;
            }

            pt.x += pt.vx; pt.y += pt.vy;
          }

          if (particlePhase === 'disperse' && !anyAlive) { body.classList.add('show-background'); particlePhase = 'done'; return; }

          // ë“œë¡œì‰ (íŠ¸ìœ™í´ + ë”ìŠ¤íŠ¸ ê°ì‡„ + í•˜ì´ë¼ì´íŠ¸ ìŠ¤íŒŒí´)
          pctx.globalCompositeOperation = 'source-over';
          pctx.shadowBlur = 10; pctx.shadowOffsetX = 0; pctx.shadowOffsetY = 0;

          for (const pt of particles) {
            if (pt.alpha <= 0) continue;

            // íŠ¸ìœ™í´
            const twinkle = 0.85 + 0.15 * Math.sin(now * 0.006 * pt.tw + pt.twPhase);

            // ë”ìŠ¤íŠ¸ ê°ì‡„
            const dustAtt = dustFactor(pt.x, pt.y);

            pctx.globalAlpha = Math.max(0, Math.min(1, pt.alpha * twinkle * dustAtt));
            pctx.shadowColor = pt.color; pctx.fillStyle = pt.color;
            pctx.beginPath(); pctx.arc(pt.x, pt.y, pt.size, 0, Math.PI * 2); pctx.fill();

            if (Math.random() < 0.0025) {
              pctx.globalAlpha *= 0.6;
              pctx.beginPath(); pctx.arc(pt.x, pt.y, pt.size * 2.2, 0, Math.PI * 2); pctx.fill();
            }
          }

          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      function onWheel(e) {
        if (isFinalized) return;
        e.preventDefault();
        const dy = e.deltaY;
        if (p < 0.5) { setProgress(p + dy * 0.0018); startAutoAnimation(); }
        else if (!autoAnimating) { startAutoAnimation(); }
      }
      function onTouchMove(e) {
        if (isFinalized) return;
        const touch = e.touches[0]; const currentY = touch.clientY;
        if (typeof onTouchMove.lastY !== "undefined") {
          const dy = onTouchMove.lastY - currentY;
          if (p < 0.5) { setProgress(p + dy * 0.0018 * 2); if (p >= 0.5) startAutoAnimation(); }
          else if (!autoAnimating && dy > 0) { startAutoAnimation(); }
        }
        onTouchMove.lastY = currentY;
      }
      function onTouchEnd() { if (!isFinalized) onTouchMove.lastY = undefined; }

      window.addEventListener('resize', resizeParticleCanvas);
      window.addEventListener('wheel', onWheel, { passive: false });
      window.addEventListener('touchstart', (e) => { onTouchMove.lastY = e.touches[0].clientY; });
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', onTouchEnd);

      resizeParticleCanvas();
      setProgress(0);

      /* ============================================================
         ğŸ¸ í˜„ ì‹œë®¬ë ˆì´í„° â€” ê¸°ì¡´ ê·¸ëŒ€ë¡œ
         ============================================================ */
      const lineCanvas = document.getElementById('lineViz');
      const lctx = lineCanvas.getContext('2d');

      const LINE_THICK = 8;
      const LINE_H_DESKTOP = 72;
      const LINE_H_MOBILE  = 96;
      const V_PAD_VH = 18;

      let tension    = 0.8;
      let loss       = 0.986;
      let SUBSTEPS   = 10;
      let radiusPx   = 80;
      let handPower  = 0.95;
      const K_MOUSE  = 1.5;
      const C_MOUSE  = 0.08;
      const HARD_FACTOR = 0.4;
      const RELEASE_KICK = 0.25;

      let numPoints = 240;
      let dx = 1, invDX2 = 1;
      let initialY = 0;
      let string = [];
      let MAX_PULL = 0;

      class StringPoint { constructor(x, y){ this.x=x; this.y=y; this.oldY=y; this.acc=0; } }

      let vanishBaseWidth = null;

      function placeLineViz() {
        const Wwin = window.innerWidth;
        const Hwin = window.innerHeight;
        const isMobile = window.matchMedia("(max-width: 768px)").matches;

        if (isMobile) {
          const desiredWidth = Math.round(Wwin * 0.9);
          const midY   = Math.round(Hwin / 2);
          const cssHeightBase = LINE_H_MOBILE;
          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = cssHeightBase + padPx * 2;
          const left = Math.round((Wwin - desiredWidth) / 2);

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = desiredWidth + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(desiredWidth  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(desiredWidth, cssHeight);
          if (vanishBaseWidth === null) vanishBaseWidth = desiredWidth;
        } else {
          const marsLine = document.getElementById('mars')?.parentElement || null;
          const keysLine = document.getElementById('keys')?.parentElement || null;
          let left   = Math.round(Wwin * 0.2);
          let width  = Math.round(Wwin * 0.6);
          let midY   = Math.round(Hwin / 2);
          try {
            if (marsLine && keysLine) {
              const wrapRect = wrap.getBoundingClientRect();
              const wrapCS = getComputedStyle(wrap);
              const padLeft = parseFloat(wrapCS.paddingLeft) || 0;
              const additionalPadding = 250;

              left = Math.round(wrapRect.left + padLeft + additionalPadding);
              const rightLimit = Math.min(keysLine.getBoundingClientRect().right, wrapRect.right - padLeft * 0.25);
              width = Math.max(260, Math.round(rightLimit - left));

              const marsBottom = marsLine.getBoundingClientRect().bottom;
              const keysTop = keysLine.getBoundingClientRect().top;
              midY = Math.round((marsBottom + keysTop) / 2);
            }
          } catch(e) {}

          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = LINE_H_DESKTOP + padPx * 2;
          width = Math.min(width, Wwin);
          left  = Math.max(0, Math.min(left, Wwin - width));

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = width + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(width  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(width, cssHeight);
          if (vanishBaseWidth === null) vanishBaseWidth = width;
        }
      }

      function setupString(W, H){
        numPoints = Math.max(160, Math.min(360, Math.round(W / 4)));
        string = [];
        for (let i=0;i<numPoints;i++){
          const x = (i/(numPoints-1)) * W;
          string.push(new StringPoint(x, H/2));
        }
        initialY = H/2;
        dx = W / (numPoints - 1);
        invDX2 = 1 / (dx*dx);
      }

      const mouse = { active:false, x:0, y:0 };
      function getPos(e){
        const r = lineCanvas.getBoundingClientRect();
        const cx = (e.clientX??e.touches?.[0].clientX) - r.left;
        const cy = (e.clientY??e.touches?.[0].clientY) - r.top;
        return {x:cx, y:cy};
      }

      lineCanvas.addEventListener('mousedown', e=>{
        const {x,y} = getPos(e); mouse.active = true; mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mousemove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mouseup', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      lineCanvas.addEventListener('touchstart', e=>{
        const {x,y} = getPos(e); e.preventDefault(); mouse.active = true; mouse.x = x; mouse.y = y;
      }, {passive:false});
      lineCanvas.addEventListener('touchmove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); e.preventDefault(); mouse.x = x; mouse.y = y;
      }, {passive:false});
      window.addEventListener('touchend', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      function hannWeight(dist, R){ if (dist >= R) return 0; const r = dist / R; return 0.5 * (1 + Math.cos(Math.PI * r)); }

      function applyMouseForce(){
        if (!mouse.active) return;
        let pullY = mouse.y - initialY;
        if (Math.abs(pullY) > MAX_PULL) pullY = Math.sign(pullY) * MAX_PULL;

        const FcapBase = 12;
        const Fcap = FcapBase / (1 + HARD_FACTOR * tension);

        for (let i = 1; i < numPoints - 1; i++) {
          const p = string[i];
          const distX = Math.abs(p.x - mouse.x);
          const w = hannWeight(distX, radiusPx);
          if (w <= 0) continue;

          const vel = p.y - p.oldY;
          const Fspring = K_MOUSE * (initialY + pullY - p.y);
          const Fdamp   = -C_MOUSE * vel;
          let F = (Fspring + Fdamp) * w;

          if (F >  Fcap * w) F =  Fcap * w;
          if (F < -Fcap * w) F = -Fcap * w;

          p.acc += F;
        }
      }

      function physicsStep(){
        for (let i=1;i<numPoints-1;i++){
          const prev = string[i-1].y, curr = string[i].y, next = string[i+1].y;
          const lap = (prev - 2*curr + next) * invDX2;
          string[i].acc = tension * lap;
        }
        applyMouseForce();

        string[0].acc = 0; string[numPoints-1].acc = 0;

        for (let i=1;i<numPoints-1;i++){
          const p = string[i];
          const tempY = p.y;
          p.y = p.y*2 - p.oldY + p.acc;
          p.oldY = tempY;
          p.y = initialY + (p.y - initialY) * loss;
        }
        string[0].y = string[0].oldY = initialY;
        string[numPoints-1].y = string[numPoints-1].oldY = initialY;
      }

      function drawString(){
        const rect = lineCanvas.getBoundingClientRect();
        const Wdraw = Math.max(0, Math.round(rect.width));
        const Hdraw = Math.max(0, Math.round(rect.height));
        if (!Wdraw || !Hdraw) return;

        lctx.clearRect(0,0,Wdraw,Hdraw);

        const smoothstep = (x) => x < 0 ? 0 : x > 1 ? 1 : x * x * (3 - 2 * x);
        const f = (p < VANISH_START) ? 0 : smoothstep((p - VANISH_START) / (1 - VANISH_START));
        const thickness = Math.max(0.6, LINE_THICK * (1 - 0.9 * f));
        lctx.globalAlpha = 1 - f;

        lctx.beginPath();
        lctx.strokeStyle = '#ffffff';
        lctx.lineWidth = thickness;
        lctx.lineCap = 'round';
        lctx.lineJoin = 'round';

        const baseW = (vanishBaseWidth || Wdraw);
        const baseC = baseW / 2;
        const scaleX = Wdraw / baseW;
        const mapX = x => baseC + (x - baseC) * scaleX;

        lctx.moveTo(mapX(string[0].x), string[0].y);
        for (let i=1;i<numPoints-2;i++){
          const xc = mapX((string[i].x + string[i+1].x)/2);
          const yc = (string[i].y + string[i+1].y)/2;
          lctx.quadraticCurveTo(mapX(string[i].x), string[i].y, xc, yc);
        }
        lctx.quadraticCurveTo(mapX(string[numPoints-2].x), string[numPoints-2].y, mapX(string[numPoints-1].x), string[numPoints-1].y);
        lctx.stroke();

        lctx.globalAlpha = 1;
      }

      function animateString(){
        for (let s=0; s<SUBSTEPS; s++) physicsStep();
        drawString();
        if(!isFinalized) requestAnimationFrame(animateString);
      }

      const ro = new ResizeObserver(() => placeLineViz());
      ro.observe(document.body);
      ro.observe(document.getElementById('brand'));
      window.addEventListener('resize', placeLineViz);
      window.addEventListener('orientationchange', placeLineViz);
      if (document.fonts && document.fonts.ready) { document.fonts.ready.then(placeLineViz); }

      placeLineViz();
      requestAnimationFrame(animateString);
    })();
  </script>
</body>
</html>
