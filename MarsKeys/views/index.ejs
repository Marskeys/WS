<!DOCTYPE html>
<% const isKorean = (lang || '').toLowerCase().startsWith('ko'); %>
<html lang="<%= lang %>">
  <%- include('partials/head') %>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>
    <% if (isSearch) { %>
      <%= locale.search_results_for %>: <%= searchKeyword %>
    <% } else if (selectedCategory) { %>
      <%= selectedCategory %>
    <% } else { %>
      <%= locale.marskeys_title %>
    <% } %>
  </title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Michroma&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <% if (isKorean) { %>
    <link href="https://fonts.googleapis.com/css2?family=Yeon+Sung&display=swap" rel="stylesheet">
  <% } %>

  <style>
    :root {
      --bg: #0e1016;
      --text: #eef2f8;
      --muted: #9aa3b2;
      --fill-int: 0%;

      /* ===== 🎇 Galaxy text palette (은하 텍스처) ===== */
      --galaxy-text:
        /* 작은 별들 */
        radial-gradient(1.2px 1.2px at 8% 12%, rgba(255,255,255,.95), transparent 60%),
        radial-gradient(1.2px 1.2px at 18% 64%, rgba(255,248,220,.9), transparent 60%),
        radial-gradient(1.4px 1.4px at 32% 22%, rgba(194,214,255,.95), transparent 60%),
        radial-gradient(1.0px 1.0px at 44% 78%, rgba(255,229,170,.9), transparent 60%),
        radial-gradient(1.6px 1.6px at 58% 36%, rgba(240,245,255,1), transparent 60%),
        radial-gradient(1.1px 1.1px at 70% 18%, rgba(190,210,255,.9), transparent 60%),
        radial-gradient(1.2px 1.2px at 80% 70%, rgba(255,246,230,.9), transparent 60%),
        radial-gradient(1.0px 1.0px at 92% 42%, rgba(255,255,255,.9), transparent 60%),
        /* 중간 별들 */
        radial-gradient(2px 2px at 26% 46%, rgba(255,255,255,.85), transparent 60%),
        radial-gradient(2px 2px at 64% 54%, rgba(176,198,255,.85), transparent 60%),
        radial-gradient(2.2px 2.2px at 84% 28%, rgba(255,236,190,.9), transparent 60%),
        radial-gradient(2px 2px at 38% 82%, rgba(210,226,255,.9), transparent 60%),
        /* 은하의 안개빛 (Nebula-ish) */
        conic-gradient(from 140deg at 50% 50%,
          rgba(220,230,255,.28) 0%,
          rgba(170,190,255,.34) 18%,
          rgba(255,232,190,.22) 36%,
          rgba(255,255,255,.22) 48%,
          rgba(180,205,255,.28) 66%,
          rgba(250,210,255,.22) 82%,
          rgba(230,238,255,.25) 100%);
    }

    * { box-sizing: border-box }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow-x: hidden;
      overflow-y: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body.lang-ko #welcome { font-family: 'Montserrat', 'Michroma', system-ui, sans-serif; font-weight: 400; }

    body.show-background {
      background-image: url('https://images.unsplash.com/photo-1502126428-175f0881ed53?q=80&w=2670&auto=format&fit=crop');
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
      background-attachment: fixed;
      transition: background-image 2s ease;
    }

    .wrap { position: relative; min-height: 100svh; padding: 5vw; overflow: visible; }

    .brand { margin: 0; line-height: 1; font-family: "Michroma", system-ui, sans-serif; position: relative; z-index: 40; }

    .brand-line { display: block; font-size: clamp(56px, min(14vw, 28vh), 200px); line-height: 1.06; padding-bottom: 0.18em; overflow: visible; position: relative; }
    .brand-line+.brand-line { margin-top: -0.32em; }

    /* ===== 🔤 텍스트: 기존 채움 로직 유지하되 배경을 '은하'로 교체 ===== */
    .ink{
      display:inline-block; color:transparent; -webkit-text-fill-color:transparent;
      -webkit-background-clip:text; background-clip:text;
      background-repeat:no-repeat,no-repeat;
      background-size:var(--fill-int) 100%, 100% 100%;
      background-image:var(--galaxy-text), linear-gradient(#fff,#fff);
      letter-spacing:0; padding-bottom:.28em; transform:translateZ(0);
      /* 은하 텍스처에 아주 미세한 패닝으로 살아있는 느낌 */
      animation: galaxy-pan 30s linear infinite;
    }
    @keyframes galaxy-pan {
      0%   { background-position: 0 0, center; }
      50%  { background-position: -2% -1%, center; }
      100% { background-position: 0 0, center; }
    }

    .tagline { font-size: clamp(16px, 2.6vw, 28px); font-weight: 600; margin: 1rem 0 0; color: var(--muted); position: relative; transition: color .55s ease; will-change: color; }
    .tagline.shine-to-white { overflow: visible; }
    .tagline.shine-to-white::before{
      content: attr(data-text); position: absolute; inset: 0; pointer-events: none;
      color: transparent; -webkit-text-fill-color: transparent;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.16) 32%, rgba(255,255,255,.85) 50%, rgba(255,255,255,.16) 68%, rgba(255,255,255,0) 100%);
      -webkit-background-clip: text; background-clip: text;
      transform: translateX(-120%) skewX(-18deg); filter: blur(.3px);
      animation: shine-sweep 900ms cubic-bezier(.2,.7,.2,1) forwards;
    }
    .tagline.to-white { color: #fff; }
    @keyframes shine-sweep { to { transform: translateX(120%) skewX(-18deg); } }

    #counter {
      position: absolute; right: 5vw; bottom: clamp(16px, 6vh, 48px); text-align: right;
      font-size: clamp(28px, min(7vw, 10vh), 96px); font-family: "Michroma", system-ui, sans-serif;
      font-weight: 900; color: white; user-select: none; pointer-events: none; transition: opacity .6s ease; z-index: 40; margin: 0;
    }

    #particleCanvas { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }

    /* 🎸 현 시뮬레이터 캔버스 */
    #lineViz { position: fixed; pointer-events: auto; z-index: 55; }
    #welcome {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) scale(0.86);
      opacity: 0; font-size: clamp(48px, 10vw, 130px); font-family: 'Montserrat', system-ui, sans-serif; color: white;
      letter-spacing: 0.01em; max-width: 92vw; white-space: nowrap;
      transition: opacity 1s ease, transform 1s cubic-bezier(.2, .7, .2, 1), text-shadow 1s ease-out;
      will-change: opacity, transform, text-shadow; pointer-events: none; z-index: 60; text-shadow: 0 0 0 transparent;
    }
    #welcome.visible { opacity: 1; transform: translate(-50%, -50%) scale(1.22); }
    #welcome.welcome-glow { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.6), 0 0 60px rgba(255, 255, 255, 0.4); }

    .scrollable-content { padding: 0 5vw 6rem; text-align: center; display: none; max-width: 1200px; margin: 0 auto; position: relative; z-index: 10; }
    .scrollable-content p { max-width: 800px; margin: 0 auto 1.5rem; line-height: 1.8; color: var(--muted); font-size: clamp(14px, 2vw, 18px); }
    .scrollable-content .temp-box { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 2rem; margin: 2rem auto; max-width: 900px; }

    @media (max-width: 768px) {
      .brand-line { line-height: 1.08; padding-bottom: 0.16em; }
      .brand-line+.brand-line { margin-top: -0.26em; }
    }
  </style>
</head>

<body class="<%= isKorean ? 'lang-ko' : '' %>">
  <main class="wrap" id="wrap">
    <canvas id="particleCanvas"></canvas>
    <canvas id="lineViz"></canvas>

    <h1 class="brand" id="brand">
      <span class="brand-line" data-c="red"><span class="ink" id="mars"><%= locale.mars_keys.split(' ')[0] %></span></span>
      <span class="brand-line" data-c="blue"><span class="ink" id="keys"><%= locale.mars_keys.split(' ')[1] %></span></span>
    </h1>

    <p class="tagline shine-to-white" data-text="<%= locale.game_music_studio %>"><%= locale.game_music_studio %></p>

    <div id="counter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">0%</div>
    <div id="welcome"><%= locale.welcome %></div>
  </main>

  <div id="scrollContent" class="scrollable-content">
    <p><%= locale.game_music_studio %> <%= locale.marskeys_title %>에 오신 것을 환영합니다...</p>
    <div class="temp-box">
      <h3>우리의 서비스</h3>
      <p>게임 OST, SFX, VO, 인터랙티브 음악 시스템...</p>
    </div>
    <div class="temp-box">
      <h3>포트폴리오</h3>
      <p>RPG, SF 어드벤처 등...</p>
    </div>
    <div class="temp-box">
      <h3>문의</h3>
      <p>협업 및 프로젝트 문의는 언제든지 환영합니다.</p>
    </div>
    <div style="height:60vh;"></div>
    <div class="temp-box">
      <p>마지막 임시 콘텐츠</p>
    </div>
  </div>

  <script>
    (function() {
      const html = document.documentElement;
      const body = document.body;
      const wrap = document.getElementById('wrap');
      const counterEl = document.getElementById("counter");
      const welcome = document.getElementById("welcome");
      const scrollContent = document.getElementById("scrollContent");
      const particleCanvas = document.getElementById('particleCanvas');
      const pctx = particleCanvas.getContext('2d');

      const tagline = document.querySelector('.tagline');
      tagline.addEventListener('animationend', (event) => {
        if (event.animationName === 'shine-sweep') {
            tagline.classList.add('to-white');
        }
      });

      // Progress
      let p = 0;
      let autoAnimating = false,
          isFinalized = false,
          particlesGenerated = false;
      const VANISH_START = 0.5;

      const IS_MOBILE = window.matchMedia("(max-width: 768px)").matches;

      // Particles
      let particles = [];
      const MAX_PARTICLES = IS_MOBILE ? 8000 : 3000;
      let particlePhase = 'idle';
      let phaseStartTime = 0;

      // 🔻 은하(안드로메다) 축소 관련 전역 (기존 태극 변수 재활용)
      let tgCenterX = 0, tgCenterY = 0;
      let taegeukScale = 1; // 이름 유지 (기존 로직 호환)
      const TAEGEUK_FINAL_SCALE = 0.38;     // 최종 축소 비율
      const SHRINK_DURATION_MS = 2600;      // 천~천히 줄어드는 시간(ms)
      const easeInOutCubic = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;

      function resizeParticleCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = wrap.getBoundingClientRect();
        particleCanvas.width = Math.floor(rect.width * dpr);
        particleCanvas.height = Math.floor(rect.height * dpr);
        particleCanvas.style.width = rect.width + 'px';
        particleCanvas.style.height = rect.height + 'px';
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.clearRect(0, 0, rect.width, rect.height);
      }

      function setProgress(v) {
        p = Math.max(0, Math.min(1, v));
        const pct = Math.round(p * 100);
        html.style.setProperty('--fill-int', pct + '%');
        if (!isFinalized) {
          counterEl.textContent = pct + "%";
          counterEl.setAttribute('aria-valuenow', String(pct));
        }
        if (p >= 1 && !particlesGenerated && !isFinalized) {
          generateParticles();
          fadeOutText();
          showWelcome();
          runParticleShow();
        }
      }

      function startAutoAnimation() {
        if (autoAnimating || isFinalized) return;
        autoAnimating = true;
        function step() {
          if (p < 1) {
            p = Math.min(1, p + 0.005);
            setProgress(p);
            requestAnimationFrame(step);
          } else {
            autoAnimating = false;
          }
        }
        step();
      }

      function drawTextToCanvas(text, fontSize, fontFamily) {
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');
        offCtx.font = `${fontSize}px ${fontFamily}`;
        const metrics = offCtx.measureText(text);
        const actualHeight = (metrics.actualBoundingBoxAscent || fontSize) + (metrics.actualBoundingBoxDescent || fontSize * 0.25);
        const width = Math.ceil(metrics.width);
        offCanvas.width = Math.ceil(width);
        offCanvas.height = Math.ceil(actualHeight);
        offCtx.font = `${fontSize}px ${fontFamily}`;
        offCtx.fillStyle = 'white';
        offCtx.textBaseline = 'top';
        offCtx.fillText(text, 0, 0);
        return { canvas: offCanvas };
      }

      function computeStepForTarget(canvas, target) {
        const area = canvas.width * canvas.height;
        const estGlyphArea = area * 0.45;
        return Math.max(3, Math.floor(Math.sqrt(estGlyphArea / Math.max(1, target))));
      }

      // 🌌 별 색상 팔레트
      function pickStarColor(){
        const r = Math.random();
        if (r < 0.55) return 'rgba(255,255,255,0.95)';        // white
        if (r < 0.75) return 'rgba(176,198,255,0.95)';        // pale blue
        if (r < 0.90) return 'rgba(255,229,170,0.95)';        // warm yellow
        return 'rgba(210,226,255,1)';                          // crisp blue-white
      }

      function generateParticles() {
        particlesGenerated = true;
        particles.length = 0;
        const wrapRect = wrap.getBoundingClientRect();
        const lines = [
          { el: document.getElementById('mars').parentElement, textEl: document.getElementById('mars') },
          { el: document.getElementById('keys').parentElement, textEl: document.getElementById('keys') }
        ];
        const centerX = wrapRect.width * 0.5;
        const centerY = wrapRect.height * 0.5;

        const TARGET_PER_LINE = IS_MOBILE ? 4000 : 1500;

        lines.forEach(({ el, textEl }) => {
          const rect = el.getBoundingClientRect();
          const style = getComputedStyle(textEl);
          const fontSize = parseFloat(style.fontSize);
          const fontFamily = style.fontFamily;
          const { canvas } = drawTextToCanvas(textEl.textContent, fontSize, fontFamily);
          const ctx = canvas.getContext('2d');
          const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = img.data;

          const STEP = computeStepForTarget(canvas, TARGET_PER_LINE);

          for (let y = 0; y < canvas.height; y += STEP) {
            for (let x = 0; x < canvas.width; x += STEP) {
              const idx = (y * canvas.width + x) * 4;
              if (data[idx + 3] > 128) {
                const px = rect.left - wrapRect.left + x;
                const py = rect.top - wrapRect.top + y;

                const dx = px - centerX;
                const dy = py - centerY;
                const dist = Math.hypot(dx, dy) + 0.0001;
                const boost = 0.6 + Math.random() * 1.1;

                particles.push({
                  x: px, y: py,
                  vx: (Math.random() - 0.5) * 0.6 + (dx / dist) * boost,
                  vy: (Math.random() - 0.5) * 0.6 + (dy / dist) * boost,
                  alpha: 1,
                  color: pickStarColor(),      // ⭐ 개별 별 색상
                  size: 1.2 + Math.random() * 1.3,
                  tw: 0.5 + Math.random() * 0.8,
                  twPhase: Math.random() * Math.PI * 2,
                  tx: null, ty: null, reached: false,
                  tbx: null, tby: null
                });
              }
            }
          }
        });

        if (particles.length > (IS_MOBILE ? 8000 : 3000)) {
          const cap = IS_MOBILE ? 8000 : 3000;
          const sampled = [];
          for (let i = 0; i < cap; i++) sampled.push(particles[(Math.random() * particles.length) | 0]);
          particles = sampled;
        }
      }

      function fadeOutText() {
        document.querySelectorAll('.ink').forEach(el => {
          el.style.transition = 'opacity .3s ease';
          el.style.opacity = '0';
        });
      }

      function showWelcome() {
        setTimeout(() => { counterEl.style.opacity = 0; }, 350);
        setTimeout(() => { welcome.classList.add("visible"); welcome.classList.add("welcome-glow"); }, 2000);
        setTimeout(() => { scrollContent.style.display = "block"; isFinalized = true; body.style.overflowY = "auto"; }, 1500);
      }

      /* === 🌌 안드로메다 형태 타깃 만들기 ===
         - 타원형 밝은 코어 + 2~3개 나선팔(Archimedean spiral)
         - 파티클 수에 맞게 샘플링 */
      function buildGalaxyTargets(n) {
        const rect = wrap.getBoundingClientRect();
        const cx = rect.width * 0.5, cy = rect.height * 0.5;
        tgCenterX = cx; tgCenterY = cy;

        const R = Math.min(rect.width, rect.height) * 0.36;
        const targets = [];

        // 코어 (bulge) — 타원 분포
        const coreCount = Math.max(200, Math.floor(n * 0.18));
        for (let i = 0; i < coreCount; i++) {
          const a = Math.random() * Math.PI * 2;
          const r = R * 0.12 * Math.pow(Math.random(), 0.6); // 중심에 더 조밀
          const ex = 0.75; // y를 조금 찌부
          targets.push({ x: cx + r * Math.cos(a), y: cy + r * ex * Math.sin(a) });
        }

        // 나선팔
        const arms = 3; // 2~3 중 택
        const turns = 3.2; // 감기는 횟수
        const perArm = Math.max(200, Math.floor((n - coreCount) / arms));
        const thetaMax = turns * Math.PI * 2;
        const b = R / thetaMax; // r = b * theta (a≈0)

        for (let k = 0; k < arms; k++) {
          const armPhase = (k / arms) * (Math.PI * 2);
          for (let j = 0; j < perArm; j++) {
            const t = j / (perArm - 1);
            let theta = t * thetaMax + armPhase;

            // 팔의 퍼짐 및 노이즈
            let r = b * theta + (Math.random() - 0.5) * (R * 0.02 + R * 0.06 * (t));
            const wobble = (Math.random() - 0.5) * 0.18;
            theta += wobble;

            // 타원 압축 + 회전 기울기 살짝
            const tilt = -0.15; // 은하 기울기
            const ex = 0.62;    // 세로 타원비
            const cosT = Math.cos(theta + tilt);
            const sinT = Math.sin(theta + tilt);

            const x = cx + r * cosT;
            const y = cy + r * ex * sinT;

            targets.push({ x, y });

            // 밀도 보정: 중심/중간에 약간 더
            if (Math.random() < 0.35) {
              const rr = r + (Math.random() - 0.5) * (R * 0.03);
              const tt = theta + (Math.random() - 0.5) * 0.2;
              const xx = cx + rr * Math.cos(tt + tilt);
              const yy = cy + rr * ex * Math.sin(tt + tilt);
              targets.push({ x: xx, y: yy });
            }
          }
        }

        // 총량 맞추기
        while (targets.length < n) {
          // 외곽 성긴 디스크 채우기
          const a = Math.random() * Math.PI * 2;
          const r = R * (0.25 + 0.75 * Math.pow(Math.random(), 0.7));
          const ex = 0.62;
          targets.push({ x: cx + r * Math.cos(a), y: cy + r * ex * Math.sin(a) });
        }
        if (targets.length > n) targets.length = n;

        // 셔플
        for (let i = targets.length - 1; i > 0; i--) {
          const j = (Math.random() * (i + 1)) | 0;
          [targets[i], targets[j]] = [targets[j], targets[i]];
        }
        return targets;
      }

      function assignGalaxyTargets() {
        const targets = buildGalaxyTargets(particles.length);
        for (let i = 0; i < particles.length; i++) {
          const t = targets[i];
          const pt = particles[i];
          pt.tx = t.x; pt.ty = t.y; pt.reached = false;
          pt.tbx = t.x; pt.tby = t.y; // 축소 기준
        }
        taegeukScale = 1; // 시작 크기
      }

      function runParticleShow() {
        particlePhase = 'explode';
        phaseStartTime = performance.now();

        function frame(now) {
          const rect = wrap.getBoundingClientRect();
          const W = rect.width, H = rect.height;
          pctx.clearRect(0, 0, W, H);

          // 단계 전환
          if (particlePhase === 'explode' && now - phaseStartTime >= 2000) {
            assignGalaxyTargets(); particlePhase = 'morph'; phaseStartTime = now;
          } else if (particlePhase === 'morph') {
            const allReached = particles.every(pt => pt.reached);
            if (allReached || (now - phaseStartTime) > 1800) { particlePhase = 'hold'; phaseStartTime = now; }
          } else if (particlePhase === 'hold' && now - phaseStartTime >= 900) {
            // ✅ 은하 완성 후 "천천히 축소"
            particlePhase = 'shrink'; phaseStartTime = now;
          } else if (particlePhase === 'shrink') {
            const t = Math.min(1, (now - phaseStartTime) / SHRINK_DURATION_MS);
            taegeukScale = 1 - (1 - TAEGEUK_FINAL_SCALE) * easeInOutCubic(t);
            if (t >= 1) {
              // 축소 끝 → 분산
              welcome.classList.remove("welcome-glow");
              for (const pt of particles) {
                const ang = Math.random() * Math.PI * 2; const spd = 0.05 + Math.random() * 0.1;
                pt.vx = Math.cos(ang) * spd; pt.vy = Math.sin(ang) * spd; pt.reached = false;
              }
              particlePhase = 'disperse'; phaseStartTime = now;
            }
          }

          let anyAlive = false;
          for (const pt of particles) {
            if (pt.alpha <= 0) continue; anyAlive = true;

            if (particlePhase === 'explode') {
              pt.vx *= 0.985; pt.vy *= 0.985; pt.vx += (Math.random() - 0.5) * 0.02; pt.vy += (Math.random() - 0.5) * 0.02; pt.alpha = Math.max(0.8, pt.alpha - 0.0006);
            } else if (particlePhase === 'morph') {
              if (pt.tx != null) {
                const dx = pt.tx - pt.x, dy = pt.ty - pt.y;
                pt.vx = pt.vx * 0.82 + dx * 0.06; pt.vy = pt.vy * 0.82 + dy * 0.06;
                if (Math.hypot(dx, dy) < 1.6) { pt.x = pt.tx; pt.y = pt.ty; pt.vx = pt.vy = 0; pt.reached = true; }
              }
              pt.alpha = Math.min(1, pt.alpha + 0.01);
            } else if (particlePhase === 'hold') {
              const wob = (now - phaseStartTime) * 0.004;
              pt.x += Math.sin(wob + (pt.tx || pt.x) * 0.01) * 0.06;
              pt.y += Math.cos(wob + (pt.ty || pt.y) * 0.01) * 0.06;
              pt.alpha = 1;
            } else if (particlePhase === 'shrink') {
              // 🔽 은하 중심으로 타깃을 점차 안쪽으로 이동
              const sx = tgCenterX + (pt.tbx - tgCenterX) * taegeukScale;
              const sy = tgCenterY + (pt.tby - tgCenterY) * taegeukScale;
              const dx = sx - pt.x, dy = sy - pt.y;
              pt.vx = pt.vx * 0.86 + dx * 0.045;
              pt.vy = pt.vy * 0.86 + dy * 0.045;
              pt.alpha = 1;
            } else if (particlePhase === 'disperse') {
              pt.vx *= 0.995; pt.vy *= 0.995; pt.alpha -= 0.0018;
            }

            pt.x += pt.vx; pt.y += pt.vy;
          }

          if (particlePhase === 'disperse' && !anyAlive) { body.classList.add('show-background'); particlePhase = 'done'; return; }

          // ⭐ 드로잉 (개별 별 색상 + 깜빡임)
          pctx.globalCompositeOperation = 'source-over';
          pctx.shadowBlur = 10; pctx.shadowOffsetX = 0; pctx.shadowOffsetY = 0;

          for (const pt of particles) {
            if (pt.alpha <= 0) continue;
            const twinkle = 0.8 + 0.2 * Math.sin(now * 0.006 * pt.tw + pt.twPhase);
            pctx.globalAlpha = Math.max(0, Math.min(1, pt.alpha * twinkle));
            pctx.shadowColor = pt.color; pctx.fillStyle = pt.color;
            pctx.beginPath(); pctx.arc(pt.x, pt.y, pt.size, 0, Math.PI * 2); pctx.fill();

            // 드물게 밝은 스파클 (하이라이트)
            if (Math.random() < 0.002) {
              pctx.globalAlpha = 0.6;
              pctx.beginPath(); pctx.arc(pt.x, pt.y, pt.size * 2.2, 0, Math.PI * 2); pctx.fill();
            }
          }

          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      function onWheel(e) {
        if (isFinalized) return;
        e.preventDefault();
        const dy = e.deltaY;
        if (p < 0.5) { setProgress(p + dy * 0.0018); startAutoAnimation(); }
        else if (!autoAnimating) { startAutoAnimation(); }
      }
      function onTouchMove(e) {
        if (isFinalized) return;
        const touch = e.touches[0]; const currentY = touch.clientY;
        if (typeof onTouchMove.lastY !== "undefined") {
          const dy = onTouchMove.lastY - currentY;
          if (p < 0.5) { setProgress(p + dy * 0.0018 * 2); if (p >= 0.5) startAutoAnimation(); }
          else if (!autoAnimating && dy > 0) { startAutoAnimation(); }
        }
        onTouchMove.lastY = currentY;
      }
      function onTouchEnd() { if (!isFinalized) onTouchMove.lastY = undefined; }

      window.addEventListener('resize', resizeParticleCanvas);
      window.addEventListener('wheel', onWheel, { passive: false });
      window.addEventListener('touchstart', (e) => { onTouchMove.lastY = e.touches[0].clientY; });
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', onTouchEnd);

      resizeParticleCanvas();
      setProgress(0);

      /* ============================================================
         🎸 현 시뮬레이터 (신호선 대체) — 변경 없음
         ============================================================ */
      const lineCanvas = document.getElementById('lineViz');
      const lctx = lineCanvas.getContext('2d');

      const LINE_THICK = 8;
      const LINE_H_DESKTOP = 72;
      const LINE_H_MOBILE  = 96;
      const V_PAD_VH = 18;

      let tension    = 0.8;
      let loss       = 0.986;
      let SUBSTEPS   = 10;
      let radiusPx   = 80;
      let handPower  = 0.95;
      const K_MOUSE  = 1.5;
      const C_MOUSE  = 0.08;
      const HARD_FACTOR = 0.4;
      const RELEASE_KICK = 0.25;

      let numPoints = 240;
      let dx = 1, invDX2 = 1;
      let initialY = 0;
      let string = [];
      let MAX_PULL = 0;

      class StringPoint { constructor(x, y){ this.x=x; this.y=y; this.oldY=y; this.acc=0; } }

      let vanishBaseWidth = null, vanishBaseLeft = null;

      function placeLineViz() {
        const Wwin = window.innerWidth;
        const Hwin = window.innerHeight;
        const isMobile = window.matchMedia("(max-width: 768px)").matches;

        // Mobile: Center on screen
        if (isMobile) {
          const desiredWidth = Math.round(Wwin * 0.9);
          const midY   = Math.round(Hwin / 2);
          const cssHeightBase = LINE_H_MOBILE;
          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = cssHeightBase + padPx * 2;
          const left = Math.round((Wwin - desiredWidth) / 2);

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = desiredWidth + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(desiredWidth  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(desiredWidth, cssHeight);
          if (vanishBaseWidth === null) {
            vanishBaseWidth = desiredWidth;
            vanishBaseLeft  = left;
          }
        }
        // Desktop: Position between Mars/Keys
        else {
          const marsLine = document.getElementById('mars')?.parentElement || null;
          const keysLine = document.getElementById('keys')?.parentElement || null;
          let left   = Math.round(Wwin * 0.2);
          let width  = Math.round(Wwin * 0.6);
          let midY   = Math.round(Hwin / 2);
          let cssHeightBase = LINE_H_DESKTOP;
          try {
            if (marsLine && keysLine) {
              const wrapRect = wrap.getBoundingClientRect();
              const wrapCS = getComputedStyle(wrap);
              const padLeft = parseFloat(wrapCS.paddingLeft) || 0;
              const additionalPadding = 250;

              left = Math.round(wrapRect.left + padLeft + additionalPadding);
              const rightLimit = Math.min(keysLine.getBoundingClientRect().right, wrapRect.right - padLeft * 0.25);
              width = Math.max(260, Math.round(rightLimit - left));

              const marsBottom = marsLine.getBoundingClientRect().bottom;
              const keysTop = keysLine.getBoundingClientRect().top;
              midY = Math.round((marsBottom + keysTop) / 2);
            }
          } catch(e) { /* fallback */ }

          const padPx = Math.round((V_PAD_VH / 100) * Hwin);
          const cssHeight = cssHeightBase + padPx * 2;
          width = Math.min(width, Wwin);
          left  = Math.max(0, Math.min(left, Wwin - width));

          lineCanvas.style.left = left + 'px';
          lineCanvas.style.top  = (midY - cssHeight/2) + 'px';
          lineCanvas.style.width  = width + 'px';
          lineCanvas.style.height = cssHeight + 'px';

          const dpr = Math.max(1, window.devicePixelRatio || 1);
          lineCanvas.width  = Math.floor(width  * dpr);
          lineCanvas.height = Math.floor(cssHeight * dpr);
          lctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          MAX_PULL = Math.floor(cssHeight * 0.42);
          setupString(width, cssHeight);
          if (vanishBaseWidth === null) {
            vanishBaseWidth = width;
            vanishBaseLeft  = left;
          }
        }
      }

      function setupString(W, H){
        numPoints = Math.max(160, Math.min(360, Math.round(W / 4)));
        string = [];
        for (let i=0;i<numPoints;i++){
          const x = (i/(numPoints-1)) * W;
          string.push(new StringPoint(x, H/2));
        }
        initialY = H/2;
        dx = W / (numPoints - 1);
        invDX2 = 1 / (dx*dx);
      }

      const mouse = { active:false, x:0, y:0 };
      function getPos(e){
        const r = lineCanvas.getBoundingClientRect();
        const cx = (e.clientX??e.touches?.[0].clientX) - r.left;
        const cy = (e.clientY??e.touches?.[0].clientY) - r.top;
        return {x:cx, y:cy};
      }

      lineCanvas.addEventListener('mousedown', e=>{
        const {x,y} = getPos(e); mouse.active = true; mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mousemove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); mouse.x = x; mouse.y = y;
      });
      window.addEventListener('mouseup', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      lineCanvas.addEventListener('touchstart', e=>{
        const {x,y} = getPos(e); e.preventDefault(); mouse.active = true; mouse.x = x; mouse.y = y;
      }, {passive:false});
      lineCanvas.addEventListener('touchmove', e=>{
        if (!mouse.active) return;
        const {x,y} = getPos(e); e.preventDefault(); mouse.x = x; mouse.y = y;
      }, {passive:false});
      window.addEventListener('touchend', ()=>{
        if (!mouse.active) return;
        mouse.active = false;
        for (let i=0;i<numPoints;i++){
          const disp = string[i].y - initialY;
          string[i].oldY = string[i].y + RELEASE_KICK * disp;
        }
      });

      function hannWeight(dist, R){
        if (dist >= R) return 0;
        const r = dist / R;
        return 0.5 * (1 + Math.cos(Math.PI * r));
      }

      function applyMouseForce(){
        if (!mouse.active) return;

        let pullY = mouse.y - initialY;
        if (Math.abs(pullY) > MAX_PULL) {
          pullY = Math.sign(pullY) * MAX_PULL;
        }

        const FcapBase = 12;
        const Fcap = FcapBase / (1 + HARD_FACTOR * tension);

        for (let i = 1; i < numPoints - 1; i++) {
          const p = string[i];
          const distX = Math.abs(p.x - mouse.x);
          const w = hannWeight(distX, radiusPx);
          if (w <= 0) continue;
          
          const vel = p.y - p.oldY;
          const Fspring = K_MOUSE * (initialY + pullY - p.y);
          const Fdamp   = -C_MOUSE * vel;
          let F = (Fspring + Fdamp) * w;
          
          if (F >  Fcap * w) F =  Fcap * w;
          if (F < -Fcap * w) F = -Fcap * w;

          p.acc += F;
        }
      }

      function physicsStep(){
        for (let i=1;i<numPoints-1;i++){
          const prev = string[i-1].y, curr = string[i].y, next = string[i+1].y;
          const lap = (prev - 2*curr + next) * invDX2;
          string[i].acc = tension * lap;
        }
        applyMouseForce();

        string[0].acc = 0; string[numPoints-1].acc = 0;

        for (let i=1;i<numPoints-1;i++){
          const p = string[i];
          const tempY = p.y;
          p.y = p.y*2 - p.oldY + p.acc;
          p.oldY = tempY;
          p.y = initialY + (p.y - initialY) * loss;
        }
        string[0].y = string[0].oldY = initialY;
        string[numPoints-1].y = string[numPoints-1].oldY = initialY;
      }

      function drawString(){
        const rect = lineCanvas.getBoundingClientRect();
        const Wdraw = Math.max(0, Math.round(rect.width));
        const Hdraw = Math.max(0, Math.round(rect.height));
        if (!Wdraw || !Hdraw) return;

        lctx.clearRect(0,0,Wdraw,Hdraw);

        const smoothstep = (x) => x < 0 ? 0 : x > 1 ? 1 : x * x * (3 - 2 * x);
        const f = (p < VANISH_START) ? 0 : smoothstep((p - VANISH_START) / (1 - VANISH_START));
        const thickness = Math.max(0.6, LINE_THICK * (1 - 0.9 * f));
        lctx.globalAlpha = 1 - f;

        lctx.beginPath();
        lctx.strokeStyle = '#ffffff';
        lctx.lineWidth = thickness;
        lctx.lineCap = 'round';
        lctx.lineJoin = 'round';

        const baseW = (vanishBaseWidth || Wdraw);
        const baseC = baseW / 2;
        const scaleX = Wdraw / baseW;
        const mapX = x => baseC + (x - baseC) * scaleX;

        lctx.moveTo(mapX(string[0].x), string[0].y);
        for (let i=1;i<numPoints-2;i++){
          const xc = mapX((string[i].x + string[i+1].x)/2);
          const yc = (string[i].y + string[i+1].y)/2;
          lctx.quadraticCurveTo(mapX(string[i].x), string[i].y, xc, yc);
        }
        lctx.quadraticCurveTo(mapX(string[numPoints-2].x), string[numPoints-2].y, mapX(string[numPoints-1].x), string[numPoints-1].y);
        lctx.stroke();

        lctx.globalAlpha = 1;
      }

      function animateString(){
        for (let s=0; s<SUBSTEPS; s++) physicsStep();
        drawString();
        if(!isFinalized) requestAnimationFrame(animateString);
      }

      function startLineEffect(){ /* keep */ }

      const ro = new ResizeObserver(() => placeLineViz());
      ro.observe(document.body);
      ro.observe(document.getElementById('brand'));
      window.addEventListener('resize', placeLineViz);
      window.addEventListener('orientationchange', placeLineViz);
      if (document.fonts && document.fonts.ready) { document.fonts.ready.then(placeLineViz); }

      placeLineViz();
      requestAnimationFrame(animateString);
    })();
  </script>
</body>
</html>
