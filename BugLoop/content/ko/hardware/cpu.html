<!-- panel.ejs : 드롭다운 기반 챕터 뷰어 (element-scoped init + anti-flicker + SPA 재장착 대응) -->
<div id="chapters-panel" class="chapters-panel is-booting">
    <div class="chapters-toolbar">
      <label for="chapterSelect" class="sr-only">장 선택</label>
      <select id="chapterSelect" class="chapters-select" aria-label="장 선택">
        <option value="0">0장. 컴퓨터는 계산기이다.</option>
        <option value="1">1장 — (coming soon)</option>
        <option value="2">2장 — (coming soon)</option>
        <option value="3">3장 — (coming soon)</option>
      </select>
    </div>
  
    <div class="chapter-content" id="chapterContent" tabindex="-1">
      <!-- 0장 -->
      <section data-chapter="0" class="chapter-section active">
        <h2 class="chapter-title">0장. 컴퓨터는 계산기이다.</h2>
        <p>CPU는 컴퓨터를 모르는 사람에겐 너무 복잡해보이는 단어다. 무언가의 약자라서, 그 무언가를 알 턱이 없는 일반인에겐 이름만 보고 그 의미나 역할을 추측한다는 게 불가능하다.</p>
        <p>
          C: 컴퓨터의 중심부에서 (Central)<br/>
          P: 뼈 빠지게 계산하는 (Processing)<br/>
          U: 팀 (Unit)
        </p>
        <p>컴퓨터는 엄청 빠른 계산기다.<br/>
        그런데 저장 기능이 있는 계산기다.<br/>
        저장 기능도 있고 계산도 엄청 빠른데, 단순한 숫자가 아닌 화려한 색상과 형태, 그리고 소리로 결과를 보여주는 계산기다.<br/>
        느릿느릿한 손짓과 발짓이 아닌 회로를 따라 엄청 빠르게 움직이는 엄청 작은 전기 알맹이를 이용해 계산하는, 초스피드 계산기다.<br/>
        전기 알맹이가 너무 빨리 움직이는 나머지, 마찰열이 쉽게 발생하기도 하는, 그렇게 시간에 따라 늙기도 하는 계산기이다.<br/>
        용도에 맞는 특별한 계산기를 직접 만들어 저장했다가 불러오는 것이 가능한, 유연한 계산기이다.</p>
        <p>그리고… 속도가 매우 빠른, 전기라는 특성을 다시 한 번 이용해 아주 멀리 있는 사람과 순식간에 소통을 하게 해 주는, 친절하고도 유능한 계산기다.</p>
        <p>일상적으로 풀어 본 컴퓨터에 대한 이 짧은 묘사에는, 사실 컴퓨터를 이해하는 데에 필요한 거의 모든 기본 개념이 다 들어가 있다.</p>
        <p>이 CPU 장에서는, 가장 첫 문장, "컴퓨터는 엄청 빠른 계산기다"에 해당하는 계산기로써의 컴퓨터를 다룬다.</p>
      </section>
  
      <!-- coming soon 섹션들 -->
      <section data-chapter="1" class="chapter-section" aria-hidden="true">
        <h2 class="chapter-title">1장 — (coming soon)</h2>
        <p>콘텐츠가 곧 올라옵니다.</p>
      </section>
  
      <section data-chapter="2" class="chapter-section" aria-hidden="true">
        <h2 class="chapter-title">2장 — (coming soon)</h2>
        <p>콘텐츠가 곧 올라옵니다.</p>
      </section>
  
      <section data-chapter="3" class="chapter-section" aria-hidden="true">
        <h2 class="chapter-title">3장 — (coming soon)</h2>
        <p>콘텐츠가 곧 올라옵니다.</p>
      </section>
    </div>
  </div>
  
  <style>
    .chapters-panel { display: grid; gap: 12px; }
    .chapters-toolbar { display: flex; gap: 8px; align-items: center; }
    .chapters-select {
      padding: 8px 10px; border: 1px solid #e1e6ef; border-radius: 10px; font-size: .95rem; background: #fff;
    }
    .chapter-content { background: #fff; border: 1px solid #e1e6ef; border-radius: 14px; padding: 16px; }
    .chapters-panel.is-booting .chapter-content { visibility: hidden; } /* anti-flicker */
  
    .chapter-title { margin: 0 0 8px; font-size: 1.1rem; }
    .chapter-section { display: none; }
    .chapter-section.active { display: block; }
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,1px,1px); border: 0; }
  </style>
  
  <script>
  (() => {
    const KEY = 'chapter.current';
  
    function initPanel(root) {
      if (!root || root.dataset.inited === '1') return; // 엘리먼트 단위 가드
      const select = root.querySelector('#chapterSelect');
      const container = root.querySelector('#chapterContent');
      if (!select || !container) return;
  
      root.dataset.inited = '1';
  
      const showChapter = (val) => {
        const sections = container.querySelectorAll('.chapter-section');
        sections.forEach(sec => {
          const active = sec.dataset.chapter === String(val);
          sec.classList.toggle('active', active);
          sec.setAttribute('aria-hidden', active ? 'false' : 'true');
        });
        try { history.replaceState(null, '', `#chapter=${val}`); } catch {}
        try { localStorage.setItem(KEY, String(val)); } catch {}
        container.focus({ preventScroll: false });
      };
  
      // 초기값: 해시 > localStorage > select 기본값
      const fromHash = (location.hash.match(/chapter=(\d+)/) || [])[1];
      const saved = (() => { try { return localStorage.getItem(KEY); } catch { return null; } })();
      const initial = fromHash ?? saved ?? select.value ?? '0';
      select.value = initial;
      showChapter(initial);
  
      // 표시 (anti-flicker 해제)
      root.classList.remove('is-booting');
  
      // 변경 이벤트
      select.addEventListener('change', (e) => showChapter(e.target.value));
  
      // 홈 버튼 연동
      document.addEventListener('click', (ev) => {
        const a = ev.target.closest('a.home-btn, a[href="/"], button.home-btn');
        if (!a) return;
        try { localStorage.removeItem(KEY); } catch {}
        document.dispatchEvent(new CustomEvent('panel:home'));
      });
  
      document.addEventListener('panel:home', () => {
        select.value = '0';
        showChapter(0);
      });
    }
  
    // 현재 DOM에 있는 패널 초기화
    initPanel(document.getElementById('chapters-panel'));
  
    // SPA: 새로 삽입되는 패널 자동 초기화
    const mo = new MutationObserver((muts) => {
      for (const m of muts) {
        m.addedNodes && m.addedNodes.forEach(node => {
          if (node.nodeType === 1) {
            if (node.id === 'chapters-panel') initPanel(node);
            const found = node.querySelector && node.querySelector('#chapters-panel');
            if (found) initPanel(found);
          }
        });
      }
    });
    mo.observe(document.documentElement, { childList: true, subtree: true });
  })();
  </script>
  