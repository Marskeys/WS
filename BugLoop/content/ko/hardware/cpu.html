<!-- panel.ejs : 드롭다운 기반 챕터 뷰어 (singleton boot + no-flicker + SPA 재장착 대응) -->
<div id="chapters-panel" class="chapters-panel" data-ready="0">
    <div class="chapters-toolbar">
      <label for="chapterSelect" class="sr-only">장 선택</label>
      <select id="chapterSelect" class="chapters-select" aria-label="장 선택">
        <option value="0">0장. 컴퓨터는 계산기이다.</option>
        <option value="1">1장 — (coming soon)</option>
        <option value="2">2장 — (coming soon)</option>
        <option value="3">3장 — (coming soon)</option>
      </select>
    </div>
  
    <div class="chapter-content" id="chapterContent" tabindex="-1">
      <!-- 0장 -->
      <section data-chapter="0" class="chapter-section active">
        <h2 class="chapter-title">0장. 컴퓨터는 계산기이다.</h2>
        <p>CPU는 컴퓨터를 모르는 사람에겐 너무 복잡해보이는 단어다. 무언가의 약자라서, 그 무언가를 알 턱이 없는 일반인에겐 이름만 보고 그 의미나 역할을 추측한다는 게 불가능하다.</p>
        <p>
          C: 컴퓨터의 중심부에서 (<b>C</b>entral)<br/>
          P: 뼈 빠지게 계산하는 (<b>P</b>rocessing)<br/>
          U: 팀 (<b>U</b>nit)
        </p>
        <p>컴퓨터는 엄청 빠른 계산기다.<br/>
        그런데 저장 기능이 있는 계산기다.<br/>
        저장 기능도 있고 계산도 엄청 빠른데, 단순한 숫자가 아닌 화려한 색상과 형태, 그리고 소리로 결과를 보여주는 계산기다.<br/>
        느릿느릿한 손짓과 발짓이 아닌 회로를 따라 엄청 빠르게 움직이는 엄청 작은 전기 알맹이를 이용해 계산하는, 초스피드 계산기다.<br/>
        전기 알맹이가 너무 빨리 움직이는 나머지, 마찰열이 쉽게 발생하기도 하는, 그렇게 시간에 따라 늙기도 하는 계산기이다.<br/>
        용도에 맞는 특별한 계산기를 직접 만들어 저장했다가 불러오는 것이 가능한, 유연한 계산기이다.</p>
        <p>그리고… 속도가 매우 빠른, 전기라는 특성을 다시 한 번 이용해 아주 멀리 있는 사람과 순식간에 소통을 하게 해 주는, 친절하고도 유능한 계산기다.</p>
        <p>일상적으로 풀어 본 컴퓨터에 대한 이 짧은 묘사에는, 사실 컴퓨터를 이해하는 데에 필요한 거의 모든 기본 개념이 다 들어가 있다.</p>
        <p>이 CPU 장에서는, 가장 첫 문장, "컴퓨터는 엄청 빠른 계산기다"에 해당하는 <b><u>계산기로써의 컴퓨터</u></b>를 다룬다.</p>
      </section>
  
      <!-- coming soon 섹션들 -->
      <section data-chapter="1" class="chapter-section" aria-hidden="true">
        <h2 class="chapter-title">1장 — (coming soon)</h2>
        <p>콘텐츠가 곧 올라옵니다.</p>
      </section>
  
      <section data-chapter="2" class="chapter-section" aria-hidden="true">
        <h2 class="chapter-title">2장 — (coming soon)</h2>
        <p>콘텐츠가 곧 올라옵니다.</p>
      </section>
  
      <section data-chapter="3" class="chapter-section" aria-hidden="true">
        <h2 class="chapter-title">3장 — (coming soon)</h2>
        <p>콘텐츠가 곧 올라옵니다.</p>
      </section>
    </div>
  </div>
  
  <style>
    .chapters-panel { display: grid; gap: 12px; }
    .chapters-toolbar { display: flex; gap: 8px; align-items: center; }
    .chapters-select {
      padding: 8px 10px; border: 1px solid #e1e6ef; border-radius: 10px; font-size: .95rem; background: #fff;
    }
    .chapter-content { background: #fff; border: 1px solid #e1e6ef; border-radius: 14px; padding: 16px; }
  
    /* ✅ 초기 깜빡임 억제: 준비될 때까지 내용 비가시화 (레이아웃은 유지) */
    #chapters-panel[data-ready="0"] .chapter-content { visibility: hidden; }
    #chapters-panel[data-ready="1"] .chapter-content { visibility: visible; }
  
    .chapter-title { margin: 0 0 8px; font-size: 1.1rem; }
    .chapter-section { display: none; }
    .chapter-section.active { display: block; }
  
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,1px,1px); border: 0; }
  </style>
  
  <script>
  /* ===== Singleton boot: 전역 1회만 부팅/감시/바인딩 ===== */
  (() => {
    if (!window.__ChapterBoot) {
      window.__ChapterBoot = {
        mo: null,
        initedRoots: new WeakSet(),
        initPanel(root, opts={}) {
          if (!root || this.initedRoots.has(root)) return;
          const select = root.querySelector('#chapterSelect');
          const container = root.querySelector('#chapterContent');
          if (!select || !container) return;
  
          this.initedRoots.add(root);
  
          const KEY = 'chapter.current';
          let isInitPhase = true; // 초기화 중에는 히스토리/스토리지 갱신 안 함
  
          const showChapter = (val, {silent=false}={}) => {
            const sections = container.querySelectorAll('.chapter-section');
            sections.forEach(sec => {
              const active = sec.dataset.chapter === String(val);
              sec.classList.toggle('active', active);
              sec.setAttribute('aria-hidden', active ? 'false' : 'true');
            });
  
            // 초기화/침묵 모드에선 라우터 자극 금지
            if (!silent && !isInitPhase) {
              try { localStorage.setItem(KEY, String(val)); } catch {}
              try { history.replaceState(null, '', `#chapter=${val}`); } catch {}
            }
          };
  
          // 초기값: 해시 > localStorage > select 기본값
          const fromHash = (location.hash.match(/chapter=(\d+)/) || [])[1];
          let saved = null;
          try { saved = localStorage.getItem(KEY); } catch {}
          const initial = fromHash ?? saved ?? (select.value ?? '0');
  
          select.value = initial;
          showChapter(initial, {silent:true});
  
          // 준비 완료 → 표시
          root.setAttribute('data-ready', '1');
          isInitPhase = false;
  
          // 변경 이벤트
          select.addEventListener('change', (e) => showChapter(e.target.value));
  
          // 홈 버튼 연동(전역 위임은 부팅 단계에서 1회 설치됨. 여기선 리스너 불필요)
          document.addEventListener('panel:home', () => {
            try { localStorage.removeItem(KEY); } catch {}
            select.value = '0';
            showChapter(0);
          }, { once:false });
        },
        bootOnce() {
          // 전역 홈 버튼 위임: 1회만
          if (!window.__ChapterBoot._homeBound) {
            document.addEventListener('click', (ev) => {
              const a = ev.target.closest('a.home-btn, a[href="/"], button.home-btn');
              if (!a) return;
              // 여기서 기본 내비게이션은 그대로 두고, 패널만 리셋
              document.dispatchEvent(new CustomEvent('panel:home'));
            });
            window.__ChapterBoot._homeBound = true;
          }
  
          // MutationObserver: 1회만
          if (!this.mo) {
            this.mo = new MutationObserver((muts) => {
              for (const m of muts) {
                for (const node of m.addedNodes || []) {
                  if (node.nodeType !== 1) continue;
                  if (node.id === 'chapters-panel') this.initPanel(node);
                  const found = node.querySelector?.('#chapters-panel');
                  if (found) this.initPanel(found);
                }
              }
            });
            this.mo.observe(document.documentElement, { childList: true, subtree: true });
          }
  
          // 초기 DOM 스캔
          this.initPanel(document.getElementById('chapters-panel'));
        }
      };
  
      // 실제 부팅
      window.__ChapterBoot.bootOnce();
    } else {
      // 이미 부팅돼 있으면, 현재 DOM에 있는 패널만 초기화 시도
      window.__ChapterBoot.initPanel(document.getElementById('chapters-panel'));
    }
  })();
  </script>
  