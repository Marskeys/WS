<!DOCTYPE html>
<html lang="<%= lang %>">
<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="/assets/css/editor.css" />
  <title>BlindLove 에디터</title>
  <%- include('partials/head') %>
  <% if (user) { %>
    <meta name="author" content="<%= user.nickname %>">
  <% } %>
<style>

</style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/style.css" />
</head>
<body class="edit-body">
  <div id="preloader">
    <div class="spinner"></div>
  </div>
  <%- include('partials/header') %>
  <% const isEdit = typeof post !== 'undefined' && post !== null; %>
  <% if (user) { %>
    <div style="text-align: center; font-weight: bold; margin-top:3rem;">
      <%= user.nickname %>님, 에디터에 오신 걸 환영합니다!
    </div>
  <% } %>

  <div class="editor-container">
    <div class="logo-wrap">
      <a href="/<%= lang %>/">
        <img src="/assets/images/logo.png" alt="BlindLove 로고" />
      </a>
    </div>

    <div class="lang-selector-wrap">
      <label for="langSelector">편집 중인 언어</label>
      <select id="langSelector">
        <%
          const langLabels = {
              'ko': '한국어',
              'en': 'English',
              'fr': 'Français',
              'zh': '中文',
              'ja': '日本語'
          };
          supportedLangs.forEach(langCode => {
        %>
          <option value="<%= langCode %>" <%= lang === langCode ? 'selected' : '' %>><%= langLabels[langCode] %></option>
        <%
          });
        %>
      </select>
    </div>

    <%
      const langList = [
        { code: 'ko', label: '한국어' },
        { code: 'en', label: 'English' },
        { code: 'fr', label: 'Français' },
        { code: 'zh', label: '简体中文' },
        { code: 'ja', label: '日本語' }
      ];
    %>

    <% langList.forEach(({ code, label }) => { %>
      <div class="lang-meta-block" data-lang="<%= code %>" style="<%= code === lang ? '' : 'display:none;' %>">
        <div class="title-wrap">
          <input
            type="text"
            name="title_<%= code %>"
            placeholder="<%= label %> 제목"
            value="<%= post?.[code]?.title || '' %>"
          />
        </div>

        <div class="toolbar" data-lang-toolbar="<%= code %>">
          <div class="dropdown">
            <div class="dropdown-toggle" data-style-toggle="<%= code %>">본문 ▼</div>
            <div class="dropdown-menu" data-style-dropdown="<%= code %>">
              <div class="h1" data-style-command="h1">제목</div>
              <div class="h2" data-style-command="h2">부제목</div>
              <div class="h3" data-style-command="h3">머리말 1</div>
              <div class="red" data-style-command="h4">빨간 머리말</div>
              <div class="p" data-style-command="p">본문</div>
              <div class="desc" data-style-command="small">설명</div>
              <div class="meta" data-style-command="footer">머리말 및 꼬리말</div>
              <div class="label" data-style-command="span">레이블</div>
              <div class="label label-bold" data-style-command="strong">진한 레이블</div>
            </div>
          </div>
          <button data-command="insertTOC" data-tooltip="목차 삽입">📑 목차</button>
          <button data-command="bold" data-tooltip="굵게"><b>B</b></button>
          <button data-command="italic" data-tooltip="기울이기"><i>I</i></button>
          <button data-command="underline" data-tooltip="밑줄"><u>U</u></button>
          <button data-command="strikeThrough" data-tooltip="취소선"><s>S</s></button>
          <button data-command="justifyLeft" data-tooltip="왼쪽 정렬"><i class="fas fa-align-left"></i></button>
          <button data-command="justifyCenter" data-tooltip="가운데 정렬"><i class="fas fa-align-center"></i></button>
          <button data-command="justifyRight" data-tooltip="오른쪽 정렬"><i class="fas fa-align-right"></i></button>
          <button data-command="insertOrderedList" data-tooltip="번호 목록"><i class="fas fa-list-ol"></i></button>
          <button data-command="insertUnorderedList" data-tooltip="글머리 기호"><i class="fas fa-list-ul"></i></button>
          <button data-command="outdent" data-tooltip="내어쓰기"><i class="fas fa-outdent"></i></button>
          <button data-command="indent" data-tooltip="들여쓰기"><i class="fas fa-indent"></i></button>
          <button data-command="createLink" data-tooltip="링크 삽입"><i class="fas fa-link"></i></button>
          <button data-command="unlink" data-tooltip="링크 제거"><i class="fas fa-unlink"></i></button>
          
          <div class="color-tool" data-color-tool="foreColor">
            <button data-color-btn="foreColor" data-tooltip="글자 색상">
              <i class="fas fa-pencil-alt"></i>
            </button>
            <div class="color-palette" data-color-palette="foreColor">
              <button style="background:black" data-color-value="black"></button>
              <button style="background:red" data-color-value="red"></button>
              <button style="background:orange" data-color-value="orange"></button>
              <button style="background:green" data-color-value="green"></button>
              <button style="background:blue" data-color-value="blue"></button>
              <button class="none-icon" data-color-value="__clear__" title="색 없음"></button>
              <label class="custom-color">
                🎨<input type="color" data-color-input="foreColor" />
              </label>
            </div>
          </div>
          
          <div class="color-tool" data-color-tool="hiliteColor">
            <button data-color-btn="hiliteColor" data-tooltip="배경 색상">
              <i class="fas fa-fill-drip"></i>
            </button>
            <div class="color-palette" data-color-palette="hiliteColor">
              <button style="background:yellow" data-color-value="yellow"></button>
              <button style="background:lightblue" data-color-value="lightblue"></button>
              <button style="background:lightgreen" data-color-value="lightgreen"></button>
              <button style="background:pink" data-color-value="pink"></button>
              <button style="background:#ccc" data-color-value="#ccc"></button>
              <button class="none-icon" data-color-value="__clear__" title="색 없음"></button>
              <label class="custom-color">
                🎨<input type="color" data-color-input="hiliteColor" />
              </label>
            </div>
          </div>
          <button data-command="openHtmlPopup" data-tooltip="HTML 삽입"><i class="fas fa-code"></i></button> 
          <button data-command="insertImage" data-tooltip="이미지 삽입"><i class="fas fa-image"></i></button>
          <button data-command="removeFormat" data-tooltip="형식 제거">지우기</button>
        </div>
    
        <% if (user && Number(user.is_admin) === 1) { %>
        <div class="mode-toggle">
          <button data-mode-toggle="design">디자인 모드</button>
          <button data-mode-toggle="html">HTML 모드</button>
        </div>
        <% } %>
        
        <div class="editor-area-wrapper">
          <div id="editor_<%= code %>"
               contenteditable="true"
               class="editor language-editor"
               spellcheck="false"
               data-lang-editor="<%= code %>"
               style="<%= code === lang ? '' : 'display:none;' %>"
          >
            <%
              let initialContent = post?.[code]?.content || '<p><br></p>';
              const isWrapped = initialContent.startsWith('<div class="bl-content"');
              if (!isWrapped) {
                initialContent = `
                  <div class="bl-content" style="white-space:normal; line-height: 1.7;">
                    ${initialContent}
                  </div>
                `;
              }
            %>
            <%- initialContent %>
          </div>
          <textarea id="htmlEditor_<%= code %>" class="editor html-editor" style="display: none;"></textarea>
        </div>

        <div class="global-options" style="margin-top: 2rem;">
          <label style="margin-right: 2rem;">
            <input type="checkbox" id="isPrivateCheckbox" name="is_private" value="1" <%= post?.is_private ? 'checked' : '' %> />
            🔒 비공개 글로 설정
          </label>
        
          <% if (user && Number(user.is_admin) === 1) { %>
            <label>
              <input type="checkbox" id="isPinnedCheckbox" name="is_pinned" value="1" <%= post?.is_pinned ? 'checked' : '' %> />
              📌 상단에 고정하기
            </label>
          <% } %>
        </div>


      </div>
    <% }) %> 

    <div class="category-box">
      <label>카테고리 선택:</label>
      <div class="category-list" id="categoryList"></div>
      <button class="bl-button add" onclick="addCategory()">+ 추가</button>
    </div>

    <div class="save-button-wrap">
      <button type="button" class="bl-button save" onclick="postContent()">💾 저장</button>
    </div>

  </div> 
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
  <script>
    let selectedCategories = []; // 기본값으로 빈 배열 선언
    <% if (post && post.categories) { %>
      // post.categories가 있을 경우에만 JSON.stringify를 사용하여 할당
      selectedCategories = <%- JSON.stringify(post.categories.split(',')) %>;
    <% } %>

    let categories = [];
    let savedRange = null;
    let currentActiveEditor = null; // 현재 활성 디자인 모드 에디터 div 엘리먼트
    let currentActiveHtmlEditor = null; // 현재 활성 HTML 모드 에디터 textarea 엘리먼트
    let currentActiveToolbar = null; // 현재 활성 툴바 div 엘리먼트 (새로 추가)

    const langList = [
        { code: 'ko', label: '한국어' },
        { code: 'en', label: 'English' },
        { code: 'fr', label: 'Français' },
        { code: 'zh', label: '简体中文' },
        { code: 'ja', label: '日本語' }
    ];
    
    const IS_EDIT_PAGE = <%- isEdit ? 'true' : 'false' %>; 
    const POST_ID = <%- post && post.id ? JSON.stringify(post.id) : 'null' %>;
    const CURRENT_PAGE_LANG = '<%= lang %>';

    function renderCategories() {
        const list = document.getElementById('categoryList');
        list.innerHTML = '';
        categories.forEach((cat, index) => {
          const item = document.createElement('div');
          item.className = 'category-item';
          if (selectedCategories.includes(cat)) item.classList.add('selected');
          item.innerText = cat;
    
          item.onclick = () => {
            const i = selectedCategories.indexOf(cat);
            if (i === -1) selectedCategories.push(cat);
            else selectedCategories.splice(i, 1);
            renderCategories();
          };
    
          const removeBtn = document.createElement('button');
          removeBtn.className = 'remove-btn';
          removeBtn.innerText = '×';
          removeBtn.onclick = (e) => {
            e.stopPropagation();
            showCustomMessage(`'${cat}' 카테고리를 삭제하시겠습니까?`, true, () => {
              fetch(`/api/categories/${encodeURIComponent(cat)}`, {
                method: 'DELETE'
              })
              .then(res => res.json())
              .then(data => {
                if (data.success) {
                  categories.splice(index, 1);
                  selectedCategories = selectedCategories.filter(c => c !== cat);
                  renderCategories();
                  showCustomMessage("카테고리가 성공적으로 삭제되었습니다.");
                } else {
                  showCustomMessage("삭제 실패: " + data.error);
                }
              })
              .catch(err => {
                console.error("삭제 오류:", err);
                showCustomMessage("삭제 중 오류가 발생했습니다.");
              });
            });
          };
    
          item.appendChild(removeBtn);
          list.appendChild(item);
        });
      }
    
      function addCategory() {
        showCustomInput("새 카테고리 이름을 입력하세요:", (newCat) => {
          newCat = newCat?.trim();
          if (!newCat || categories.includes(newCat)) return;
      
          fetch('/api/categories', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: newCat })
          })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              categories.push(newCat);
              renderCategories();
              showCustomMessage("카테고리가 성공적으로 추가되었습니다.");
            } else {
              showCustomMessage("추가 실패: " + data.error);
            }
          })
          .catch(err => {
            console.error("추가 오류:", err);
            showCustomMessage("추가 중 오류가 발생했습니다.");
          });
        });
      }
    
      function postContent() {
          const postData = {
              categories: selectedCategories,
              is_private: document.getElementById('isPrivateCheckbox')?.checked ? 1 : 0,
              is_pinned: document.getElementById('isPinnedCheckbox')?.checked ? 1 : 0,
              lang_content: {}
          };

          let hasContentForDefaultLang = false;

          langList.forEach(({ code }) => {
              const titleInput = document.querySelector(`input[name="title_${code}"]`);
              const editorDiv = document.getElementById(`editor_${code}`);
              const htmlEditorDiv = document.getElementById(`htmlEditor_${code}`);

              if (!titleInput || !editorDiv || !htmlEditorDiv) {
                  console.warn(`언어 코드 ${code} 에 대한 입력 필드 또는 에디터 DIV를 찾을 수 없습니다.`);
                  return;
              }

              let contentToSave = '';
              if (htmlEditorDiv.style.display === 'block') { // HTML 모드인 경우
                  contentToSave = htmlEditorDiv.value.trim();
              } else { // 디자인 모드인 경우
                  // 디자인 모드에서 내용을 가져올 때, bl-content 내부의 내용만 가져오도록 합니다.
                  const blContent = editorDiv.querySelector('.bl-content');
                  contentToSave = blContent ? blContent.innerHTML.trim() : editorDiv.innerHTML.trim();
              }

              // 내용이 비어있거나 기본 플레이스홀더 내용인 경우 '<p><br></p>'로 통일
              if (!contentToSave || contentToSave === '<div><br></div>' || contentToSave === '<p><br></p>') {
                  contentToSave = '<p><br></p>';
              }

              postData.lang_content[code] = {
                  title: titleInput.value.trim(),
                  content: contentToSave
              };

              if (code === 'ko' && (postData.lang_content[code].title || postData.lang_content[code].content !== '<p><br></p>')) {
                  hasContentForDefaultLang = true;
              }
          });

          if (!postData.categories || postData.categories.length === 0) {
              return showCustomMessage("최소 하나의 카테고리를 선택해주세요.");
          }

          if (!hasContentForDefaultLang) {
            return showCustomMessage("한국어 제목 또는 내용을 입력해주세요.");
          }
      
          // 폼 제출 URL을 현재 언어 경로를 포함하도록 수정
          const submitUrl = IS_EDIT_PAGE && POST_ID ? `/${CURRENT_PAGE_LANG}/edit/${POST_ID}` : `/${CURRENT_PAGE_LANG}/savePost`;

          fetch(submitUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(postData)
          })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              showCustomMessage("성공적으로 저장되었습니다!", false, () => {
                // 저장 후 리디렉션 URL에도 현재 언어 경로를 포함
                if (IS_EDIT_PAGE && POST_ID) {
                  window.location.href = `/${CURRENT_PAGE_LANG}/post/${POST_ID}`;
                } else if (data.postId) { // 새로 생성된 글의 경우 ID가 있을 수 있음
                  window.location.href = `/${CURRENT_PAGE_LANG}/post/${data.postId}`;
                } else {
                  window.location.href = `/${CURRENT_PAGE_LANG}/`; // 글 ID가 없는 경우 메인 페이지로
                }
              });
            } else {
              showCustomMessage("저장 실패: " + data.error);
            }
          })
          .catch(err => {
            console.error("저장 중 오류:", err);
            showCustomMessage("저장 중 오류가 발생했습니다.");
          });
        }
      
      function format(command, value = null) {
          if (!currentActiveEditor) return; // 활성 에디터가 없으면 반환
          currentActiveEditor.focus();
          document.execCommand("styleWithCSS", false, false);
          document.execCommand(command, false, value);
          setTimeout(detectStyle, 100);
      }

      function applyStyle(tag) {
        if (!currentActiveEditor) return;
        const blockTags = ['h1', 'h2', 'h3', 'h4', 'p', 'small', 'footer'];

        restoreSelection(); // 저장된 선택 영역 복원
        currentActiveEditor.focus(); // 에디터에 포커스

        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed) {
            // 선택된 내용이 없으면 현재 블록 전체에 적용 시도 (기존 formatBlock 방식)
            document.execCommand("styleWithCSS", false, false);
            document.execCommand('formatBlock', false, `<${tag.toUpperCase()}>`);
            saveSelection();
            setTimeout(detectStyle, 100);
            return;
        }

        const range = sel.getRangeAt(0);
        let commonAncestor = range.commonAncestorContainer;

        // 텍스트 노드인 경우 부모 요소로 이동
        if (commonAncestor.nodeType === 3) {
            commonAncestor = commonAncestor.parentNode;
        }

        // 현재 선택된 블록 요소를 찾습니다. (bl-content 바로 아래의 블록 요소)
        let targetBlock = commonAncestor;
        while (targetBlock && targetBlock !== currentActiveEditor && !blockTags.includes(targetBlock.tagName.toLowerCase())) {
            targetBlock = targetBlock.parentNode;
        }

        // targetBlock이 bl-content 바로 아래의 유효한 블록 요소가 아니거나,
        // 선택 영역이 여러 블록에 걸쳐있을 경우를 대비하여 더 견고한 처리를 시도합니다.
        if (targetBlock && targetBlock !== currentActiveEditor && blockTags.includes(targetBlock.tagName.toLowerCase())) {
            // 단일 블록 요소에 대한 스타일 변경 시도
            const currentTag = targetBlock.tagName.toLowerCase();

            // 이미 같은 태그인 경우 토글 (p 태그로 되돌리기)
            if (currentTag === tag) {
                if (tag === 'p') { // 이미 p인데 p로 바꾸려고 하면 아무것도 안 함
                    // 선택된 텍스트가 이미 p 태그인데 다시 p를 누르면 아무것도 안 함
                    // 하지만 선택된 내용이 없다면 <p><br></p>로 강제 변환
                    if (sel.isCollapsed) {
                        document.execCommand("formatBlock", false, '<p>');
                    }
                    saveSelection();
                    setTimeout(detectStyle, 100);
                    return;
                }
                document.execCommand("formatBlock", false, '<p>'); // 같은 태그면 p로 되돌림
                saveSelection();
                setTimeout(detectStyle, 100);
                return;
            }

            // 선택된 블록 태그를 새 태그로 변경
            document.execCommand("formatBlock", false, `<${tag.toUpperCase()}>`);
            
        } else {
            // 여러 블록에 걸쳐 선택되었거나, 예상치 못한 경우
            // 선택된 내용을 추출하여 새 태그로 감싸는 방식 (더 안전)
            try {
                const fragment = range.extractContents(); // 선택된 내용 추출
                const newBlock = document.createElement(tag); // 새 블록 요소 생성
                newBlock.appendChild(fragment); // 추출한 내용을 새 블록에 추가

                range.insertNode(newBlock); // 새 블록을 원래 위치에 삽입

                // 삽입 후 선택 영역을 새로 만든 블록으로 재설정
                sel.removeAllRanges();
                const newRange = document.createRange();
                newRange.selectNodeContents(newBlock); // 새 블록의 내용 전체를 선택
                sel.addRange(newRange);
                
            } catch (e) {
                console.warn("applyStyle (DOM 조작) 실패, fallback to execCommand:", e);
                // DOM 조작 실패 시 execCommand로 대체
                document.execCommand("formatBlock", false, `<${tag.toUpperCase()}>`);
            }
        }
        
        saveSelection();
        setTimeout(detectStyle, 100);

        // span이나 strong과 같은 인라인 태그 처리 (기존 로직 유지)
        // 이 부분은 블록 태그가 아닌 인라인 태그 (span, strong)에 대한 로직입니다.
        // 선택된 텍스트를 span/strong으로 감싸는 부분은 그대로 유지됩니다.
        if (!blockTags.includes(tag)) {
            const tempElement = document.createElement(tag);
            if (tag === 'span') tempElement.classList.add('label');
            if (tag === 'strong') tempElement.classList.add('label', 'label-bold');

            // 이전에 추출된 fragment를 사용할 수도 있지만, 블록 태그 처리가 되었으므로
            // 여기서는 다시 선택 영역을 확인하고 처리합니다.
            const selAfterBlockFormat = window.getSelection();
            if (!selAfterBlockFormat.rangeCount || selAfterBlockFormat.isCollapsed) return;
            const rangeAfterBlockFormat = selAfterBlockFormat.getRangeAt(0);

            try {
                const contents = rangeAfterBlockFormat.extractContents();
                tempElement.appendChild(contents);
                rangeAfterBlockFormat.insertNode(tempElement);

                selAfterBlockFormat.removeAllRanges();
                const newRange = document.createRange();
                newRange.selectNode(tempElement);
                selAfterBlockFormat.addRange(newRange);

                saveSelection();
            } catch (e) {
                console.error("applyStyle(span/strong) 오류:", e);
            }
        }
    }

      function insertImage() {
          showCustomInput("이미지 URL을 입력하세요:", (url) => {
            if (url) format('insertImage', url);
          });
      }

      function saveContent() {
          showCustomMessage("임시 저장 완료!");
      }

      function toggleDropdown() {
        if (!currentActiveToolbar) return;
        const styleDropdown = currentActiveToolbar.querySelector('.dropdown-menu');
        if (styleDropdown) {
            styleDropdown.classList.toggle('show');
        }
      }

      function updateCurrentStyle(tagName) {
          if (!currentActiveToolbar) return;
          const labelMap = {
              h1: "제목",
              h2: "부제목",
              h3: "머리말 1",
              h4: "빨간 머리말",
              p: "본문",
              small: "설명",
              footer: "머리말 및 꼬리말",
              span: "레이블",
              strong: "진한 레이블"
          };
          const label = labelMap[tagName.toLowerCase()] || tagName;
          const currentStyleToggle = currentActiveToolbar.querySelector('.dropdown-toggle');
          if (currentStyleToggle) {
              currentStyleToggle.innerText = `${label} ▼`;
          }
      }

      function detectStyle() {
        if (!currentActiveEditor) return;
        const sel = window.getSelection();
        if (!sel.rangeCount || !currentActiveEditor.contains(sel.getRangeAt(0).commonAncestorContainer)) {
            updateCurrentStyle('p');
            return;
        }
        let node = sel.getRangeAt(0).startContainer;

        if (node.nodeType === 3) node = node.parentNode;

        while (node && node !== currentActiveEditor) {
          const tag = node.tagName?.toLowerCase();
          if (['h1', 'h2', 'h3', 'h4', 'p', 'small', 'footer'].includes(tag)) {
            updateCurrentStyle(tag);
            return;
          }
          node = node.parentNode;
        }
        updateCurrentStyle('p');
      }

      function saveSelection() {
          const sel = window.getSelection();
          // 현재 활성 에디터 내에서만 Selection을 저장
          if (sel.rangeCount > 0 && currentActiveEditor && currentActiveEditor.contains(sel.getRangeAt(0).commonAncestorContainer)) {
              savedRange = sel.getRangeAt(0).cloneRange();
          } else {
              savedRange = null; // 현재 활성 에디터 밖의 Selection은 무시
          }
      }

      function restoreSelection() {
          const sel = window.getSelection();
          if (savedRange && currentActiveEditor) {
              sel.removeAllRanges();
              sel.addRange(savedRange);
          }
      }

      function setColor(command, color) {
        restoreSelection();
        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed || !currentActiveEditor || !currentActiveEditor.contains(sel.getRangeAt(0).commonAncestorContainer)) return;

        const range = sel.getRangeAt(0);

        if (color === "__clear__") {
          // 선택 영역 내에서 특정 스타일 제거 (span 태그를 찾아 style 속성 제거)
          const tempDiv = document.createElement('div');
          tempDiv.appendChild(range.extractContents());
          
          const spans = tempDiv.querySelectorAll("span");
          spans.forEach(span => {
            if (command === 'foreColor') {
              span.style.color = '';
              if (!span.style.backgroundColor && !span.style.color && !span.classList.length) { // 다른 스타일이 없으면 span 제거
                span.outerHTML = span.innerHTML;
              }
            } else if (command === 'hiliteColor') {
              span.style.backgroundColor = '';
              if (!span.style.backgroundColor && !span.style.color && !span.classList.length) { // 다른 스타일이 없으면 span 제거
                span.outerHTML = span.innerHTML;
              }
            }
          });
          range.insertNode(tempDiv.firstChild); // 첫 번째 자식을 다시 삽입
          return;
        }

        const span = document.createElement("span");
        if (command === "foreColor") span.style.color = color;
        else if (command === "hiliteColor") span.style.backgroundColor = color;

        const contents = range.extractContents();
        span.appendChild(contents);
        range.insertNode(span);

        sel.removeAllRanges();
        const newRange = document.createRange();
        newRange.selectNode(span);
        sel.addRange(newRange);

        saveSelection();
        detectStyle();
      }

      function getCurrentBlockTag() {
        if (!currentActiveEditor) return 'p';
        const sel = window.getSelection();
        if (!sel.rangeCount || !currentActiveEditor.contains(sel.getRangeAt(0).commonAncestorContainer)) return 'p';

        let node = sel.getRangeAt(0).startContainer;
        while (node && node !== currentActiveEditor) {
          if (node.nodeType === 1) {
            const tag = node.tagName.toLowerCase();
            if (['h1', 'h2', 'h3', 'h4', 'p', 'small', 'footer'].includes(tag)) {
              return tag;
            }
          }
          node = node.parentNode;
        }
        return 'p';
      }

      function createMessageBox(message, isConfirm = false, onConfirm = null) {
          let modal = document.getElementById('customMessageModal');
          if (!modal) {
              modal = document.createElement('div');
              modal.id = 'customMessageModal';
              modal.style = `
                  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                  background: rgba(0,0,0,0.5); display: flex; justify-content: center;
                  align-items: center; z-index: 1000;
              `;
              document.body.appendChild(modal);
          }
          modal.innerHTML = `
              <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); max-width: 400px; width: 90%; text-align: center;">
                  <p style="color: black;">${message}</p>
                  ${isConfirm ? `
                      <button id="confirmBtn" style="padding: 8px 15px; margin: 5px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">확인</button>
                      <button id="cancelBtn" style="padding: 8px 15px; margin: 5px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">취소</button>
                  ` : `
                      <button id="okBtn" style="padding: 8px 15px; margin: 5px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">확인</button>
                  `}
              </div>
          `;
          modal.style.display = 'flex';

          if (isConfirm) {
              document.getElementById('confirmBtn').onclick = () => {
                  modal.style.display = 'none';
                  if (onConfirm) onConfirm();
              };
              document.getElementById('cancelBtn').onclick = () => {
                  modal.style.display = 'none';
              };
          } else {
              document.getElementById('okBtn').onclick = () => {
                  modal.style.display = 'none';
                  if (onConfirm) onConfirm();
              };
          }
      }

      function showCustomMessage(message, isConfirm = false, onConfirm = null) {
          createMessageBox(message, isConfirm, onConfirm);
      }

      function showCustomInput(message, onInput) {
          let modal = document.getElementById('customInputModal');
          if (!modal) {
              modal = document.createElement('div');
              modal.id = 'customInputModal';
              modal.style = `
                  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                  background: rgba(0,0,0,0.5); display: flex; justify-content: center;
                  align-items: center; z-index: 1000;
              `;
              document.body.appendChild(modal);
          }
          modal.innerHTML = `
              <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); max-width: 400px; width: 90%; text-align: center;">
                  <p style="color: black;">${message}</p>
                  <input type="text" id="customInput" style="width: calc(100% - 20px); padding: 8px; margin: 10px 0; border: 1px solid #ccc; border-radius: 4px;" />
                  <button id="inputOkBtn" style="padding: 8px 15px; margin: 5px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">확인</button>
                  <button id="inputCancelBtn" style="padding: 8px 15px; margin: 5px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">취소</button>
              </div>
          `;
          modal.style.display = 'flex';

          document.getElementById('inputOkBtn').onclick = () => {
              const inputValue = document.getElementById('customInput').value;
              modal.style.display = 'none';
              if (onInput) onInput(inputValue);
          };
          document.getElementById('inputCancelBtn').onclick = () => {
              modal.style.display = 'none';
              if (onInput) onInput(null);
          };
          document.getElementById('customInput').focus();
      }

      window.onclick = function(e) {
          // 모든 드롭다운 메뉴를 닫음 (툴바에 관계없이)
          const dropdowns = document.querySelectorAll('.dropdown-menu');
          dropdowns.forEach(d => {
              if (d.classList.contains('show') && !e.target.closest('.dropdown')) {
                  d.classList.remove('show');
              }
          });
      };

      function activateEditor(langCode) {
          // 모든 언어 블록 숨기기
          document.querySelectorAll('.lang-meta-block').forEach(block => {
              block.style.display = 'none';
          });

          // 선택된 언어 블록 보이기
          const activeLangBlock = document.querySelector(`.lang-meta-block[data-lang="${langCode}"]`);
          if (activeLangBlock) {
              activeLangBlock.style.display = '';

              const editorDiv = document.getElementById(`editor_${langCode}`);
              const htmlEditorDiv = document.getElementById(`htmlEditor_${langCode}`);
              const toolbarDiv = document.querySelector(`.toolbar[data-lang-toolbar="${langCode}"]`);

              currentActiveEditor = editorDiv;
              currentActiveHtmlEditor = htmlEditorDiv;
              currentActiveToolbar = toolbarDiv; // 활성 툴바 설정

              if (editorDiv) {
                  editorDiv.style.display = 'block'; // 디자인 모드 기본 활성화
                  htmlEditorDiv.style.display = 'none'; // HTML 모드 비활성화
                  editorDiv.focus();
                  detectStyle();
              }
          }
      }


      window.addEventListener('DOMContentLoaded', () => { // DOMContentLoaded로 변경하여 DOM이 완전히 로드된 후 스크립트 실행 보장
          // 카테고리 불러오기 및 렌더링
          fetch(`/api/categories?lang=${CURRENT_PAGE_LANG}`)
            .then(res => res.json())
            .then(data => {
              categories = data.categories || [];
              renderCategories();
            })
            .catch(err => {
              console.error("카테고리 불러오기 오류:", err);
              categories = ['일상', '기록', '리뷰']; // 대체 카테고리
              renderCategories();
            });

          // 언어 선택 드롭다운 초기값 설정
          document.getElementById('langSelector').value = CURRENT_PAGE_LANG;

          // 페이지 로드 시 현재 언어 (lang) 에디터를 활성화
          activateEditor(CURRENT_PAGE_LANG);

          // 모든 언어 에디터에 이벤트 리스너 추가
          const languageEditors = document.querySelectorAll('.language-editor');
          languageEditors.forEach(editor => {
              editor.addEventListener('keyup', detectStyle);
              editor.addEventListener('mouseup', detectStyle);
              editor.addEventListener('mouseup', saveSelection);
              editor.addEventListener('keyup', saveSelection);
              editor.addEventListener('focus', () => {
                  const langCode = editor.dataset.langEditor;
                  // 현재 활성화된 에디터와 툴바를 업데이트합니다.
                  currentActiveEditor = editor;
                  currentActiveHtmlEditor = document.getElementById(`htmlEditor_${langCode}`);
                  currentActiveToolbar = document.querySelector(`.toolbar[data-lang-toolbar="${langCode}"]`);
                  
                  // 포커스 시 HTML 모드였다면 디자인 모드로 자동 전환 (현재 언어 블록만 해당)
                  if (currentActiveHtmlEditor && currentActiveHtmlEditor.style.display !== 'none') {
                      switchToDesignMode(); 
                  }
                  detectStyle();
              });
          });

          // 툴바 버튼 이벤트 리스너 동적 할당
          document.querySelectorAll('.toolbar').forEach(toolbar => {
            toolbar.addEventListener('click', (event) => {
              const button = event.target.closest('button[data-command], .dropdown-toggle');
              // ⭐ 추가: 드롭다운 메뉴 내의 스타일 명령 요소를 찾도록 수정
              const styleCommandElement = event.target.closest('[data-style-command]');

              if (!button && !styleCommandElement) return; // 유효한 요소가 아니면 반환

              saveSelection(); // 명령 실행 전에 현재 선택 영역 저장

              // ⭐ 수정된 부분: styleCommandElement가 있다면 applyStyle 실행
              if (styleCommandElement) {
                  const styleCommand = styleCommandElement.dataset.styleCommand;
                  applyStyle(styleCommand);
                  // 스타일 적용 후 드롭다운 메뉴 닫기
                  const styleDropdown = styleCommandElement.closest('.dropdown-menu');
                  if (styleDropdown) {
                      styleDropdown.classList.remove('show');
                  }
                  // 클릭 이벤트가 툴바 전체로 전파되지 않도록 방지
                  event.stopPropagation(); 
              } else if (button) { // 기존 button 처리 로직
                const command = button.dataset.command;

                if (command) {
                  switch (command) {
                    case 'insertTOC':
                      insertTOC();
                      break;
                    case 'createLink':
                      showCustomInput("링크 URL을 입력하세요:", (url) => {
                        if (url) format('createLink', url);
                      });
                      break;
                    case 'insertImage':
                      insertImage();
                      break;
                    case 'openHtmlPopup':
                      showCustomMessage("HTML 삽입 기능은 현재 구현되지 않았습니다.");
                      break;
                    case 'removeFormat':
                      format('removeFormat');
                      break;
                    default:
                      format(command);
                      break;
                  }
                } else if (button.classList.contains('dropdown-toggle')) {
                  toggleDropdown();
                  // 드롭다운 토글 버튼 클릭 시 이벤트 전파 방지
                  event.stopPropagation(); 
                }
              }
            });

            // 색상 선택 버튼 및 팔레트 이벤트 리스너
            toolbar.querySelectorAll('[data-color-btn]').forEach(btn => {
                btn.addEventListener('mousedown', saveSelection); // mousedown 이벤트에서 selection 저장
                btn.addEventListener('click', (e) => {
                    const colorPalette = btn.closest('[data-color-tool]').querySelector('[data-color-palette]');
                    if (colorPalette) {
                        colorPalette.classList.toggle('show');
                    }
                    e.stopPropagation(); // 버튼 클릭 시 드롭다운 닫히지 않도록
                });
            });

            toolbar.querySelectorAll('[data-color-palette] button').forEach(colorBtn => {
                colorBtn.addEventListener('click', (e) => {
                    const command = colorBtn.closest('[data-color-tool]').dataset.colorTool;
                    const value = colorBtn.dataset.colorValue;
                    setColor(command, value);
                    e.target.closest('[data-color-palette]').classList.remove('show'); // 색 선택 후 팔레트 닫기
                });
            });

            toolbar.querySelectorAll('[data-color-input]').forEach(colorInput => {
                colorInput.addEventListener('change', (e) => {
                    const command = colorInput.closest('[data-color-tool]').dataset.colorTool;
                    setColor(command, e.target.value);
                    e.target.closest('[data-color-palette]').classList.remove('show'); // 색 선택 후 팔레트 닫기
                });
            });
          });

          // HTML/디자인 모드 토글 버튼 이벤트 리스너
          document.querySelectorAll('[data-mode-toggle]').forEach(button => {
            button.addEventListener('click', (event) => {
              const mode = event.target.dataset.modeToggle;
              if (mode === 'design') {
                switchToDesignMode();
              } else if (mode === 'html') {
                switchToHtmlMode();
              }
            });
          });
      });

      function insertTOC() {
        if (!currentActiveEditor) {
            showCustomMessage("에디터가 활성화되지 않았습니다.");
            return;
        }

        const blContentDiv = currentActiveEditor.querySelector('.bl-content');

        if (!blContentDiv) {
            showCustomMessage("에디터 내용이 올바른 형식이 아닙니다. 다시 시도해주세요.");
            return;
        }

        const headings = blContentDiv.querySelectorAll("h1, h2");
        if (!headings.length) {
            showCustomMessage("제목(h1)이나 부제목(h2)이 없어 목차를 만들 수 없습니다.");
            return;
        }

        // 기존 목차 제거
        const oldTOC = blContentDiv.querySelector(".auto-toc");
        if (oldTOC) oldTOC.remove();

        const tocWrapper = document.createElement("div");
        tocWrapper.className = "auto-toc";
        tocWrapper.contentEditable = "false";

        const tocTitle = document.createElement("strong");
        tocTitle.className = "toc-title";
        tocTitle.textContent = "📑 목차";

        const tocList = document.createElement("ul");
        tocList.className = "toc-list";
        tocList.style.margin = "0";
        tocList.style.padding = "0";

        let h1Count = 0;
        let h2Count = 0;

        headings.forEach(el => {
            const tag = el.tagName.toLowerCase();
            let number = "";

            if (tag === "h1") {
            h1Count++;
            h2Count = 0;
            number = `${h1Count}.`;
            } else if (tag === "h2") {
            h2Count++;
            number = `${h1Count}.${h2Count}`;
            }

            // ID 부여 (기존 ID 무시하고 항상 재생성)
            const id = `toc-${number.replace(/\./g, "-")}`;
            el.id = id;

            const li = document.createElement("li");
            li.className = `toc-item toc-${tag}`;

            const a = document.createElement("a");
            a.href = `#${id}`;
            a.textContent = `${number} ${el.textContent.trim()}`;
            a.onclick = function(e) {
            e.preventDefault();
            document.getElementById(id)?.scrollIntoView({ behavior: "smooth" });
            };

            li.appendChild(a);
            tocList.appendChild(li);
        });

        tocWrapper.appendChild(tocTitle);
        tocWrapper.appendChild(tocList);

        // ✅ 목차를 bl-content 가장 위에 삽입 (prepend 방식)
        blContentDiv.prepend(tocWrapper);
      }

      function switchToHtmlMode() {
        if (!currentActiveEditor || !currentActiveHtmlEditor || !currentActiveToolbar) {
            console.error("HTML 모드 전환 실패: 활성 에디터 또는 툴바 없음");
            return;
        }

        let currentContent = currentActiveEditor.innerHTML.trim();

        // ✅ bl-content로 감싸져 있는지 확인
        const isWrapped = currentContent.startsWith('<div class="bl-content"');

        if (!isWrapped) {
            // 빈 상태도 감싸기
            if (!currentContent || currentContent === '<p><br></p>' || currentContent === '<div><br></div>') {
                currentContent = '<p><br></p>';
            }

            currentContent = `
<div class="bl-content" style="white-space:normal; line-height: 1.7;">
${currentContent}
</div>`.trim();
        }

        currentActiveHtmlEditor.value = html_beautify(currentContent, {
            indent_size: 2,
            wrap_attributes: 'auto',
            indent_with_tabs: false
        });

        currentActiveEditor.style.display = 'none';
        currentActiveHtmlEditor.style.display = 'block';
        currentActiveToolbar.style.display = 'none'; // HTML 모드 시 툴바 숨기기 (선택 사항)
      }

      function switchToDesignMode() {
        if (!currentActiveEditor || !currentActiveHtmlEditor || !currentActiveToolbar) {
            console.error("디자인 모드 전환 실패: 활성 에디터 또는 툴바 없음");
            return;
        }

        let rawHtml = currentActiveHtmlEditor.value.trim();

        // ✅ bl-content 감싸기 누락 시 자동 추가
        if (!rawHtml.startsWith('<div class="bl-content"')) {
            rawHtml = `<div class="bl-content" style="white-space:normal; line-height: 1.7;">${rawHtml}</div>`;
        }

        currentActiveEditor.innerHTML = rawHtml;
        currentActiveHtmlEditor.style.display = 'none';
        currentActiveEditor.style.display = 'block';
        currentActiveToolbar.style.display = 'flex'; // 디자인 모드 시 툴바 보이기 (선택 사항)
        currentActiveEditor.focus();
        detectStyle();
      }

   
  </script>

<%- include('partials/footer') %>
<%- include('partials/scripts') %>

</body>
</html>