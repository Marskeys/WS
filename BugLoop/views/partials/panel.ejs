<style>
    :root { --header-h: 30px;   --panel-h-default: 150px; --panel-h: var(--panel-h-default);}
  
    :root{
      --ide-w: 50px;     /* VSCode 사이드바 폭 */
      --panel-w: 360px;  /* 확장 패널 폭 */
      --gut: 2.5vw;      /* 양옆 여백 비율 */
    }
  
    @media (max-width: 768px){
      :root {--panel-h-default: 220px; --panel-h: var(--panel-h-default);}
    }
  
    /* 컨테이너 */
    #mini-lecture{
      position: fixed;
      top: var(--header-h, 0);
      z-index: 40;
      left:  calc(var(--ide-w) + var(--gut));
      right: var(--gut);
      height: var(--panel-h);
      min-height: 20px;
      display: grid;
      grid-template-rows: minmax(0, 1fr) 20px;
      overflow: hidden;
  
      /* 엄청 쎈 멀티 레이어 섀도우 */
      box-shadow:
        0 60px 140px -30px rgba(0,0,0,.70),
        0 30px  70px -20px rgba(0,0,0,.60),
        0 14px  30px -10px rgba(0,0,0,.50),
        0  2px   8px  -2px rgba(0,0,0,.45),
        0  0     0   1px  rgba(0,0,0,.28); /* 가장자리 정리용 */
    }
  
    /* 열림 상태: (ide 50px + 패널 360px) 제외한 나머지의 2.5% 여백 */
    body.panel-open #mini-lecture{
      left:  calc(var(--ide-w) + var(--panel-w) + (100vw - (var(--ide-w) + var(--panel-w))) * 0.025);
      right: calc((100vw - (var(--ide-w) + var(--panel-w))) * 0.025);
    }
  
    @media (max-width: 768px){
      :root{
        --ide-w: 0px;     /* 모바일에선 좌측 IDE 없음 */
        --panel-w: 0px;   /* 확장 패널도 좌측이 아니라 상단이라 0 취급 */
      }
  
      /* 본문 밀림 제거 (데스크탑 규칙 무효화) */
      body,
      body.panel-open{
        padding-left: 0 !important;
      }
  
      /* ✅ fixed 패널은 모바일에서 left/right만 쓰고 width/margin 제거 */
      #mini-lecture{
        top: 77px;
        left: 15px !important;
        right: 15px !important;
        width: auto !important;
        margin: 0 !important;
        padding-left: 0 !important;
      }
    }
  
    /* 패널 내용(자체 스크롤 + 체이닝 차단) */
    #mini-lecture .panel-card{
      background: #2a5d06;
      color: #eee;
      border: 1px solid #333;
      border-bottom: 0;
      box-shadow: 0 10px 30px rgba(0,0,0,.4);
      padding: 16px;
      overflow: auto;
      min-height: 0;                 /* ✅ 0까지 허용 (완전 접힘) */
      overscroll-behavior: contain;  /* ✅ 스크롤 체이닝 차단 */
      -webkit-overflow-scrolling: touch;
    }
  
    #mini-lecture .connector{
      display: inline-block;
      margin-bottom: 8px;
      background: #000;
      color: #fff;
      border: 1px solid #333;
      border-bottom: 0;
      border-radius: 10px;
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 700;
    }
  
    .chip{
      display: inline-block;
      margin-top: 8px;
      margin-right: 6px;
      background: #1a1a1a;
      color: #ddd;
      border: 1px solid #333;
      padding: 6px 10px;
      font-size: 12px;
    }
  
    /* 리사이저 */
    #panel-resizer{
      grid-row: 2;
      height: 16px; /* ✅ 리사이저 자체 20px */
      border: 0;
      cursor: ns-resize;
      background: #313131;
      transition: background .15s ease, box-shadow .15s ease;
      position: relative;
      touch-action: none;
    }
    #panel-resizer::before{
      content: "";
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: 70px; height: 4px; border-radius: 999px; /* ✅ 20px에 맞게 높이 조정 */
      background: linear-gradient(90deg, #777, #aaa, #777);
      opacity: .9;
    }
    #panel-resizer::after{
      content: "";
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: 70px; height: 20px; /* ✅ 핸들 패턴 높이도 20px로 조정 */
      pointer-events: none;
      color: #666;
      opacity: .55;
      background: radial-gradient(currentColor 1px, transparent 2px) 0 50%/10px 8px repeat-x;
    }
    #panel-resizer:hover,
    #panel-resizer:focus-visible,
    body.resizing #panel-resizer{
      background: #181818;
      box-shadow: inset 0 0 0 1px #444, 0 0 0 2px rgba(255,255,255,.05);
    }
    #panel-resizer:hover::before,
    #panel-resizer:focus-visible::before{
      transform: translate(-50%, -50%) scaleX(1.08);
    }
  
    /* 모바일 동일 보장 */
    @media (max-width: 640px){
      #mini-lecture{
        height: var(--panel-h);
        min-height: 20px; /* ✅ 모바일도 20px까지 접힘 */
      }
    }
  
    body.resizing{ user-select: none; }
  
    /* ✅ 배경 스크롤 잠금 */
    html.lock-scroll, body.lock-scroll{
      overflow: hidden !important;
      height: 100%;
      touch-action: none;
      overscroll-behavior: none;
    }
  </style>
  
  <div id="mini-lecture" role="region" aria-label="미니 강의 패널">
    <div class="panel-card">
      <span class="connector">Welcome</span>
      <% if (panelData && panelData.html) { %>
        <div class="panel-body"><%- panelData.html %></div>
      <% } else { %>
        <h3 style="margin:0 0 6px 0"><%= panelData.title %></h3>
        <p style="margin:0;opacity:.9"><%= panelData.body %></p>
      <% } %>
    </div>
  
    <div id="panel-resizer"
         role="separator"
         aria-orientation="horizontal"
         aria-label="패널 높이 조절"
         aria-valuemin="20"   aria-valuemax="800"
         aria-valuenow="500"
         tabindex="0"
         title="드래그하거나 ↑/↓ 키로 높이 조절"></div>
  </div>
  
  <script>
    /* ===== 패널 리사이저 ===== */
    (function(){
      const root = document.documentElement;
      const resizer = document.getElementById('panel-resizer');
      if(!resizer) return;
  
      /* ✅ aria와 동기화: HTML의 min/max 값을 그대로 사용 */
      const MIN = parseInt(resizer.getAttribute('aria-valuemin'), 10) || 20;
      const MAX = parseInt(resizer.getAttribute('aria-valuemax'), 10) || 800;
      const STEP = 16, BIG = 64;
      const VAR = '--panel-h';
      const KEY = 'miniPanelH_session';      // ✅ 세션 저장 (탭 생명주기)
  
      // 홈 경로 판단: /, /ko, /en, /ko/ 같은 루트
      const isHomePath = (p) => p === '/' || /^\/[a-z]{2}\/?$/.test(p);
  
      const getDefaultPx = () => {
        const v = getComputedStyle(root).getPropertyValue('--panel-h-default').trim() || '500px';
        return parseInt(v, 10) || 500;
      };
  
      const clamp = v => Math.max(MIN, Math.min(MAX, v|0));
  
      const setH = (h, save=false) => {
        const n = clamp(parseInt(h, 10));
        root.style.setProperty(VAR, n + 'px');
        resizer.setAttribute('aria-valuenow', String(n));
        if (save) sessionStorage.setItem(KEY, n + 'px');
      };
  
      // ===== 초기화: 홈이면 기본값으로 리셋, 아니면 세션 값 적용 =====
      (function init(){
        if (isHomePath(location.pathname)) {
          sessionStorage.removeItem(KEY);           // ✅ 홈 진입 시 리셋
          root.style.removeProperty(VAR);           //   → --panel-h-default 사용
          resizer.setAttribute('aria-valuenow', String(getDefaultPx()));
        } else {
          const saved = sessionStorage.getItem(KEY);
          if (saved) setH(saved, false);
          else root.style.removeProperty(VAR);      // 기본값 사용
        }
      })();
  
      // ARIA 범위(보강)
      resizer.setAttribute('aria-valuemin', String(MIN));
      resizer.setAttribute('aria-valuemax', String(MAX));
  
      let startY = 0, startH = 0, dragging = false;
  
      function move(e){
        if(!dragging) return;
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        setH(startH + (y - startY));                // 드래그 중 저장 X
        e.preventDefault?.();
      }
      function up(){
        if(!dragging) return;
        dragging = false;
        document.body.classList.remove('resizing');
        const cur = parseInt(getComputedStyle(root).getPropertyValue(VAR),10) || getDefaultPx();
        setH(cur, true);                            // ✅ 드래그 끝날 때만 저장(세션)
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', up);
        window.removeEventListener('touchmove', move);
        window.removeEventListener('touchend', up);
      }
      function down(e){
        dragging = true;
        document.body.classList.add('resizing');
        startY = (e.touches ? e.touches[0].clientY : e.clientY);
        startH = parseInt(getComputedStyle(root).getPropertyValue(VAR),10) || getDefaultPx();
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', up);
        window.addEventListener('touchmove', move, { passive:false });
        window.addEventListener('touchend', up);
        e.preventDefault?.();
      }
  
      resizer.addEventListener('mousedown', down);
      resizer.addEventListener('touchstart', down, { passive:false });
  
      // 키보드 조작
      resizer.addEventListener('keydown', (e)=>{
        const cur = parseInt(getComputedStyle(root).getPropertyValue(VAR),10) || getDefaultPx();
        if(e.key === 'ArrowUp'){    setH(cur - (e.shiftKey ? BIG : STEP), true); e.preventDefault(); }
        else if(e.key === 'ArrowDown'){ setH(cur + (e.shiftKey ? BIG : STEP), true); e.preventDefault(); }
        else if(e.key === 'Home'){  setH(MIN, true); e.preventDefault(); }
        else if(e.key === 'End'){   setH(MAX, true); e.preventDefault(); }
        else if(e.key === 'Enter' || e.key === ' '){ setH(getDefaultPx(), true); e.preventDefault(); }
      });
    })();
  </script>
  
  <script>
    /* ===== 현재 활성 서브메뉴 → 패널 상단 라벨 반영 (기존) ===== */
    document.addEventListener('DOMContentLoaded', () => {
      const activeMenu = document.querySelector('.submenu a.active');
      const connector = document.querySelector('#mini-lecture .connector');
      if (activeMenu && connector) {
        connector.textContent = activeMenu.textContent.trim();
      }
    });
  </script>
  
  <script>
    /* ===== 배경 스크롤 잠금 & 체이닝 완전 차단 (URL 변경 후에도 유지) ===== */
    (function(){
      let state = { panel: null, scroller: null, cleanups: [] };
  
      const addLock = () => {
        document.documentElement.classList.add('lock-scroll');
        document.body.classList.add('lock-scroll');
      };
      const removeLock = () => {
        document.documentElement.classList.remove('lock-scroll');
        document.body.classList.remove('lock-scroll');
      };
      const cleanupAll = () => {
        state.cleanups.forEach(fn => { try { fn(); } catch(e){} });
        state.cleanups = [];
      };
  
      function bindScrollTrap(){
        cleanupAll();
        removeLock(); // 네비 직후 남아있을 수 있는 락 해제
  
        state.panel    = document.getElementById('mini-lecture');
        state.scroller = state.panel?.querySelector('.panel-card') || null;
        if (!state.panel || !state.scroller) return;
  
        /* 진입/이탈 시 배경 잠금 */
        const onEnter   = () => addLock();
        const onLeave   = (e) => { if (!state.panel.contains(e.relatedTarget)) removeLock(); };
        const onFocusIn = onEnter;
        const onFocusOut= (e) => { if (!state.panel.contains(e.relatedTarget)) removeLock(); };
  
        state.panel.addEventListener('pointerenter', onEnter);
        state.panel.addEventListener('pointerleave', onLeave);
        state.panel.addEventListener('focusin', onFocusIn);
        state.panel.addEventListener('focusout', onFocusOut);
        state.cleanups.push(() => {
          state.panel.removeEventListener('pointerenter', onEnter);
          state.panel.removeEventListener('pointerleave', onLeave);
          state.panel.removeEventListener('focusin', onFocusIn);
          state.panel.removeEventListener('focusout', onFocusOut);
        });
  
        /* 사파리 등 바운스 방지 */
        const onWheel = (e) => {
          const s = state.scroller;
          const atTop = s.scrollTop <= 0 && e.deltaY < 0;
          const atBottom = s.scrollTop + s.clientHeight >= s.scrollHeight && e.deltaY > 0;
          if (atTop || atBottom) e.preventDefault();
        };
        state.scroller.addEventListener('wheel', onWheel, { passive: false });
        state.cleanups.push(() => state.scroller.removeEventListener('wheel', onWheel));
  
        let startY = 0;
        const onTouchStart = (e) => { startY = e.touches[0].clientY; };
        const onTouchMove  = (e) => {
          const s = state.scroller;
          const curY = e.touches[0].clientY;
          const delta = startY - curY;
          const atTop = s.scrollTop <= 0 && delta < 0;
          const atBottom = s.scrollTop + s.clientHeight >= s.scrollHeight && delta > 0;
          if (atTop || atBottom) e.preventDefault();
        };
        state.scroller.addEventListener('touchstart', onTouchStart, { passive: true });
        state.scroller.addEventListener('touchmove', onTouchMove, { passive: false });
        state.cleanups.push(() => {
          state.scroller.removeEventListener('touchstart', onTouchStart);
          state.scroller.removeEventListener('touchmove', onTouchMove);
        });
  
        /* 패널 내부 DOM 교체 감지 → 재바인딩 */
        const mo = new MutationObserver(() => {
          const cur = state.panel.querySelector('.panel-card');
          if (cur !== state.scroller) bindScrollTrap();
        });
        mo.observe(state.panel, { childList: true, subtree: true });
        state.cleanups.push(() => mo.disconnect());
      }
  
      function onLocationChange(){
        // DOM 업데이트가 반영된 뒤 재바인딩
        requestAnimationFrame(bindScrollTrap);
      }
  
      document.addEventListener('DOMContentLoaded', () => {
        bindScrollTrap();
  
        /* pushState / replaceState 훅 + popstate */
        const _pushState = history.pushState;
        const _replaceState = history.replaceState;
        history.pushState = function(){
          const ret = _pushState.apply(this, arguments);
          onLocationChange();
          return ret;
        };
        history.replaceState = function(){
          const ret = _replaceState.apply(this, arguments);
          onLocationChange();
          return ret;
        };
        window.addEventListener('popstate', onLocationChange);
  
        /* 일반 a 태그(헤더 메뉴 등) 클릭 뒤에도 재바인딩 시도 */
        document.addEventListener('click', (e) => {
          const a = e.target.closest('a');
          if (!a) return;
          // SPA 내 panel만 교체하거나 data-panel-link로 처리하는 경우도 커버
          if (a.matches('[data-panel-link], [data-panel], nav a, .submenu a')) {
            setTimeout(onLocationChange, 0);
          }
        }, true);
      });
    })();
  </script>
  